{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4989a357_ecc6f208",
        "filename": "src/vnet/tcp/tcp_inlines.h",
        "patchSetId": 10
      },
      "lineNbr": 243,
      "author": {
        "id": 3187
      },
      "writtenOn": "2025-02-18T11:32:13Z",
      "side": 1,
      "message": "we recently absorbed this change via an update to our VPP baseline version.\nIts causing coring because the ip.rx_sw_if_index has large incorrect values.\nThey i guess are clobbered by TCP opaque info sent from our passive proxy plugin node --\u003e TCP stack for uplink packets- what happens then is if there is a TCP stack RESET (node tcp-reset) it cores in subsequent node:\ntcp46_reset_inline :\n     /* IP lookup in fib where it was received. Previous value\n       * was overwritten by tcp-input */\n      vnet_buffer (b[0])-\u003esw_if_index[VLIB_TX] \u003d\n        vec_elt (ip4_main.fib_index_by_sw_if_index,\n                 vnet_buffer (b[0])-\u003esw_if_index[VLIB_RX]); \n\n\nbecause sw_if_index[VLIB_RX] is a large incorrect num, TX gets the wrong index -\nit then cores inside ip4-lookup -\n\nis it safe for me to remove this one line? or should the full patch be reverted in our code base?",
      "revId": "bfa86084af0e4d0cc8ad8ccbeafe999b748a990e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9bdc5439_8a36a273",
        "filename": "src/vnet/tcp/tcp_inlines.h",
        "patchSetId": 10
      },
      "lineNbr": 243,
      "author": {
        "id": 193
      },
      "writtenOn": "2025-02-18T22:54:50Z",
      "side": 1,
      "message": "Hey Aidan! This is actually moved lower (line 314) in newer versions of vpp, in case the connection is not found (which maybe is the actual scenario you\u0027re hitting).\n\nIt might also be okay to remove this code, as long as you\u0027re not relying on setting the right sw_if_index on the outgoing packets. But ideally, if we have a plugin between ip-local and tcp-input, it should not touch `vnet_buffer (b)-\u003eip.rx_sw_if_index`",
      "parentUuid": "4989a357_ecc6f208",
      "revId": "bfa86084af0e4d0cc8ad8ccbeafe999b748a990e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "feb728c9_a4af9428",
        "filename": "src/vnet/tcp/tcp_inlines.h",
        "patchSetId": 10
      },
      "lineNbr": 243,
      "author": {
        "id": 3187
      },
      "writtenOn": "2025-02-19T15:31:06Z",
      "side": 1,
      "message": "Hi Florin,\nthanks for the response. Yes i think i have that version u mention (line 314) [VPP 2310].\nFrom my tests I don\u0027t see this value ever getting set as in i don\u0027t see ip4_local_check_src_x2 nor ip4_local_check_src getting called in normal wget requests. It looks to me therefore this has half random/half clobbered value by the time tcp_input_lookup_buffer is called - If we track normal uplink packet on our system:\n\n1. opwv-tp4-input (opwv) node [this overloads opaque-\u003etcp fields]\n2. opwv-tp4-passive (opwv) node [this resets the tcp fields]\n3. opwv-tp4-control (opwv) node [proxy app node which now directs to TCP stack]\n4. tcp4-input-nolookup node [this now sets sw RX to ip.rx_sw_if_index \n  ip.rx_sw_if_index \u003d\u003d tcp.data_len (+ flags and another byte)\n \n//if its a reset scenario it continues to a crash\n5. tcp4-reset  [uses RX in #4 to find TX which is random value]\n6. ip4-lookup  \u003c\u003c\u003ccore dumps here as TX index is completely wrong\n\nI guess given this and the fact we don\u0027t seem to trigger that DPO code (its for different traffic to our client/server proxied packets?), i assume i can\nremove all the patch if need be - would need to then check TCP resets use correct sw index",
      "parentUuid": "9bdc5439_8a36a273",
      "revId": "bfa86084af0e4d0cc8ad8ccbeafe999b748a990e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    }
  ]
}