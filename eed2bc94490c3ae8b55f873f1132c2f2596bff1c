{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8ded675f_e619b1fa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 361
      },
      "writtenOn": "2023-01-03T10:38:51Z",
      "side": 1,
      "message": "I\u0027m a bit wary of letting the tx function running for too long, what about using a timeout instead of a retry count?",
      "revId": "eed2bc94490c3ae8b55f873f1132c2f2596bff1c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7d57f65f_9cb6f355",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 2837
      },
      "writtenOn": "2023-01-04T04:24:20Z",
      "side": 1,
      "message": "This maybe not a problem, if the bandwidth is not enough or the kernel issues cause the sending time to be too long, we will definitely lose the packet. I think it is better to spend on sending, so that the packets can be dropped earlier.\n\nHow about calling `af_xdp_device_output_tx_db` once per 32 or 64 packages?",
      "parentUuid": "8ded675f_e619b1fa",
      "revId": "eed2bc94490c3ae8b55f873f1132c2f2596bff1c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "753cc11c_dba48424",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 361
      },
      "writtenOn": "2023-01-05T15:38:25Z",
      "side": 1,
      "message": "The problem is that while VPP worker process packets, most control plane operations (including API calls) are blocked. It is not good to block for too long. In the worst case, if we block for more than 1s, VPP worker barrier watchdog will trigger an abort.\nMoreover, blocking too much on tx can also trigger bufferbloat.\nAll in all, I think we want to allow blocking on tx long enough to send all packets in most situation, but not for too long.\n\nRegarding calling af_xdp_device_output_tx_db once every 32/64 packets, I\u0027m not sure what it would solve?",
      "parentUuid": "7d57f65f_9cb6f355",
      "revId": "eed2bc94490c3ae8b55f873f1132c2f2596bff1c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4f428f00_292209ed",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 2837
      },
      "writtenOn": "2023-01-06T11:27:45Z",
      "side": 1,
      "message": "node processes max 256 packets at a time.\n`af_xdp_device_output_tx_db` is called to process 256 packages at a time, worrying that it will take too long in the kernel. So, I think it makes more sense to refer to DPDK and call `af_xdp_device_output_tx_db` every 32 packets.\n\nCan you provide some more explicit advice on timeout instead of retry?",
      "parentUuid": "753cc11c_dba48424",
      "revId": "eed2bc94490c3ae8b55f873f1132c2f2596bff1c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "092f05de_943786d3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 361
      },
      "writtenOn": "2023-01-06T15:37:59Z",
      "side": 1,
      "message": "\u003e node processes max 256 packets at a time.\n\u003e `af_xdp_device_output_tx_db` is called to process 256 packages at a time, worrying that it will take too long in the kernel. So, I think it makes more sense to refer to DPDK and call `af_xdp_device_output_tx_db` every 32 packets.\n\u003e Can you provide some more explicit advice on timeout instead of retry?\n\nI\u0027m not worried about the syscall taking too long, it should be non-blocking in this case and should return in a reasonable amount of time.\nWhat I\u0027m worried is if for some reason the kernel takes a long time to send all the packets, we\u0027ll be continuously busy-looping doing syscalls until it\u0027s fully done. My issue are not the syscalls (we have to pay for them anyway, we\u0027re trying to send packets), but the busy-loop.",
      "parentUuid": "4f428f00_292209ed",
      "revId": "eed2bc94490c3ae8b55f873f1132c2f2596bff1c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9dc8f88b_a0da9f13",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 361
      },
      "writtenOn": "2023-01-06T16:37:15Z",
      "side": 1,
      "message": "Actually, I remember the issue now! There is https://gerrit.fd.io/r/c/vpp/+/34668 quietly rusting...\nThe issue stems from the kernel AF_XDP code which limits a TX batch to a magic value defined only in net/xdp/xsk.c. I think it used to be 16 and is 32 now.\nSo if we try to send more than this (say 256), we\u0027ll fail and drop the rest. Which obviously is not ideal.\nThe difficulty is we do not know this magic value in userspace, hence my other patch retrying as long as we get EAGAIN.",
      "revId": "eed2bc94490c3ae8b55f873f1132c2f2596bff1c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "09762c4c_ec0a3199",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 2837
      },
      "writtenOn": "2023-01-13T13:13:04Z",
      "side": 1,
      "message": "Well done!\n\nI think we should commit these two patches together.\n\nAnd, I think this patch(https://gerrit.fd.io/r/c/vpp/+/34668) should be changed look like below:\n\n```\n      do\n\t{\n\t  ret \u003d poll (\u0026fd, 1, 0);\n\t}\n      while (ret \u003c 0 \u0026\u0026 EAGAIN \u003d\u003d errno);\n```",
      "parentUuid": "9dc8f88b_a0da9f13",
      "revId": "eed2bc94490c3ae8b55f873f1132c2f2596bff1c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6c39be86_feba6fbe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 2837
      },
      "writtenOn": "2023-01-17T07:39:48Z",
      "side": 1,
      "message": "Sorry, my last commit about (https://gerrit.fd.io/r/c/vpp/+/34668) is not correct. Ignore that pls.",
      "parentUuid": "09762c4c_ec0a3199",
      "revId": "eed2bc94490c3ae8b55f873f1132c2f2596bff1c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b57bb168_99c2ab28",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 2837
      },
      "writtenOn": "2023-01-28T07:28:31Z",
      "side": 1,
      "message": "```\nit should be non-blocking in this case and should return in a reasonable amount of time.\n```\nOn my server, kernel 5.10 + Mellanox CX-5 network card driven by mlx5_core. af_xdp is not zero-copy(I do not know why, zero-copy should have higher performance), the function call relationship is:\n```\nxsk_poll -\u003e __xsk_sendmsg -\u003e xsk_generic_xmit\n```\nThe system call does not return immediately, instead, it sends a batch of up to 16 packages and then returns.",
      "parentUuid": "092f05de_943786d3",
      "revId": "eed2bc94490c3ae8b55f873f1132c2f2596bff1c",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    }
  ]
}