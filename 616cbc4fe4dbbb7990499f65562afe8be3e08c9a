{
  "comments": [
    {
      "key": {
        "uuid": "7c52bd5a_b72ec4b8",
        "filename": "src/svm/svm_fifo.c",
        "patchSetId": 48
      },
      "lineNbr": 360,
      "author": {
        "id": 1561
      },
      "writtenOn": "2020-01-20T15:06:14Z",
      "side": 1,
      "message": "By this increment, the `*tail` may go beyond the end of allocated chunk, which would cause a problem.\n\nI don\u0027t have a good alternative code, but I guess it requires some condition check as following:\n\n    if (*tail + bytes \u003c\u003d f_chunk_end (f-\u003eend_chunk))\n      {\n        *tail \u003d *tail + bytes;\n        ooo_segment_free (f, s_index);\n         :",
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71005f53_92647125",
        "filename": "src/svm/svm_fifo.c",
        "patchSetId": 48
      },
      "lineNbr": 360,
      "author": {
        "id": 193
      },
      "writtenOn": "2020-01-20T16:23:27Z",
      "side": 1,
      "message": "\"bytes\" must\u0027ve been written to some allocated chunk. So at most *tail + bytes \u003d\u003d head + f-\u003esize \u003d\u003d f_chunk_end (f-\u003eend_chunk). Why would that be an issue?\n\nThe caller makes sure afterwards to advance tail_chunk as much as needed by doing: \nf-\u003etail_chunk \u003d f_lookup_clear_chunks (f, \u0026f-\u003eooo_enq_lookup, old_tail_c, tail);",
      "parentUuid": "7c52bd5a_b72ec4b8",
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "01a679fc_f201e949",
        "filename": "src/svm/svm_fifo.c",
        "patchSetId": 48
      },
      "lineNbr": 360,
      "author": {
        "id": 1561
      },
      "writtenOn": "2020-01-20T17:02:51Z",
      "side": 1,
      "message": "My understanding on ooo-segments seems incorrect more or less, unfortunately.\n\nSo, according to your comments, the existing of an ooo-segment in f-\u003eooo_segments means the corresponding data has been already written in some existing chunk before. Right?\nThen, the happening of the condition `(*tail + bytes \u003e f_chunk_end (f-\u003eend_chunk))` should indicate that the issue happened much earlier. Let me check again if I\u0027ve merged your code correctly.",
      "parentUuid": "71005f53_92647125",
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ab32938c_45ed448a",
        "filename": "src/svm/svm_fifo.c",
        "patchSetId": 48
      },
      "lineNbr": 360,
      "author": {
        "id": 193
      },
      "writtenOn": "2020-01-20T17:28:22Z",
      "side": 1,
      "message": "Yes, ooo enqueues means we enqueue data in a chunk and track it with ooo segments. The latter are used to track ooo writes/enqueues and figure out when the data is finally contiguous. \n\nAnd yes, the fact that the condition fails suggests something wrong happened at an earlier stage.",
      "parentUuid": "01a679fc_f201e949",
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13c6acc5_b0179fe8",
        "filename": "src/svm/svm_fifo.c",
        "patchSetId": 48
      },
      "lineNbr": 414,
      "author": {
        "id": 193
      },
      "writtenOn": "2020-01-17T18:38:33Z",
      "side": 1,
      "message": "by default, min_alloc is 4096 if first_chunk (rounded fifo size) is less than 16kB, first_chunk size / 4 if larger. After 256kB it\u0027s capped to 64kB\n\nI guess this can be fine tuned going forward. Otherwise, fifo tuning logic could change this based on memory pressure",
      "range": {
        "startLine": 413,
        "startChar": 2,
        "endLine": 414,
        "endChar": 47
      },
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20b2c838_9dd30bca",
        "filename": "src/svm/svm_fifo.c",
        "patchSetId": 48
      },
      "lineNbr": 818,
      "author": {
        "id": 193
      },
      "writtenOn": "2020-01-17T18:38:33Z",
      "side": 1,
      "message": "This means each grow request will add a minimum of min_alloc bytes to the fifo, if enough free space is left. Otherwise, alloc size is bound by the amount of free space. \n\nIf the write is larger than alloc_size, i.e., write is larger than min_alloc, we use len - free_alloced as an upper alloc bound.",
      "range": {
        "startLine": 818,
        "startChar": 25,
        "endLine": 818,
        "endChar": 37
      },
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7f0ec54c_a9f899cc",
        "filename": "src/svm/svm_fifo.c",
        "patchSetId": 48
      },
      "lineNbr": 818,
      "author": {
        "id": 1561
      },
      "writtenOn": "2020-01-20T11:01:27Z",
      "side": 1,
      "message": "I agree with the idea here. It should work fine even with a large difference between the current actual size and the (virtual) size. So it will be kept safe for the large f-\u003esize (relatively too large than the current actual size).\n\nJust to sharing my thoughts..., I thought the calculation would be something as following, but I suppose it doesn\u0027t really matter because of the effect of clib_min with the f-\u003emin_alloc.\n  actual_size \u003d f_chunk_end (f-\u003eend_chunk) - f-\u003estart_chunk-\u003estart_byte;\n  alloc_size \u003d clib_min (f-\u003emin_alloc, f-\u003esize - actual_size);\n  alloc_size \u003d clib_max (alloc_size, len - free_alloced);",
      "parentUuid": "20b2c838_9dd30bca",
      "range": {
        "startLine": 818,
        "startChar": 25,
        "endLine": 818,
        "endChar": 37
      },
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f833b9d3_cf2a055f",
        "filename": "src/svm/svm_fifo.c",
        "patchSetId": 48
      },
      "lineNbr": 818,
      "author": {
        "id": 193
      },
      "writtenOn": "2020-01-20T15:55:36Z",
      "side": 1,
      "message": "Actual size above can be larger than f-\u003esize. Fifo is usable only from head onwards and head \u003e\u003d f-\u003estart_chunk-\u003estart_byte\n\nSo we\u0027re capping f-\u003emin_alloc to whatever amount of free space we have in the fifo.",
      "parentUuid": "7f0ec54c_a9f899cc",
      "range": {
        "startLine": 818,
        "startChar": 25,
        "endLine": 818,
        "endChar": 37
      },
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7c5c58ba_a1e9ce4c",
        "filename": "src/svm/svm_fifo.h",
        "patchSetId": 48
      },
      "lineNbr": 134,
      "author": {
        "id": 1561
      },
      "writtenOn": "2020-01-20T17:20:23Z",
      "side": 1,
      "message": "I guess, this should be something equivalent to:\n  return (f_chunk_end (f-\u003eend_chunk) - (tail - f-\u003estart_chunk-\u003estart_byte));",
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a53424aa_11db2511",
        "filename": "src/svm/svm_fifo.h",
        "patchSetId": 48
      },
      "lineNbr": 134,
      "author": {
        "id": 193
      },
      "writtenOn": "2020-01-20T17:36:13Z",
      "side": 1,
      "message": "This is free bytes in the fifo. Fifo starts at head and ends at head + f-\u003esize and tail - head is the amount of bytes that are used. At most tail \u003d head + f-\u003esize.\n\nSo this is not the amount of bytes that are not used at the end of the fifo. Also, keep in mind that head !\u003d f-\u003estart_chunk-\u003estart_byte and head - f-\u003estart_chunk-\u003estart_byte are unusable but not \"free-able\". \n\nAlso, we try to separate fifo logic (head, tail, size, used bytes, free bytes) from chunk allocation logic (chunk linked list).",
      "parentUuid": "7c5c58ba_a1e9ce4c",
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    }
  ]
}