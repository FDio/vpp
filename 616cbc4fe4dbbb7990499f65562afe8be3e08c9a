{
  "comments": [
    {
      "key": {
        "uuid": "7c52bd5a_b72ec4b8",
        "filename": "src/svm/svm_fifo.c",
        "patchSetId": 48
      },
      "lineNbr": 360,
      "author": {
        "id": 1561
      },
      "writtenOn": "2020-01-20T15:06:14Z",
      "side": 1,
      "message": "By this increment, the `*tail` may go beyond the end of allocated chunk, which would cause a problem.\n\nI don\u0027t have a good alternative code, but I guess it requires some condition check as following:\n\n    if (*tail + bytes \u003c\u003d f_chunk_end (f-\u003eend_chunk))\n      {\n        *tail \u003d *tail + bytes;\n        ooo_segment_free (f, s_index);\n         :",
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13c6acc5_b0179fe8",
        "filename": "src/svm/svm_fifo.c",
        "patchSetId": 48
      },
      "lineNbr": 414,
      "author": {
        "id": 193
      },
      "writtenOn": "2020-01-17T18:38:33Z",
      "side": 1,
      "message": "by default, min_alloc is 4096 if first_chunk (rounded fifo size) is less than 16kB, first_chunk size / 4 if larger. After 256kB it\u0027s capped to 64kB\n\nI guess this can be fine tuned going forward. Otherwise, fifo tuning logic could change this based on memory pressure",
      "range": {
        "startLine": 413,
        "startChar": 2,
        "endLine": 414,
        "endChar": 47
      },
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20b2c838_9dd30bca",
        "filename": "src/svm/svm_fifo.c",
        "patchSetId": 48
      },
      "lineNbr": 818,
      "author": {
        "id": 193
      },
      "writtenOn": "2020-01-17T18:38:33Z",
      "side": 1,
      "message": "This means each grow request will add a minimum of min_alloc bytes to the fifo, if enough free space is left. Otherwise, alloc size is bound by the amount of free space. \n\nIf the write is larger than alloc_size, i.e., write is larger than min_alloc, we use len - free_alloced as an upper alloc bound.",
      "range": {
        "startLine": 818,
        "startChar": 25,
        "endLine": 818,
        "endChar": 37
      },
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7f0ec54c_a9f899cc",
        "filename": "src/svm/svm_fifo.c",
        "patchSetId": 48
      },
      "lineNbr": 818,
      "author": {
        "id": 1561
      },
      "writtenOn": "2020-01-20T11:01:27Z",
      "side": 1,
      "message": "I agree with the idea here. It should work fine even with a large difference between the current actual size and the (virtual) size. So it will be kept safe for the large f-\u003esize (relatively too large than the current actual size).\n\nJust to sharing my thoughts..., I thought the calculation would be something as following, but I suppose it doesn\u0027t really matter because of the effect of clib_min with the f-\u003emin_alloc.\n  actual_size \u003d f_chunk_end (f-\u003eend_chunk) - f-\u003estart_chunk-\u003estart_byte;\n  alloc_size \u003d clib_min (f-\u003emin_alloc, f-\u003esize - actual_size);\n  alloc_size \u003d clib_max (alloc_size, len - free_alloced);",
      "parentUuid": "20b2c838_9dd30bca",
      "range": {
        "startLine": 818,
        "startChar": 25,
        "endLine": 818,
        "endChar": 37
      },
      "revId": "616cbc4fe4dbbb7990499f65562afe8be3e08c9a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    }
  ]
}