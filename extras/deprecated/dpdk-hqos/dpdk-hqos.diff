diff --git a/src/plugins/dpdk/CMakeLists.txt b/src/plugins/dpdk/CMakeLists.txt
index e0122d928..af8c80d8f 100644
--- a/src/plugins/dpdk/CMakeLists.txt
+++ b/src/plugins/dpdk/CMakeLists.txt
@@ -118,8 +118,6 @@ add_vpp_plugin(dpdk
   buffer.c
   main.c
   thread.c
-#  api/dpdk_api.c
-#  api/dpdk_test.c
   device/cli.c
   device/common.c
   device/device.c
@@ -127,7 +125,6 @@ add_vpp_plugin(dpdk
   device/format.c
   device/init.c
   device/node.c
-#   hqos/hqos.c
   ipsec/cli.c
   ipsec/crypto_node.c
   ipsec/esp_decrypt.c
@@ -142,12 +139,6 @@ add_vpp_plugin(dpdk
   ipsec/esp_decrypt.c
   ipsec/esp_encrypt.c
 
-#  API_FILES
-#  api/dpdk.api
-
-#  API_TEST_SOURCES
-#  api/dpdk_test.c
-
   INSTALL_HEADERS
   device/dpdk.h
   ipsec/ipsec.h
diff --git a/src/plugins/dpdk/device/cli.c b/src/plugins/dpdk/device/cli.c
index 416d97360..0f771c6ba 100644
--- a/src/plugins/dpdk/device/cli.c
+++ b/src/plugins/dpdk/device/cli.c
@@ -40,61 +40,6 @@
  */
 
 
-#if 0
-static clib_error_t *
-get_hqos (u32 hw_if_index, u32 subport_id, dpdk_device_t ** xd,
-	  dpdk_device_config_t ** devconf)
-{
-  dpdk_main_t *dm = &dpdk_main;
-  vnet_hw_interface_t *hw;
-  struct rte_eth_dev_info dev_info;
-  struct rte_pci_device *pci_dev;
-  uword *p = 0;
-  clib_error_t *error = NULL;
-
-
-  if (hw_if_index == (u32) ~ 0)
-    {
-      error = clib_error_return (0, "please specify valid interface name");
-      goto done;
-    }
-
-  if (subport_id != 0)
-    {
-      error = clib_error_return (0, "Invalid subport");
-      goto done;
-    }
-
-  hw = vnet_get_hw_interface (dm->vnet_main, hw_if_index);
-  *xd = vec_elt_at_index (dm->devices, hw->dev_instance);
-
-  rte_eth_dev_info_get ((*xd)->port_id, &dev_info);
-
-  pci_dev = dpdk_get_pci_device (&dev_info);
-
-  if (pci_dev)
-    {
-      vlib_pci_addr_t pci_addr;
-
-      pci_addr.domain = pci_dev->addr.domain;
-      pci_addr.bus = pci_dev->addr.bus;
-      pci_addr.slot = pci_dev->addr.devid;
-      pci_addr.function = pci_dev->addr.function;
-
-      p =
-	hash_get (dm->conf->device_config_index_by_pci_addr, pci_addr.as_u32);
-    }
-
-  if (p)
-    (*devconf) = pool_elt_at_index (dm->conf->dev_confs, p[0]);
-  else
-    (*devconf) = &dm->conf->default_devconf;
-
-done:
-  return error;
-}
-#endif
-
 static clib_error_t *
 show_dpdk_buffer (vlib_main_t * vm, unformat_input_t * input,
 		  vlib_cli_command_t * cmd)
@@ -408,1308 +353,6 @@ VLIB_CLI_COMMAND (cmd_set_dpdk_if_desc,static) = {
 };
 /* *INDENT-ON* */
 
-#if 0
-static int
-dpdk_device_queue_sort (void *a1, void *a2)
-{
-  dpdk_device_and_queue_t *dq1 = a1;
-  dpdk_device_and_queue_t *dq2 = a2;
-
-  if (dq1->device > dq2->device)
-    return 1;
-  else if (dq1->device < dq2->device)
-    return -1;
-  else if (dq1->queue_id > dq2->queue_id)
-    return 1;
-  else if (dq1->queue_id < dq2->queue_id)
-    return -1;
-  else
-    return 0;
-}
-
-
-static clib_error_t *
-show_dpdk_if_hqos_placement (vlib_main_t * vm, unformat_input_t * input,
-			     vlib_cli_command_t * cmd)
-{
-  vlib_thread_main_t *tm = vlib_get_thread_main ();
-  dpdk_main_t *dm = &dpdk_main;
-  dpdk_device_and_queue_t *dq;
-  int cpu;
-
-  if (tm->n_vlib_mains == 1)
-    vlib_cli_output (vm, "All interfaces are handled by main thread");
-
-  for (cpu = 0; cpu < vec_len (dm->devices_by_hqos_cpu); cpu++)
-    {
-      if (cpu >= dm->hqos_cpu_first_index &&
-	  cpu < (dm->hqos_cpu_first_index + dm->hqos_cpu_count))
-	vlib_cli_output (vm, "Thread %u (%s at lcore %u):", cpu,
-			 vlib_worker_threads[cpu].name,
-			 vlib_worker_threads[cpu].cpu_id);
-
-      vec_foreach (dq, dm->devices_by_hqos_cpu[cpu])
-      {
-	u32 hw_if_index = dm->devices[dq->device].hw_if_index;
-	vnet_hw_interface_t *hi =
-	  vnet_get_hw_interface (dm->vnet_main, hw_if_index);
-	vlib_cli_output (vm, "  %v queue %u", hi->name, dq->queue_id);
-      }
-    }
-  return 0;
-}
-
-/*?
- * This command is used to display the thread and core each
- * DPDK output interface and HQoS queue is assigned too.
- *
- * @cliexpar
- * Example of how to display the DPDK output interface and HQoS queue placement:
- * @cliexstart{show dpdk interface hqos placement}
- * Thread 1 (vpp_hqos-threads_0 at lcore 3):
- *   GigabitEthernet0/8/0 queue 0
- * Thread 2 (vpp_hqos-threads_1 at lcore 4):
- *   GigabitEthernet0/9/0 queue 0
- * @cliexend
-?*/
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (cmd_show_dpdk_if_hqos_placement, static) = {
-  .path = "show dpdk interface hqos placement",
-  .short_help = "show dpdk interface hqos placement",
-  .function = show_dpdk_if_hqos_placement,
-};
-/* *INDENT-ON* */
-
-static clib_error_t *
-set_dpdk_if_hqos_placement (vlib_main_t * vm, unformat_input_t * input,
-			    vlib_cli_command_t * cmd)
-{
-  unformat_input_t _line_input, *line_input = &_line_input;
-  dpdk_main_t *dm = &dpdk_main;
-  dpdk_device_and_queue_t *dq;
-  vnet_hw_interface_t *hw;
-  dpdk_device_t *xd;
-  u32 hw_if_index = (u32) ~ 0;
-  u32 cpu = (u32) ~ 0;
-  int i;
-  clib_error_t *error = NULL;
-
-  if (!unformat_user (input, unformat_line_input, line_input))
-    return 0;
-
-  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat
-	  (line_input, "%U", unformat_vnet_hw_interface, dm->vnet_main,
-	   &hw_if_index))
-	;
-      else if (unformat (line_input, "thread %d", &cpu))
-	;
-      else
-	{
-	  error = clib_error_return (0, "parse error: '%U'",
-				     format_unformat_error, line_input);
-	  goto done;
-	}
-    }
-
-  if (hw_if_index == (u32) ~ 0)
-    return clib_error_return (0, "please specify valid interface name");
-
-  if (cpu < dm->hqos_cpu_first_index ||
-      cpu >= (dm->hqos_cpu_first_index + dm->hqos_cpu_count))
-    {
-      error = clib_error_return (0, "please specify valid thread id");
-      goto done;
-    }
-
-  hw = vnet_get_hw_interface (dm->vnet_main, hw_if_index);
-  xd = vec_elt_at_index (dm->devices, hw->dev_instance);
-
-  for (i = 0; i < vec_len (dm->devices_by_hqos_cpu); i++)
-    {
-      vec_foreach (dq, dm->devices_by_hqos_cpu[i])
-      {
-	if (hw_if_index == dm->devices[dq->device].hw_if_index)
-	  {
-	    if (cpu == i)	/* nothing to do */
-	      goto done;
-
-	    vec_del1 (dm->devices_by_hqos_cpu[i],
-		      dq - dm->devices_by_hqos_cpu[i]);
-	    vec_add2 (dm->devices_by_hqos_cpu[cpu], dq, 1);
-	    dq->queue_id = 0;
-	    dq->device = xd->device_index;
-
-	    vec_sort_with_function (dm->devices_by_hqos_cpu[i],
-				    dpdk_device_queue_sort);
-
-	    vec_sort_with_function (dm->devices_by_hqos_cpu[cpu],
-				    dpdk_device_queue_sort);
-
-	    goto done;
-	  }
-      }
-    }
-
-  error = clib_error_return (0, "not found");
-
-done:
-  unformat_free (line_input);
-
-  return error;
-}
-
-/*?
- * This command is used to assign a given DPDK output interface and
- * HQoS queue to a different thread. This will not create a thread,
- * so the thread must already exist. Use '<em>/etc/vpp/startup.conf</em>'
- * for the initial thread creation. See @ref qos_doc for more details.
- *
- * @cliexpar
- * Example of how to display the DPDK output interface and HQoS queue placement:
- * @cliexstart{show dpdk interface hqos placement}
- * Thread 1 (vpp_hqos-threads_0 at lcore 3):
- *   GigabitEthernet0/8/0 queue 0
- * Thread 2 (vpp_hqos-threads_1 at lcore 4):
- *   GigabitEthernet0/9/0 queue 0
- * @cliexend
- * Example of how to assign a DPDK output interface and HQoS queue to a thread:
- * @cliexcmd{set dpdk interface hqos placement GigabitEthernet0/8/0 thread 2}
-?*/
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (cmd_set_dpdk_if_hqos_placement, static) = {
-  .path = "set dpdk interface hqos placement",
-  .short_help = "set dpdk interface hqos placement <interface> thread <n>",
-  .function = set_dpdk_if_hqos_placement,
-};
-/* *INDENT-ON* */
-
-static clib_error_t *
-set_dpdk_if_hqos_pipe (vlib_main_t * vm, unformat_input_t * input,
-		       vlib_cli_command_t * cmd)
-{
-  unformat_input_t _line_input, *line_input = &_line_input;
-  dpdk_main_t *dm = &dpdk_main;
-  vnet_hw_interface_t *hw;
-  dpdk_device_t *xd;
-  u32 hw_if_index = (u32) ~ 0;
-  u32 subport_id = (u32) ~ 0;
-  u32 pipe_id = (u32) ~ 0;
-  u32 profile_id = (u32) ~ 0;
-  int rv;
-  clib_error_t *error = NULL;
-
-  if (!unformat_user (input, unformat_line_input, line_input))
-    return 0;
-
-  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat
-	  (line_input, "%U", unformat_vnet_hw_interface, dm->vnet_main,
-	   &hw_if_index))
-	;
-      else if (unformat (line_input, "subport %d", &subport_id))
-	;
-      else if (unformat (line_input, "pipe %d", &pipe_id))
-	;
-      else if (unformat (line_input, "profile %d", &profile_id))
-	;
-      else
-	{
-	  error = clib_error_return (0, "parse error: '%U'",
-				     format_unformat_error, line_input);
-	  goto done;
-	}
-    }
-
-  if (hw_if_index == (u32) ~ 0)
-    {
-      error = clib_error_return (0, "please specify valid interface name");
-      goto done;
-    }
-
-  hw = vnet_get_hw_interface (dm->vnet_main, hw_if_index);
-  xd = vec_elt_at_index (dm->devices, hw->dev_instance);
-
-  rv =
-    rte_sched_pipe_config (xd->hqos_ht->hqos, subport_id, pipe_id,
-			   profile_id);
-  if (rv)
-    {
-      error = clib_error_return (0, "pipe configuration failed");
-      goto done;
-    }
-
-done:
-  unformat_free (line_input);
-
-  return error;
-}
-
-/*?
- * This command is used to change the profile associate with a HQoS pipe. The
- * '<em><profile_id></em>' is zero based. Use the command
- * '<em>show dpdk interface hqos</em>' to display the content of each profile.
- * See @ref qos_doc for more details.
- *
- * @note
- * Currently there is not an API to create a new HQoS pipe profile. One is
- * created by default in the code (search for '<em>hqos_pipe_params_default</em>'').
- * Additional profiles can be created in code and code recompiled. Then use this
- * command to assign it.
- *
- * @cliexpar
- * Example of how to assign a new profile to a HQoS pipe:
- * @cliexcmd{set dpdk interface hqos pipe GigabitEthernet0/8/0 subport 0 pipe 2 profile 1}
-?*/
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (cmd_set_dpdk_if_hqos_pipe, static) =
-{
-  .path = "set dpdk interface hqos pipe",
-  .short_help = "set dpdk interface hqos pipe <interface> subport <subport_id> pipe <pipe_id> "
-                  "profile <profile_id>",
-  .function = set_dpdk_if_hqos_pipe,
-};
-/* *INDENT-ON* */
-
-static clib_error_t *
-set_dpdk_if_hqos_subport (vlib_main_t * vm, unformat_input_t * input,
-			  vlib_cli_command_t * cmd)
-{
-  unformat_input_t _line_input, *line_input = &_line_input;
-  dpdk_main_t *dm = &dpdk_main;
-  dpdk_device_t *xd = NULL;
-  u32 hw_if_index = (u32) ~ 0;
-  u32 subport_id = (u32) ~ 0;
-  struct rte_sched_subport_params p;
-  int rv;
-  clib_error_t *error = NULL;
-  u32 tb_rate = (u32) ~ 0;
-  u32 tb_size = (u32) ~ 0;
-  u32 tc_rate[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE] =
-    { (u32) ~ 0, (u32) ~ 0, (u32) ~ 0, (u32) ~ 0 };
-  u32 tc_period = (u32) ~ 0;
-  dpdk_device_config_t *devconf = NULL;
-
-  if (!unformat_user (input, unformat_line_input, line_input))
-    return 0;
-
-  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat
-	  (line_input, "%U", unformat_vnet_hw_interface, dm->vnet_main,
-	   &hw_if_index))
-	;
-      else if (unformat (line_input, "subport %d", &subport_id))
-	;
-      else if (unformat (line_input, "rate %d", &tb_rate))
-	;
-      else if (unformat (line_input, "bktsize %d", &tb_size))
-	;
-      else if (unformat (line_input, "tc0 %d", &tc_rate[0]))
-	;
-      else if (unformat (line_input, "tc1 %d", &tc_rate[1]))
-	;
-      else if (unformat (line_input, "tc2 %d", &tc_rate[2]))
-	;
-      else if (unformat (line_input, "tc3 %d", &tc_rate[3]))
-	;
-      else if (unformat (line_input, "period %d", &tc_period))
-	;
-      else
-	{
-	  error = clib_error_return (0, "parse error: '%U'",
-				     format_unformat_error, line_input);
-	  goto done;
-	}
-    }
-
-  error = get_hqos (hw_if_index, subport_id, &xd, &devconf);
-
-  if (error == NULL)
-    {
-      /* Copy the current values over to local structure. */
-      memcpy (&p, &devconf->hqos.subport[subport_id], sizeof (p));
-
-      /* Update local structure with input values. */
-      if (tb_rate != (u32) ~ 0)
-	{
-	  p.tb_rate = tb_rate;
-	  p.tc_rate[0] = tb_rate;
-	  p.tc_rate[1] = tb_rate;
-	  p.tc_rate[2] = tb_rate;
-	  p.tc_rate[3] = tb_rate;
-	}
-      if (tb_size != (u32) ~ 0)
-	{
-	  p.tb_size = tb_size;
-	}
-      if (tc_rate[0] != (u32) ~ 0)
-	{
-	  p.tc_rate[0] = tc_rate[0];
-	}
-      if (tc_rate[1] != (u32) ~ 0)
-	{
-	  p.tc_rate[1] = tc_rate[1];
-	}
-      if (tc_rate[2] != (u32) ~ 0)
-	{
-	  p.tc_rate[2] = tc_rate[2];
-	}
-      if (tc_rate[3] != (u32) ~ 0)
-	{
-	  p.tc_rate[3] = tc_rate[3];
-	}
-      if (tc_period != (u32) ~ 0)
-	{
-	  p.tc_period = tc_period;
-	}
-
-      /* Apply changes. */
-      rv = rte_sched_subport_config (xd->hqos_ht->hqos, subport_id, &p);
-      if (rv)
-	{
-	  error = clib_error_return (0, "subport configuration failed");
-	  goto done;
-	}
-      else
-	{
-	  /* Successfully applied, so save of the input values. */
-	  memcpy (&devconf->hqos.subport[subport_id], &p, sizeof (p));
-	}
-    }
-
-done:
-  unformat_free (line_input);
-
-  return error;
-}
-
-/*?
- * This command is used to set the subport level parameters such as token
- * bucket rate (bytes per seconds), token bucket size (bytes), traffic class
- * rates (bytes per seconds) and token update period (Milliseconds).
- *
- * By default, the '<em>rate</em>' is set to 1250000000 bytes/second (10GbE
- * rate) and each of the four traffic classes is set to 100% of the port rate.
- * If the '<em>rate</em>' is updated by this command, all four traffic classes
- * are assigned the same value. Each of the four traffic classes can be updated
- * individually.
- *
- * @cliexpar
- * Example of how modify the subport attributes for a 1GbE link:
- * @cliexcmd{set dpdk interface hqos subport GigabitEthernet0/8/0 subport 0 rate 125000000}
-?*/
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (cmd_set_dpdk_if_hqos_subport, static) = {
-  .path = "set dpdk interface hqos subport",
-  .short_help = "set dpdk interface hqos subport <interface> subport <subport_id> "
-                 "[rate <n>] [bktsize <n>] [tc0 <n>] [tc1 <n>] [tc2 <n>] [tc3 <n>] "
-                 "[period <n>]",
-  .function = set_dpdk_if_hqos_subport,
-};
-/* *INDENT-ON* */
-
-static clib_error_t *
-set_dpdk_if_hqos_tctbl (vlib_main_t * vm, unformat_input_t * input,
-			vlib_cli_command_t * cmd)
-{
-  unformat_input_t _line_input, *line_input = &_line_input;
-  vlib_thread_main_t *tm = vlib_get_thread_main ();
-  dpdk_main_t *dm = &dpdk_main;
-  vnet_hw_interface_t *hw;
-  dpdk_device_t *xd;
-  u32 hw_if_index = (u32) ~ 0;
-  u32 tc = (u32) ~ 0;
-  u32 queue = (u32) ~ 0;
-  u32 entry = (u32) ~ 0;
-  u32 val, i;
-  clib_error_t *error = NULL;
-
-  if (!unformat_user (input, unformat_line_input, line_input))
-    return 0;
-
-  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat
-	  (line_input, "%U", unformat_vnet_hw_interface, dm->vnet_main,
-	   &hw_if_index))
-	;
-      else if (unformat (line_input, "entry %d", &entry))
-	;
-      else if (unformat (line_input, "tc %d", &tc))
-	;
-      else if (unformat (line_input, "queue %d", &queue))
-	;
-      else
-	{
-	  error = clib_error_return (0, "parse error: '%U'",
-				     format_unformat_error, line_input);
-	  goto done;
-	}
-    }
-
-  if (hw_if_index == (u32) ~ 0)
-    {
-      error = clib_error_return (0, "please specify valid interface name");
-      goto done;
-    }
-  if (entry >= 64)
-    {
-      error = clib_error_return (0, "invalid entry");
-      goto done;
-    }
-  if (tc >= RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE)
-    {
-      error = clib_error_return (0, "invalid traffic class");
-      goto done;
-    }
-  if (queue >= RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS)
-    {
-      error = clib_error_return (0, "invalid traffic class queue");
-      goto done;
-    }
-
-  hw = vnet_get_hw_interface (dm->vnet_main, hw_if_index);
-  xd = vec_elt_at_index (dm->devices, hw->dev_instance);
-
-  /* Detect the set of worker threads */
-  uword *p = hash_get_mem (tm->thread_registrations_by_name, "workers");
-  /* Should never happen, shut up Coverity warning */
-  if (p == 0)
-    {
-      error = clib_error_return (0, "no worker registrations?");
-      goto done;
-    }
-
-  vlib_thread_registration_t *tr = (vlib_thread_registration_t *) p[0];
-  int worker_thread_first = tr->first_index;
-  int worker_thread_count = tr->count;
-
-  val = tc * RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS + queue;
-  for (i = 0; i < worker_thread_count; i++)
-    xd->hqos_wt[worker_thread_first + i].hqos_tc_table[entry] = val;
-
-done:
-  unformat_free (line_input);
-
-  return error;
-}
-
-/*?
- * This command is used to set the traffic class translation table. The
- * traffic class translation table is used to map 64 values (0-63) to one of
- * four traffic class and one of four HQoS input queue. Use the '<em>show
- * dpdk interface hqos</em>' command to display the traffic class translation
- * table. See @ref qos_doc for more details.
- *
- * This command has the following parameters:
- *
- * - <b><interface></b> - Used to specify the output interface.
- *
- * - <b>entry <map_val></b> - Mapped value (0-63) to assign traffic class and queue to.
- *
- * - <b>tc <tc_id></b> - Traffic class (0-3) to be used by the provided mapped value.
- *
- * - <b>queue <queue_id></b> - HQoS input queue (0-3) to be used by the provided mapped value.
- *
- * @cliexpar
- * Example of how modify the traffic class translation table:
- * @cliexcmd{set dpdk interface hqos tctbl GigabitEthernet0/8/0 entry 16 tc 2 queue 2}
-?*/
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (cmd_set_dpdk_if_hqos_tctbl, static) = {
-  .path = "set dpdk interface hqos tctbl",
-  .short_help = "set dpdk interface hqos tctbl <interface> entry <map_val> tc <tc_id> queue <queue_id>",
-  .function = set_dpdk_if_hqos_tctbl,
-};
-/* *INDENT-ON* */
-
-static clib_error_t *
-set_dpdk_if_hqos_pktfield (vlib_main_t * vm, unformat_input_t * input,
-			   vlib_cli_command_t * cmd)
-{
-  unformat_input_t _line_input, *line_input = &_line_input;
-  vlib_thread_main_t *tm = vlib_get_thread_main ();
-  dpdk_main_t *dm = &dpdk_main;
-  clib_error_t *error = NULL;
-
-  /* Device specific data */
-  struct rte_eth_dev_info dev_info;
-  struct rte_pci_device *pci_dev;
-  dpdk_device_config_t *devconf = 0;
-  vnet_hw_interface_t *hw;
-  dpdk_device_t *xd;
-  u32 hw_if_index = (u32) ~ 0;
-
-  /* Detect the set of worker threads */
-  uword *p = hash_get_mem (tm->thread_registrations_by_name, "workers");
-  /* Should never happen, shut up Coverity warning */
-  if (p == 0)
-    return clib_error_return (0, "no worker registrations?");
-
-  vlib_thread_registration_t *tr = (vlib_thread_registration_t *) p[0];
-  int worker_thread_first = tr->first_index;
-  int worker_thread_count = tr->count;
-
-  /* Packet field configuration */
-  u64 mask = (u64) ~ 0;
-  u32 id = (u32) ~ 0;
-  u32 offset = (u32) ~ 0;
-
-  /* HQoS params */
-  u32 n_subports_per_port, n_pipes_per_subport, tctbl_size;
-
-  u32 i;
-
-  /* Parse input arguments */
-  if (!unformat_user (input, unformat_line_input, line_input))
-    return 0;
-
-  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat
-	  (line_input, "%U", unformat_vnet_hw_interface, dm->vnet_main,
-	   &hw_if_index))
-	;
-      else if (unformat (line_input, "id subport"))
-	id = 0;
-      else if (unformat (line_input, "id pipe"))
-	id = 1;
-      else if (unformat (line_input, "id tc"))
-	id = 2;
-      else if (unformat (line_input, "id %d", &id))
-	;
-      else if (unformat (line_input, "offset %d", &offset))
-	;
-      else if (unformat (line_input, "mask %llx", &mask))
-	;
-      else
-	{
-	  error = clib_error_return (0, "parse error: '%U'",
-				     format_unformat_error, line_input);
-	  goto done;
-	}
-    }
-
-  /* Get interface */
-  if (hw_if_index == (u32) ~ 0)
-    {
-      error = clib_error_return (0, "please specify valid interface name");
-      goto done;
-    }
-
-  hw = vnet_get_hw_interface (dm->vnet_main, hw_if_index);
-  xd = vec_elt_at_index (dm->devices, hw->dev_instance);
-
-  rte_eth_dev_info_get (xd->port_id, &dev_info);
-
-  pci_dev = dpdk_get_pci_device (&dev_info);
-
-  if (pci_dev)
-    {
-      vlib_pci_addr_t pci_addr;
-
-      pci_addr.domain = pci_dev->addr.domain;
-      pci_addr.bus = pci_dev->addr.bus;
-      pci_addr.slot = pci_dev->addr.devid;
-      pci_addr.function = pci_dev->addr.function;
-
-      p =
-	hash_get (dm->conf->device_config_index_by_pci_addr, pci_addr.as_u32);
-    }
-
-  if (p)
-    devconf = pool_elt_at_index (dm->conf->dev_confs, p[0]);
-  else
-    devconf = &dm->conf->default_devconf;
-
-  if (devconf->hqos_enabled == 0)
-    {
-      vlib_cli_output (vm, "HQoS disabled for this interface");
-      goto done;
-    }
-
-  n_subports_per_port = devconf->hqos.port.n_subports_per_port;
-  n_pipes_per_subport = devconf->hqos.port.n_pipes_per_subport;
-  tctbl_size = RTE_DIM (devconf->hqos.tc_table);
-
-  /* Validate packet field configuration: id, offset and mask */
-  if (id >= 3)
-    {
-      error = clib_error_return (0, "invalid packet field id");
-      goto done;
-    }
-
-  switch (id)
-    {
-    case 0:
-      if (dpdk_hqos_validate_mask (mask, n_subports_per_port) != 0)
-	{
-	  error = clib_error_return (0, "invalid subport ID mask "
-				     "(n_subports_per_port = %u)",
-				     n_subports_per_port);
-	  goto done;
-	}
-      break;
-    case 1:
-      if (dpdk_hqos_validate_mask (mask, n_pipes_per_subport) != 0)
-	{
-	  error = clib_error_return (0, "invalid pipe ID mask "
-				     "(n_pipes_per_subport = %u)",
-				     n_pipes_per_subport);
-	  goto done;
-	}
-      break;
-    case 2:
-    default:
-      if (dpdk_hqos_validate_mask (mask, tctbl_size) != 0)
-	{
-	  error = clib_error_return (0, "invalid TC table index mask "
-				     "(TC table size = %u)", tctbl_size);
-	  goto done;
-	}
-    }
-
-  /* Propagate packet field configuration to all workers */
-  for (i = 0; i < worker_thread_count; i++)
-    switch (id)
-      {
-      case 0:
-	xd->hqos_wt[worker_thread_first + i].hqos_field0_slabpos = offset;
-	xd->hqos_wt[worker_thread_first + i].hqos_field0_slabmask = mask;
-	xd->hqos_wt[worker_thread_first + i].hqos_field0_slabshr =
-	  count_trailing_zeros (mask);
-	break;
-      case 1:
-	xd->hqos_wt[worker_thread_first + i].hqos_field1_slabpos = offset;
-	xd->hqos_wt[worker_thread_first + i].hqos_field1_slabmask = mask;
-	xd->hqos_wt[worker_thread_first + i].hqos_field1_slabshr =
-	  count_trailing_zeros (mask);
-	break;
-      case 2:
-      default:
-	xd->hqos_wt[worker_thread_first + i].hqos_field2_slabpos = offset;
-	xd->hqos_wt[worker_thread_first + i].hqos_field2_slabmask = mask;
-	xd->hqos_wt[worker_thread_first + i].hqos_field2_slabshr =
-	  count_trailing_zeros (mask);
-      }
-
-done:
-  unformat_free (line_input);
-
-  return error;
-}
-
-/*?
- * This command is used to set the packet fields required for classifying the
- * incoming packet. As a result of classification process, packet field
- * information will be mapped to 5 tuples (subport, pipe, traffic class, pipe,
- * color) and stored in packet mbuf.
- *
- * This command has the following parameters:
- *
- * - <b><interface></b> - Used to specify the output interface.
- *
- * - <b>id subport|pipe|tc</b> - Classification occurs across three fields.
- * This parameter indicates which of the three masks are being configured. Legacy
- * code used 0-2 to represent these three fields, so 0-2 is still accepted.
- *   - <b>subport|0</b> - Currently only one subport is supported, so only
- * an empty mask is supported for the subport classification.
- *   - <b>pipe|1</b> - Currently, 4096 pipes per subport are supported, so a
- * 12-bit mask should be configure to map to the 0-4095 pipes.
- *   - <b>tc|2</b> - The translation table (see '<em>set dpdk interface hqos
- * tctbl</em>' command) maps each value (0-63) into one of the 4 traffic classes
- * per pipe. A 6-bit mask should be configure to map this field to a traffic class.
- *
- * - <b>offset <n></b> - Offset in the packet to apply the 64-bit mask for classification.
- * The offset should be on an 8-byte boundary (0,8,16,24..).
- *
- * - <b>mask <hex-mask></b> - 64-bit mask to apply to packet at the given '<em>offset</em>'.
- * Bits must be contiguous and should not include '<em>0x</em>'.
- *
- * The default values for the '<em>pktfield</em>' assumes Ethernet/IPv4/UDP packets with
- * no VLAN. Adjust based on expected packet format and desired classification field.
- * - '<em>subport</em>' is always empty (offset 0 mask 0000000000000000)
- * - By default, '<em>pipe</em>' maps to the UDP payload bits 12 .. 23 (offset 40
- * mask 0000000fff000000)
- * - By default, '<em>tc</em>' maps to the DSCP field in IP header (offset 48 mask
- * 00000000000000fc)
- *
- * @cliexpar
- * Example of how modify the '<em>pipe</em>' classification filter to match VLAN:
- * @cliexcmd{set dpdk interface hqos pktfield GigabitEthernet0/8/0 id pipe offset 8 mask 0000000000000FFF}
-?*/
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (cmd_set_dpdk_if_hqos_pktfield, static) = {
-  .path = "set dpdk interface hqos pktfield",
-  .short_help = "set dpdk interface hqos pktfield <interface> id subport|pipe|tc offset <n> "
-                 "mask <hex-mask>",
-  .function = set_dpdk_if_hqos_pktfield,
-};
-/* *INDENT-ON* */
-
-static clib_error_t *
-show_dpdk_if_hqos (vlib_main_t * vm, unformat_input_t * input,
-		   vlib_cli_command_t * cmd)
-{
-  unformat_input_t _line_input, *line_input = &_line_input;
-  vlib_thread_main_t *tm = vlib_get_thread_main ();
-  dpdk_main_t *dm = &dpdk_main;
-  vnet_hw_interface_t *hw;
-  dpdk_device_t *xd;
-  dpdk_device_config_hqos_t *cfg;
-  dpdk_device_hqos_per_hqos_thread_t *ht;
-  dpdk_device_hqos_per_worker_thread_t *wk;
-  u32 *tctbl;
-  u32 hw_if_index = (u32) ~ 0;
-  u32 profile_id, subport_id, i;
-  struct rte_eth_dev_info dev_info;
-  struct rte_pci_device *pci_dev;
-  dpdk_device_config_t *devconf = 0;
-  vlib_thread_registration_t *tr;
-  uword *p = 0;
-  clib_error_t *error = NULL;
-
-  if (!unformat_user (input, unformat_line_input, line_input))
-    return 0;
-
-  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat
-	  (line_input, "%U", unformat_vnet_hw_interface, dm->vnet_main,
-	   &hw_if_index))
-	;
-      else
-	{
-	  error = clib_error_return (0, "parse error: '%U'",
-				     format_unformat_error, line_input);
-	  goto done;
-	}
-    }
-
-  if (hw_if_index == (u32) ~ 0)
-    {
-      error = clib_error_return (0, "please specify interface name!!");
-      goto done;
-    }
-
-  hw = vnet_get_hw_interface (dm->vnet_main, hw_if_index);
-  xd = vec_elt_at_index (dm->devices, hw->dev_instance);
-
-  rte_eth_dev_info_get (xd->port_id, &dev_info);
-
-  pci_dev = dpdk_get_pci_device (&dev_info);
-
-  if (pci_dev)
-    {
-      vlib_pci_addr_t pci_addr;
-
-      pci_addr.domain = pci_dev->addr.domain;
-      pci_addr.bus = pci_dev->addr.bus;
-      pci_addr.slot = pci_dev->addr.devid;
-      pci_addr.function = pci_dev->addr.function;
-
-      p =
-	hash_get (dm->conf->device_config_index_by_pci_addr, pci_addr.as_u32);
-    }
-
-  if (p)
-    devconf = pool_elt_at_index (dm->conf->dev_confs, p[0]);
-  else
-    devconf = &dm->conf->default_devconf;
-
-  if (devconf->hqos_enabled == 0)
-    {
-      vlib_cli_output (vm, "HQoS disabled for this interface");
-      goto done;
-    }
-
-  /* Detect the set of worker threads */
-  p = hash_get_mem (tm->thread_registrations_by_name, "workers");
-
-  /* Should never happen, shut up Coverity warning */
-  if (p == 0)
-    {
-      error = clib_error_return (0, "no worker registrations?");
-      goto done;
-    }
-
-  tr = (vlib_thread_registration_t *) p[0];
-
-  cfg = &devconf->hqos;
-  ht = xd->hqos_ht;
-  wk = &xd->hqos_wt[tr->first_index];
-  tctbl = wk->hqos_tc_table;
-
-  vlib_cli_output (vm, " Thread:");
-  vlib_cli_output (vm, "   Input SWQ size = %u packets", cfg->swq_size);
-  vlib_cli_output (vm, "   Enqueue burst size = %u packets",
-		   ht->hqos_burst_enq);
-  vlib_cli_output (vm, "   Dequeue burst size = %u packets",
-		   ht->hqos_burst_deq);
-
-  vlib_cli_output (vm,
-		   "   Packet field 0: slab position = %4u, slab bitmask = 0x%016llx   (subport)",
-		   wk->hqos_field0_slabpos, wk->hqos_field0_slabmask);
-  vlib_cli_output (vm,
-		   "   Packet field 1: slab position = %4u, slab bitmask = 0x%016llx   (pipe)",
-		   wk->hqos_field1_slabpos, wk->hqos_field1_slabmask);
-  vlib_cli_output (vm,
-		   "   Packet field 2: slab position = %4u, slab bitmask = 0x%016llx   (tc)",
-		   wk->hqos_field2_slabpos, wk->hqos_field2_slabmask);
-  vlib_cli_output (vm,
-		   "   Packet field 2  tc translation table: ([Mapped Value Range]: tc/queue tc/queue ...)");
-  vlib_cli_output (vm,
-		   "     [ 0 .. 15]: "
-		   "%u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u",
-		   tctbl[0] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[0] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[1] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[1] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[2] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[2] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[3] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[3] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[4] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[4] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[5] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[5] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[6] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[6] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[7] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[7] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[8] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[8] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[9] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[9] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[10] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[10] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[11] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[11] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[12] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[12] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[13] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[13] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[14] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[14] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[15] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[15] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS);
-  vlib_cli_output (vm,
-		   "     [16 .. 31]: "
-		   "%u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u",
-		   tctbl[16] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[16] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[17] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[17] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[18] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[18] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[19] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[19] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[20] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[20] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[21] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[21] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[22] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[22] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[23] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[23] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[24] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[24] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[25] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[25] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[26] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[26] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[27] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[27] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[28] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[28] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[29] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[29] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[30] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[30] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[31] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[31] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS);
-  vlib_cli_output (vm,
-		   "     [32 .. 47]: "
-		   "%u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u",
-		   tctbl[32] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[32] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[33] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[33] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[34] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[34] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[35] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[35] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[36] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[36] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[37] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[37] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[38] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[38] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[39] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[39] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[40] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[40] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[41] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[41] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[42] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[42] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[43] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[43] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[44] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[44] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[45] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[45] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[46] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[46] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[47] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[47] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS);
-  vlib_cli_output (vm,
-		   "     [48 .. 63]: "
-		   "%u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u %u/%u",
-		   tctbl[48] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[48] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[49] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[49] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[50] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[50] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[51] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[51] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[52] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[52] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[53] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[53] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[54] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[54] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[55] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[55] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[56] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[56] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[57] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[57] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[58] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[58] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[59] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[59] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[60] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[60] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[61] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[61] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[62] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[62] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[63] / RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS,
-		   tctbl[63] % RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS);
-  vlib_cli_output (vm, " Port:");
-  vlib_cli_output (vm, "   Rate = %u bytes/second", cfg->port.rate);
-  vlib_cli_output (vm, "   MTU = %u bytes", cfg->port.mtu);
-  vlib_cli_output (vm, "   Frame overhead = %u bytes",
-		   cfg->port.frame_overhead);
-  vlib_cli_output (vm, "   Number of subports = %u",
-		   cfg->port.n_subports_per_port);
-  vlib_cli_output (vm, "   Number of pipes per subport = %u",
-		   cfg->port.n_pipes_per_subport);
-  vlib_cli_output (vm,
-		   "   Packet queue size: TC0 = %u, TC1 = %u, TC2 = %u, TC3 = %u packets",
-		   cfg->port.qsize[0], cfg->port.qsize[1], cfg->port.qsize[2],
-		   cfg->port.qsize[3]);
-  vlib_cli_output (vm, "   Number of pipe profiles = %u",
-		   cfg->port.n_pipe_profiles);
-
-  for (subport_id = 0; subport_id < vec_len (cfg->subport); subport_id++)
-    {
-      vlib_cli_output (vm, " Subport %u:", subport_id);
-      vlib_cli_output (vm, "   Rate = %u bytes/second",
-		       cfg->subport[subport_id].tb_rate);
-      vlib_cli_output (vm, "   Token bucket size = %u bytes",
-		       cfg->subport[subport_id].tb_size);
-      vlib_cli_output (vm,
-		       "   Traffic class rate: TC0 = %u, TC1 = %u, TC2 = %u, TC3 = %u bytes/second",
-		       cfg->subport[subport_id].tc_rate[0],
-		       cfg->subport[subport_id].tc_rate[1],
-		       cfg->subport[subport_id].tc_rate[2],
-		       cfg->subport[subport_id].tc_rate[3]);
-      vlib_cli_output (vm, "   TC period = %u milliseconds",
-		       cfg->subport[subport_id].tc_period);
-    }
-
-  for (profile_id = 0; profile_id < vec_len (cfg->pipe); profile_id++)
-    {
-      vlib_cli_output (vm, " Pipe profile %u:", profile_id);
-      vlib_cli_output (vm, "   Rate = %u bytes/second",
-		       cfg->pipe[profile_id].tb_rate);
-      vlib_cli_output (vm, "   Token bucket size = %u bytes",
-		       cfg->pipe[profile_id].tb_size);
-      vlib_cli_output (vm,
-		       "   Traffic class rate: TC0 = %u, TC1 = %u, TC2 = %u, TC3 = %u bytes/second",
-		       cfg->pipe[profile_id].tc_rate[0],
-		       cfg->pipe[profile_id].tc_rate[1],
-		       cfg->pipe[profile_id].tc_rate[2],
-		       cfg->pipe[profile_id].tc_rate[3]);
-      vlib_cli_output (vm, "   TC period = %u milliseconds",
-		       cfg->pipe[profile_id].tc_period);
-#ifdef RTE_SCHED_SUBPORT_TC_OV
-      vlib_cli_output (vm, "   TC3 oversubscription_weight = %u",
-		       cfg->pipe[profile_id].tc_ov_weight);
-#endif
-
-      for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
-	{
-	  vlib_cli_output (vm,
-			   "   TC%u WRR weights: Q0 = %u, Q1 = %u, Q2 = %u, Q3 = %u",
-			   i, cfg->pipe[profile_id].wrr_weights[i * 4],
-			   cfg->pipe[profile_id].wrr_weights[i * 4 + 1],
-			   cfg->pipe[profile_id].wrr_weights[i * 4 + 2],
-			   cfg->pipe[profile_id].wrr_weights[i * 4 + 3]);
-	}
-    }
-
-#ifdef RTE_SCHED_RED
-  vlib_cli_output (vm, " Weighted Random Early Detection (WRED):");
-  for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
-    {
-      vlib_cli_output (vm, "   TC%u min: G = %u, Y = %u, R = %u", i,
-		       cfg->port.red_params[i][e_RTE_METER_GREEN].min_th,
-		       cfg->port.red_params[i][e_RTE_METER_YELLOW].min_th,
-		       cfg->port.red_params[i][e_RTE_METER_RED].min_th);
-
-      vlib_cli_output (vm, "   TC%u max: G = %u, Y = %u, R = %u", i,
-		       cfg->port.red_params[i][e_RTE_METER_GREEN].max_th,
-		       cfg->port.red_params[i][e_RTE_METER_YELLOW].max_th,
-		       cfg->port.red_params[i][e_RTE_METER_RED].max_th);
-
-      vlib_cli_output (vm,
-		       "   TC%u inverted probability: G = %u, Y = %u, R = %u",
-		       i, cfg->port.red_params[i][e_RTE_METER_GREEN].maxp_inv,
-		       cfg->port.red_params[i][e_RTE_METER_YELLOW].maxp_inv,
-		       cfg->port.red_params[i][e_RTE_METER_RED].maxp_inv);
-
-      vlib_cli_output (vm, "   TC%u weight: R = %u, Y = %u, R = %u", i,
-		       cfg->port.red_params[i][e_RTE_METER_GREEN].wq_log2,
-		       cfg->port.red_params[i][e_RTE_METER_YELLOW].wq_log2,
-		       cfg->port.red_params[i][e_RTE_METER_RED].wq_log2);
-    }
-#endif
-
-done:
-  unformat_free (line_input);
-
-  return error;
-}
-
-/*?
- * This command is used to display details of an output interface's HQoS
- * settings.
- *
- * @cliexpar
- * Example of how to display HQoS settings for an interfaces:
- * @cliexstart{show dpdk interface hqos GigabitEthernet0/8/0}
- *  Thread:
- *    Input SWQ size = 4096 packets
- *    Enqueue burst size = 256 packets
- *    Dequeue burst size = 220 packets
- *    Packet field 0: slab position =    0, slab bitmask = 0x0000000000000000   (subport)
- *    Packet field 1: slab position =   40, slab bitmask = 0x0000000fff000000   (pipe)
- *    Packet field 2: slab position =    8, slab bitmask = 0x00000000000000fc   (tc)
- *    Packet field 2  tc translation table: ([Mapped Value Range]: tc/queue tc/queue ...)
- *      [ 0 .. 15]: 0/0 0/1 0/2 0/3 1/0 1/1 1/2 1/3 2/0 2/1 2/2 2/3 3/0 3/1 3/2 3/3
- *      [16 .. 31]: 0/0 0/1 0/2 0/3 1/0 1/1 1/2 1/3 2/0 2/1 2/2 2/3 3/0 3/1 3/2 3/3
- *      [32 .. 47]: 0/0 0/1 0/2 0/3 1/0 1/1 1/2 1/3 2/0 2/1 2/2 2/3 3/0 3/1 3/2 3/3
- *      [48 .. 63]: 0/0 0/1 0/2 0/3 1/0 1/1 1/2 1/3 2/0 2/1 2/2 2/3 3/0 3/1 3/2 3/3
- *  Port:
- *    Rate = 1250000000 bytes/second
- *    MTU = 1514 bytes
- *    Frame overhead = 24 bytes
- *    Number of subports = 1
- *    Number of pipes per subport = 4096
- *    Packet queue size: TC0 = 64, TC1 = 64, TC2 = 64, TC3 = 64 packets
- *    Number of pipe profiles = 2
- *  Subport 0:
- *    Rate = 1250000000 bytes/second
- *    Token bucket size = 1000000 bytes
- *    Traffic class rate: TC0 = 1250000000, TC1 = 1250000000, TC2 = 1250000000, TC3 = 1250000000 bytes/second
- *    TC period = 10 milliseconds
- *  Pipe profile 0:
- *    Rate = 305175 bytes/second
- *    Token bucket size = 1000000 bytes
- *    Traffic class rate: TC0 = 305175, TC1 = 305175, TC2 = 305175, TC3 = 305175 bytes/second
- *    TC period = 40 milliseconds
- *    TC0 WRR weights: Q0 = 1, Q1 = 1, Q2 = 1, Q3 = 1
- *    TC1 WRR weights: Q0 = 1, Q1 = 1, Q2 = 1, Q3 = 1
- *    TC2 WRR weights: Q0 = 1, Q1 = 1, Q2 = 1, Q3 = 1
- *    TC3 WRR weights: Q0 = 1, Q1 = 1, Q2 = 1, Q3 = 1
- * @cliexend
-?*/
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (cmd_show_dpdk_if_hqos, static) = {
-  .path = "show dpdk interface hqos",
-  .short_help = "show dpdk interface hqos <interface>",
-  .function = show_dpdk_if_hqos,
-};
-
-/* *INDENT-ON* */
-
-static clib_error_t *
-show_dpdk_hqos_queue_stats (vlib_main_t * vm, unformat_input_t * input,
-			    vlib_cli_command_t * cmd)
-{
-  unformat_input_t _line_input, *line_input = &_line_input;
-  clib_error_t *error = NULL;
-#ifdef RTE_SCHED_COLLECT_STATS
-  dpdk_main_t *dm = &dpdk_main;
-  u32 hw_if_index = (u32) ~ 0;
-  u32 subport = (u32) ~ 0;
-  u32 pipe = (u32) ~ 0;
-  u32 tc = (u32) ~ 0;
-  u32 tc_q = (u32) ~ 0;
-  vnet_hw_interface_t *hw;
-  dpdk_device_t *xd;
-  uword *p = 0;
-  struct rte_eth_dev_info dev_info;
-  struct rte_pci_device *pci_dev;
-  dpdk_device_config_t *devconf = 0;
-  u32 qindex;
-  struct rte_sched_queue_stats stats;
-  u16 qlen;
-
-  if (!unformat_user (input, unformat_line_input, line_input))
-    return 0;
-
-  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat
-	  (line_input, "%U", unformat_vnet_hw_interface, dm->vnet_main,
-	   &hw_if_index))
-	;
-
-      else if (unformat (line_input, "subport %d", &subport))
-	;
-
-      else if (unformat (line_input, "pipe %d", &pipe))
-	;
-
-      else if (unformat (line_input, "tc %d", &tc))
-	;
-
-      else if (unformat (line_input, "tc_q %d", &tc_q))
-	;
-
-      else
-	{
-	  error = clib_error_return (0, "parse error: '%U'",
-				     format_unformat_error, line_input);
-	  goto done;
-	}
-    }
-
-  if (hw_if_index == (u32) ~ 0)
-    {
-      error = clib_error_return (0, "please specify interface name!!");
-      goto done;
-    }
-
-  hw = vnet_get_hw_interface (dm->vnet_main, hw_if_index);
-  xd = vec_elt_at_index (dm->devices, hw->dev_instance);
-
-  rte_eth_dev_info_get (xd->port_id, &dev_info);
-
-  pci_dev = dpdk_get_pci_device (&dev_info);
-
-  if (pci_dev)
-    {				/* bonded interface has no pci info */
-      vlib_pci_addr_t pci_addr;
-
-      pci_addr.domain = pci_dev->addr.domain;
-      pci_addr.bus = pci_dev->addr.bus;
-      pci_addr.slot = pci_dev->addr.devid;
-      pci_addr.function = pci_dev->addr.function;
-
-      p =
-	hash_get (dm->conf->device_config_index_by_pci_addr, pci_addr.as_u32);
-    }
-
-  if (p)
-    devconf = pool_elt_at_index (dm->conf->dev_confs, p[0]);
-  else
-    devconf = &dm->conf->default_devconf;
-
-  if (devconf->hqos_enabled == 0)
-    {
-      vlib_cli_output (vm, "HQoS disabled for this interface");
-      goto done;
-    }
-
-  /*
-   * Figure out which queue to query.  cf rte_sched_port_qindex.  (Not sure why
-   * that method isn't made public by DPDK - how _should_ we get the queue ID?)
-   */
-  qindex = subport * devconf->hqos.port.n_pipes_per_subport + pipe;
-  qindex = qindex * RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE + tc;
-  qindex = qindex * RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS + tc_q;
-
-  if (rte_sched_queue_read_stats (xd->hqos_ht->hqos, qindex, &stats, &qlen) !=
-      0)
-    {
-      error = clib_error_return (0, "failed to read stats");
-      goto done;
-    }
-
-  vlib_cli_output (vm, "%=24s%=16s", "Stats Parameter", "Value");
-  vlib_cli_output (vm, "%=24s%=16d", "Packets", stats.n_pkts);
-  vlib_cli_output (vm, "%=24s%=16d", "Packets dropped", stats.n_pkts_dropped);
-#ifdef RTE_SCHED_RED
-  vlib_cli_output (vm, "%=24s%=16d", "Packets dropped (RED)",
-		   stats.n_pkts_red_dropped);
-#endif
-  vlib_cli_output (vm, "%=24s%=16d", "Bytes", stats.n_bytes);
-  vlib_cli_output (vm, "%=24s%=16d", "Bytes dropped", stats.n_bytes_dropped);
-
-#else
-
-  /* Get a line of input */
-  if (!unformat_user (input, unformat_line_input, line_input))
-    return 0;
-
-  vlib_cli_output (vm, "RTE_SCHED_COLLECT_STATS disabled in DPDK");
-  goto done;
-
-#endif
-
-done:
-  unformat_free (line_input);
-
-  return error;
-}
-
-/*?
- * This command is used to display statistics associated with a HQoS traffic class
- * queue.
- *
- * @note
- * Statistic collection by the scheduler is disabled by default in DPDK. In order to
- * turn it on, add the following line to '<em>../vpp/dpdk/Makefile</em>':
- * - <b>$(call set,RTE_SCHED_COLLECT_STATS,y)</b>
- *
- * @cliexpar
- * Example of how to display statistics of HQoS a HQoS traffic class queue:
- * @cliexstart{show dpdk hqos queue GigabitEthernet0/9/0 subport 0 pipe 3181 tc 0 tc_q 0}
- *      Stats Parameter          Value
- *          Packets               140
- *      Packets dropped            0
- *           Bytes               8400
- *       Bytes dropped             0
- * @cliexend
-?*/
-/* *INDENT-OFF* */
-VLIB_CLI_COMMAND (cmd_show_dpdk_hqos_queue_stats, static) = {
-  .path = "show dpdk hqos queue",
-  .short_help = "show dpdk hqos queue <interface> subport <subport_id> pipe <pipe_id> tc <tc_id> tc_q <queue_id>",
-  .function = show_dpdk_hqos_queue_stats,
-};
-/* *INDENT-ON* */
-#endif
-
 static clib_error_t *
 show_dpdk_version_command_fn (vlib_main_t * vm,
 			      unformat_input_t * input,
diff --git a/src/plugins/dpdk/device/device.c b/src/plugins/dpdk/device/device.c
index 323149043..c355edf6a 100644
--- a/src/plugins/dpdk/device/device.c
+++ b/src/plugins/dpdk/device/device.c
@@ -180,21 +180,6 @@ static_always_inline
 	    queue_id = (queue_id + 1) % xd->tx_q_used;
 	}
 
-#if 0
-      if (PREDICT_FALSE (xd->flags & DPDK_DEVICE_FLAG_HQOS))	/* HQoS ON */
-	{
-	  /* no wrap, transmit in one burst */
-	  dpdk_device_hqos_per_worker_thread_t *hqos =
-	    &xd->hqos_wt[vm->thread_index];
-
-	  ASSERT (hqos->swq != NULL);
-
-	  dpdk_hqos_metadata_set (hqos, mb, n_left);
-	  n_sent = rte_ring_sp_enqueue_burst (hqos->swq, (void **) mb,
-					      n_left, 0);
-	}
-      else
-#endif
       if (PREDICT_TRUE (xd->flags & DPDK_DEVICE_FLAG_PMD))
 	{
 	  /* no wrap, transmit in one burst */
diff --git a/src/plugins/dpdk/device/dpdk.h b/src/plugins/dpdk/device/dpdk.h
index ab28ac06a..68d9e712b 100644
--- a/src/plugins/dpdk/device/dpdk.h
+++ b/src/plugins/dpdk/device/dpdk.h
@@ -119,40 +119,6 @@ typedef enum
 
 typedef uint16_t dpdk_portid_t;
 
-typedef struct
-{
-  /* Required for vec_validate_aligned */
-  CLIB_CACHE_LINE_ALIGN_MARK (cacheline0);
-
-  struct rte_ring *swq;
-
-  u64 hqos_field0_slabmask;
-  u32 hqos_field0_slabpos;
-  u32 hqos_field0_slabshr;
-  u64 hqos_field1_slabmask;
-  u32 hqos_field1_slabpos;
-  u32 hqos_field1_slabshr;
-  u64 hqos_field2_slabmask;
-  u32 hqos_field2_slabpos;
-  u32 hqos_field2_slabshr;
-  u32 hqos_tc_table[64];
-} dpdk_device_hqos_per_worker_thread_t;
-
-typedef struct
-{
-  /* Required for vec_validate_aligned */
-  CLIB_CACHE_LINE_ALIGN_MARK (cacheline0);
-  struct rte_ring **swq;
-  struct rte_mbuf **pkts_enq;
-  struct rte_mbuf **pkts_deq;
-  struct rte_sched_port *hqos;
-  u32 hqos_burst_enq;
-  u32 hqos_burst_deq;
-  u32 pkts_enq_len;
-  u32 swq_pos;
-  u32 flush_count;
-} dpdk_device_hqos_per_hqos_thread_t;
-
 #define foreach_dpdk_device_flags \
   _( 0, ADMIN_UP, "admin-up") \
   _( 1, PROMISC, "promisc") \
@@ -160,7 +126,6 @@ typedef struct
   _( 3, PMD_INIT_FAIL, "pmd-init-fail") \
   _( 4, MAYBE_MULTISEG, "maybe-multiseg") \
   _( 5, HAVE_SUBIF, "subif") \
-  _( 6, HQOS, "hqos") \
   _( 9, TX_OFFLOAD, "tx-offload") \
   _(10, INTEL_PHDR_CKSUM, "intel-phdr-cksum") \
   _(11, RX_FLOW_OFFLOAD, "rx-flow-offload") \
@@ -235,10 +200,6 @@ typedef struct
   u32 parked_loop_count;
   struct rte_flow_error last_flow_error;
 
-  /* HQoS related */
-  dpdk_device_hqos_per_worker_thread_t *hqos_wt;
-  dpdk_device_hqos_per_hqos_thread_t *hqos_ht;
-
   /* af_packet instance number */
   u16 af_packet_instance_num;
 
@@ -278,39 +239,6 @@ typedef struct
 #define HQOS_FLUSH_COUNT_THRESHOLD              100000
 #endif
 
-typedef struct dpdk_device_config_hqos_t
-{
-  u32 hqos_thread;
-  u32 hqos_thread_valid;
-
-  u32 swq_size;
-  u32 burst_enq;
-  u32 burst_deq;
-
-  u32 pktfield0_slabpos;
-  u32 pktfield1_slabpos;
-  u32 pktfield2_slabpos;
-  u64 pktfield0_slabmask;
-  u64 pktfield1_slabmask;
-  u64 pktfield2_slabmask;
-  u32 tc_table[64];
-
-  struct rte_sched_port_params port;
-  struct rte_sched_subport_params *subport;
-  struct rte_sched_pipe_params *pipe;
-  uint32_t *pipe_map;
-} dpdk_device_config_hqos_t;
-
-int dpdk_hqos_validate_mask (u64 mask, u32 n);
-void dpdk_device_config_hqos_pipe_profile_default (dpdk_device_config_hqos_t *
-						   hqos, u32 pipe_profile_id);
-#if 0
-void dpdk_device_config_hqos_default (dpdk_device_config_hqos_t * hqos);
-#endif
-clib_error_t *dpdk_port_setup_hqos (dpdk_device_t * xd,
-				    dpdk_device_config_hqos_t * hqos);
-void dpdk_hqos_metadata_set (dpdk_device_hqos_per_worker_thread_t * hqos,
-			     struct rte_mbuf **pkts, u32 n_pkts);
 
 #define foreach_dpdk_device_config_item \
   _ (num_rx_queues) \
@@ -333,8 +261,6 @@ typedef struct
     foreach_dpdk_device_config_item
 #undef _
     clib_bitmap_t * workers;
-  u32 hqos_enabled;
-  dpdk_device_config_hqos_t hqos;
   u8 tso;
   u8 *devargs;
 
@@ -397,7 +323,6 @@ typedef struct
 
   /* Devices */
   dpdk_device_t *devices;
-  dpdk_device_and_queue_t **devices_by_hqos_cpu;
   dpdk_per_thread_data_t *per_thread_data;
 
   /* buffer flags template, configurable to enable/disable tcp / udp cksum */
@@ -409,10 +334,6 @@ typedef struct
    */
   u8 admin_up_down_in_progress;
 
-  /* which cpus are running I/O TX */
-  int hqos_cpu_first_index;
-  int hqos_cpu_count;
-
   /* control interval of dpdk link state and stat polling */
   f64 link_state_poll_interval;
   f64 stat_poll_interval;
@@ -502,8 +423,6 @@ format_function_t format_dpdk_tx_offload_caps;
 vnet_flow_dev_ops_function_t dpdk_flow_ops_fn;
 
 clib_error_t *unformat_rss_fn (unformat_input_t * input, uword * rss_fn);
-clib_error_t *unformat_hqos (unformat_input_t * input,
-			     dpdk_device_config_hqos_t * hqos);
 
 struct rte_pci_device *dpdk_get_pci_device (const struct rte_eth_dev_info
 					    *info);
diff --git a/src/plugins/dpdk/device/format.c b/src/plugins/dpdk/device/format.c
index 20493eb77..8ef46512c 100644
--- a/src/plugins/dpdk/device/format.c
+++ b/src/plugins/dpdk/device/format.c
@@ -913,25 +913,6 @@ unformat_rss_fn (unformat_input_t * input, uword * rss_fn)
   return 0;
 }
 
-clib_error_t *
-unformat_hqos (unformat_input_t * input, dpdk_device_config_hqos_t * hqos)
-{
-  clib_error_t *error = 0;
-
-  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
-    {
-      if (unformat (input, "hqos-thread %u", &hqos->hqos_thread))
-	hqos->hqos_thread_valid = 1;
-      else
-	{
-	  error = clib_error_return (0, "unknown input `%U'",
-				     format_unformat_error, input);
-	  break;
-	}
-    }
-
-  return error;
-}
 
 /*
  * fd.io coding-style-patch-verification: OFF
diff --git a/src/plugins/dpdk/device/init.c b/src/plugins/dpdk/device/init.c
index d0125e939..5d0e5a260 100644
--- a/src/plugins/dpdk/device/init.c
+++ b/src/plugins/dpdk/device/init.c
@@ -214,29 +214,9 @@ dpdk_lib_init (dpdk_main_t * dm)
   dpdk_device_t *xd;
   vlib_pci_addr_t last_pci_addr;
   u32 last_pci_addr_port = 0;
-  vlib_thread_registration_t *tr_hqos;
-  uword *p_hqos;
-
-  u32 next_hqos_cpu = 0;
   u8 af_packet_instance_num = 0;
   last_pci_addr.as_u32 = ~0;
 
-  dm->hqos_cpu_first_index = 0;
-  dm->hqos_cpu_count = 0;
-
-  /* find out which cpus will be used for I/O TX */
-  p_hqos = hash_get_mem (tm->thread_registrations_by_name, "hqos-threads");
-  tr_hqos = p_hqos ? (vlib_thread_registration_t *) p_hqos[0] : 0;
-
-  if (tr_hqos && tr_hqos->count > 0)
-    {
-      dm->hqos_cpu_first_index = tr_hqos->first_index;
-      dm->hqos_cpu_count = tr_hqos->count;
-    }
-
-  vec_validate_aligned (dm->devices_by_hqos_cpu, tm->n_vlib_mains - 1,
-			CLIB_CACHE_LINE_BYTES);
-
   nports = rte_eth_dev_count_avail ();
 
   if (nports < 1)
@@ -596,38 +576,6 @@ dpdk_lib_init (dpdk_main_t * dm)
       /* assign interface to input thread */
       int q;
 
-      if (devconf->hqos_enabled)
-	{
-	  xd->flags |= DPDK_DEVICE_FLAG_HQOS;
-
-	  int cpu;
-	  if (devconf->hqos.hqos_thread_valid)
-	    {
-	      if (devconf->hqos.hqos_thread >= dm->hqos_cpu_count)
-		return clib_error_return (0, "invalid HQoS thread index");
-
-	      cpu = dm->hqos_cpu_first_index + devconf->hqos.hqos_thread;
-	    }
-	  else
-	    {
-	      if (dm->hqos_cpu_count == 0)
-		return clib_error_return (0, "no HQoS threads available");
-
-	      cpu = dm->hqos_cpu_first_index + next_hqos_cpu;
-
-	      next_hqos_cpu++;
-	      if (next_hqos_cpu == dm->hqos_cpu_count)
-		next_hqos_cpu = 0;
-
-	      devconf->hqos.hqos_thread_valid = 1;
-	      devconf->hqos.hqos_thread = cpu;
-	    }
-
-	  dpdk_device_and_queue_t *dq;
-	  vec_add2 (dm->devices_by_hqos_cpu[cpu], dq, 1);
-	  dq->device = xd->device_index;
-	  dq->queue_id = 0;
-	}
 
       error = ethernet_register_interface
 	(dm->vnet_main, dpdk_device_class.index, xd->device_index,
@@ -770,14 +718,6 @@ dpdk_lib_init (dpdk_main_t * dm)
 		      format_dpdk_device_name, i,
 		      format_dpdk_device_errors, xd);
 
-      if (devconf->hqos_enabled)
-	{
-	  clib_error_t *rv;
-	  rv = dpdk_port_setup_hqos (xd, &devconf->hqos);
-	  if (rv)
-	    return rv;
-	}
-
       /*
        * A note on Cisco VIC (PMD_ENIC) and VLAN:
        *
@@ -1060,11 +1000,7 @@ dpdk_device_config (dpdk_config_main_t * conf, vlib_pci_addr_t pci_addr,
     }
 
   devconf->pci_addr.as_u32 = pci_addr.as_u32;
-  devconf->hqos_enabled = 0;
   devconf->tso = DPDK_DEVICE_TSO_DEFAULT;
-#if 0
-  dpdk_device_config_hqos_default (&devconf->hqos);
-#endif
 
   if (!input)
     return 0;
@@ -1097,19 +1033,6 @@ dpdk_device_config (dpdk_config_main_t * conf, vlib_pci_addr_t pci_addr,
 	devconf->vlan_strip_offload = DPDK_DEVICE_VLAN_STRIP_OFF;
       else if (unformat (input, "vlan-strip-offload on"))
 	devconf->vlan_strip_offload = DPDK_DEVICE_VLAN_STRIP_ON;
-      else
-	if (unformat
-	    (input, "hqos %U", unformat_vlib_cli_sub_input, &sub_input))
-	{
-	  devconf->hqos_enabled = 1;
-	  error = unformat_hqos (&sub_input, &devconf->hqos);
-	  if (error)
-	    break;
-	}
-      else if (unformat (input, "hqos"))
-	{
-	  devconf->hqos_enabled = 1;
-	}
       else if (unformat (input, "tso on"))
 	{
 	  devconf->tso = DPDK_DEVICE_TSO_ON;
