#!/usr/bin/env python3


# e.g. 5 bit code symbol has 8 slots (2^8-5), last 3 bits are irrelevant
def generate_slots(fh, s, cl):
    for i in range(1 << 8 - cl):
        fh.write("  { 0x%02X, %d },\n" % (s, cl))


# list of code and code length tuples
huff_code_table = []

# parse Huffman code (RFC7541 Appendix B), EOS removed
with open("rfc7541_huffman_code.txt") as f:
    while line := f.readline():
        # we need just last two columns
        l = line.rstrip().split("  ")
        # len in bits
        code_len = l[-1][1:-1].strip()
        # code as hex aligned to LSB
        code = l[-2].strip()
        huff_code_table.append((code_len, code))

f = open("../http2/huffman_table.h", "w")
f.write(
    """/* SPDX-License-Identifier: Apache-2.0
 * Copyright(c) 2025 Cisco Systems, Inc.
 */

/* generated by mk_huffman_table.py */

#ifndef SRC_PLUGINS_HTTP_HUFFMAN_TABLE_H_
#define SRC_PLUGINS_HTTP_HUFFMAN_TABLE_H_

#include <vppinfra/types.h>

typedef struct
{
  u8 code_len;
  u32 code;
} hpack_huffman_symbol_t;

static hpack_huffman_symbol_t huff_sym_table[] = {
"""
)

# encoding table
[f.write("  {" + code[0] + ", 0x" + code[1] + "},\n") for code in huff_code_table]

f.write(
    """};

typedef struct
{
  u8 symbol;
  u8 code_len;
} hpack_huffman_code_t;

static hpack_huffman_code_t huff_code_table_fast[] = {
"""
)

# fast decoding table, symbols with code length from 5 to 8 bits (most of printable ASCII characters)
[generate_slots(f, i, 5) for i, code in enumerate(huff_code_table) if code[0] == "5"]
[generate_slots(f, i, 6) for i, code in enumerate(huff_code_table) if code[0] == "6"]
[generate_slots(f, i, 7) for i, code in enumerate(huff_code_table) if code[0] == "7"]
[generate_slots(f, i, 8) for i, code in enumerate(huff_code_table) if code[0] == "8"]

# last 2 entries are longer codes prefixes, code_len set to 0
f.write("  { 0x00, 0 },\n")
f.write("  { 0x00, 0 },\n")

f.write(
    """};

typedef struct
{
  u32 first_code;
  u8 code_len;
  u8 symbols[29];
} hpack_huffman_group_t;

/* clang-format off */

static hpack_huffman_group_t huff_code_table_slow[] = {
"""
)
for i in range(10, 31):
    symbols = [
        (symbol, code[1])
        for symbol, code in enumerate(huff_code_table)
        if code[0] == str(i)
    ]
    if symbols:
        _, first_code = symbols[0]
        f.write("  {\n    0x" + first_code + ", /* first_code */\n")
        f.write("    " + str(i) + ", /* code_len */\n")
        f.write("    {\n     ")
        [f.write(" 0x%02X," % s) for s, c in symbols[:10]]
        if len(symbols) > 10:
            f.write("\n     ")
            [f.write(" 0x%02X," % s) for s, c in symbols[10:20]]
            if len(symbols) > 20:
                f.write("\n     ")
                [f.write(" 0x%02X," % s) for s, c in symbols[20:30]]
        f.write("\n    } /* symbols */\n  },\n")

f.write(
    """};

/* clang format-on */

always_inline hpack_huffman_group_t *
hpack_huffman_get_group (u32 value)
{
"""
)

index = 0

symbols = [
    (symbol, code[1]) for symbol, code in enumerate(huff_code_table) if code[0] == "10"
]
_, last_code = symbols[-1]
boundary = (int(last_code, 16) + 1) << 22
f.write("  if (value < 0x%X)\n" % boundary)
f.write("    return &huff_code_table_slow[%d];\n" % index)
index += 1

for i in range(11, 30):
    symbols = [
        (symbol, code[1])
        for symbol, code in enumerate(huff_code_table)
        if code[0] == str(i)
    ]
    if symbols:
        _, last_code = symbols[-1]
        boundary = (int(last_code, 16) + 1) << (32 - i)
        f.write("  else if (value < 0x%X)\n" % boundary)
        f.write("    return &huff_code_table_slow[%d];\n" % index)
        index += 1

f.write("  else\n")
f.write("    return &huff_code_table_slow[%d];\n" % index)

f.write(
    """}

#endif /* SRC_PLUGINS_HTTP_HUFFMAN_TABLE_H_ */
"""
)

f.close()
