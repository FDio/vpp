#!/usr/bin/env python3


# e.g. 5 bit code symbol has 8 slots (2^8-5), last 3 bits are irrelevant
def generate_slots(fh, s, cl):
    for i in range(1 << 8 - cl):
        fh.write("  {" + str(s) + ", " + str(cl) + "},\n")


# list of code and code length tuples
huff_sym_table = []

# parse Huffman code (RFC7541 Appendix B), EOS removed
with open("rfc7541_huffman_code.txt") as f:
    while line := f.readline():
        # we need just last two columns
        l = line.rstrip().split("  ")
        # len in bits
        code_len = l[-1][1:-1].strip()
        # code as hex aligned to LSB
        code = l[-2].strip()
        huff_sym_table.append((code_len, code))

f = open("../huffman_table.h", "w")
f.write(
    """/* SPDX-License-Identifier: Apache-2.0
 * Copyright(c) 2025 Cisco Systems, Inc.
 */

/* generated by mk_huffman_table.py */

#ifndef SRC_PLUGINS_HTTP_HUFFMAN_TABLE_H_
#define SRC_PLUGINS_HTTP_HUFFMAN_TABLE_H_

#include <vppinfra/types.h>

typedef struct
{
  u8 code_len;
  u32 code;
} http_huffman_symbol_t;

static http_huffman_symbol_t huff_sym_table[] = {
"""
)

# encoding table
[f.write("  {" + sym[0] + ", 0x" + sym[1] + "},\n") for sym in huff_sym_table]

f.write(
    """};

typedef struct
{
  u8 symbol;
  u8 code_len;
} http_huffman_code_t;

static http_huffman_code_t huff_code_table_fast[] = {
"""
)

# fast decoding table, symbols with code length from 5 to 8 bits (most of printable ASCII characters)
[generate_slots(f, i, 5) for i, sym in enumerate(huff_sym_table) if sym[0] == "5"]
[generate_slots(f, i, 6) for i, sym in enumerate(huff_sym_table) if sym[0] == "6"]
[generate_slots(f, i, 7) for i, sym in enumerate(huff_sym_table) if sym[0] == "7"]
[generate_slots(f, i, 8) for i, sym in enumerate(huff_sym_table) if sym[0] == "8"]

# last 2 entries are longer codes prefixes, code_len set to 0
f.write("  {254, 0},\n")
f.write("  {255, 0},\n")

f.write(
    """};

typedef struct
{
  u32 first_code;
  u8 code_len;
  u8 symbols[29];
} http_huffman_group_t;

static http_huffman_group_t huff_code_table_slow[] = {
"""
)
for i in range(10, 31):
    symbols = [
        (char, sym[1]) for char, sym in enumerate(huff_sym_table) if sym[0] == str(i)
    ]
    if symbols:
        _, first_code = symbols[0]
        f.write("{0x" + first_code + ", " + str(i) + ", {")
        [f.write(str(s) + ", ") for s, c in symbols]
        f.write("}},\n")

f.write(
    """};

always_inline http_huffman_group_t*
http_huffman_get_group(u32 value)
{
"""
)

index = 0

symbols = [(char, sym[1]) for char, sym in enumerate(huff_sym_table) if sym[0] == "10"]
_, last_code = symbols[-1]
boundary = (int(last_code, 16) + 1) << 22
f.write("  if (value < 0x%X)\n" % boundary)
f.write("    return &huff_code_table_slow[%d];\n" % index)
index += 1

for i in range(11, 30):
    symbols = [
        (char, sym[1]) for char, sym in enumerate(huff_sym_table) if sym[0] == str(i)
    ]
    if symbols:
        _, last_code = symbols[-1]
        boundary = (int(last_code, 16) + 1) << (32 - i)
        f.write("  else if (value < 0x%X)\n" % boundary)
        f.write("    return &huff_code_table_slow[%d];\n" % index)
        index += 1

f.write("  else\n")
f.write("    return &huff_code_table_slow[%d];\n" % index)

f.write(
    """}

#endif /* SRC_PLUGINS_HTTP_HUFFMAN_TABLE_H_ */
"""
)

f.close()
