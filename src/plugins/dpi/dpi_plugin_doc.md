# DPI plugin for VPP    {#dpi_plugin_doc}

## Overview

DPI plugin can identify and analyze the traffic running on networks in real time.
It can be used on many use cases, such as Web Application Firewall,
Policy based routing, Intrusion Detection System, Intrusion Prevention System, etc.

Here are some possbile use cases:
1). Web Application Firewall
A Web Application Firewall filters, monitors, and blocks HTTP traffic
to and from a web application. By inspecting HTTP traffic, it can
prevent attacks stemming from web application security flaws, such as SQL injection,
cross-site scripting, file inclusion, and security misconfigurations.

2). Policy based routing
It can identify application level flows, and prioritize mission-critical applications
in case of bandwidth limitations, then these applications can be dynamically routed
with the suitable fastest path.

## Design

The DPI plugin leverage Hyperscan to perform regex matching.

Hyperscan is a high-performance multiple regex matching library.
Please refer to below for details:
http://intel.github.io/dpi/dev-reference/

This plugin provides Hyperscan support on VPP, so can implement DPI/IPS/IDS etc.

Below is the brief design info. 
1. Configure application name and matched rules, so users can add them dynamically.
   In future will support load rule configuration file when VPP startup. 
      
      "dpi create app <name>",
      
      "dpi app <name> rule <id> (add | del) [host <regex> pattern <regex>]",
      
      "dpi adr add app <name>"
               
2. Configure static dpi flows with 5-tuple and VRF-aware, and supports both ipv4 and ipv6 flows.
   These flows will first try to HW offload to NIC based on DPDK rte_flow mechanism
   and vpp/vnet/flow infrastructure.
   If failed, then will create static SW flow mappings.
   Each flow configuration will create two HW or SW flow mappings, i.e. for forward and reverse traffic.
   And both flow mappings will be mapped to the same dpi flow.
   Dynamically create new SW mapping and aging out mechanism will be added later.
        
        "dpi flow [add | del]  "
        "[src-ip <ip-addr>] [dst-ip <ip-addr>] "
        "[src-port <port>] [dst-port <port>] "
        "[protocol <protocol>] [vrf-id <nn>]",
        
        "dpi set flow-offload hw <interface-name> rx <flow-id> [del]",
        
        "dpi set ip4 flow-bypass <interface> [del]",
        

3. When HW flow offload matched, packets will be redirected to DPI plugin with dpi flow_id in packet descriptor.
   If not, packets will be bypassed to DPI plugin from ip-input, and then lookup SW flow mapping table.

4. Then will detect layer 7 applications.
   This first patch only detect sub protocls within SSL/TLS.
   Will search SSL certificate only for TLS handshake packets, and lookup Hyperscan rules.
   1). Get SSL/TLS certificate through checking TLS handshake packets, i.e. packets with Content type = 22.
   2). If SSL/TLS cert is got, then lookup Hyperscan rules database, and get application id if matched.
   3). If SSL/TLS cert is not found or incomplete, will check more subsequent packets belonging to the same flow.
   4). If maximum packets for this flow is checked and not found matched application, the detection will end up.


## Hyperscan Installation

Hyperscan can be installed from packages directly on below OS:
  Ubuntu 16.04.03
  Ubuntu 18.04 and later version
  Fedora 27 and later version
  openSUSE rolling-release Tumbleweed and later version

If you cannot install Hyperscan from packages directly,
you can build and install it from the source code.

Below are steps to build and install Hyperscan on Ubuntu 16.04:
1).Install binary prerequisites
apt-get install cmake ragel
apt-get install libboost-dev
apt-get install python-dev libbz2-dev

2).Download Hyperscan sources
wget https://github.com/intel/hyperscan/archive/v5.0.0.tar.gz
tar -xf v5.0.0.tar.gz

3).Download boost headers
wget https://dl.bintray.com/boostorg/release/1.68.0/source/boost_1_68_0.tar.gz
tar -xf boost_1_68_0.tar.gz
cp -r boost_1_68_0/boost hyperscan-5.0.0/include

4).Build and install Hyperscan shared library.
   Just follow the instruction from here. Compilation can take a long time.
cd hyperscan-5.0.0
mkdir build
cd build
cmake -DBUILD_SHARED_LIBS=true ..
make
make install

## Multi-Thread Support
Since generated bytecode database is read only, you can run multiple cores
to utilize the byte database to scale.




