/*
 * Copyright (c) 2020 Cisco and/or its affiliates.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** \file
    This file defines the vpp control-plane API messages
    used to configure Calico policies
*/

option version = "0.1.0";
import "vnet/ip/ip_types.api";
import "vnet/fib/fib_types.api";

/** \brief Get the plugin version
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
*/

define capo_get_version
{
  u32 client_index;
  u32 context;
};

/** \brief Reply to get the plugin version
    @param context - returned sender context, to match reply w/ request
    @param major - Incremented every time a known breaking behavior change is introduced
    @param minor - Incremented with small changes, may be used to avoid buggy versions
*/

define capo_get_version_reply
{
  u32 context;
  u32 major;
  u32 minor;
};

/** \brief Control ping from client to api server request
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
*/
define capo_control_ping
{
  u32 client_index;
  u32 context;
};

/** \brief Control ping from the client to the server response
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param retval - return code for the request
    @param vpe_pid - the pid of the vpe, returned by the server
*/
define capo_control_ping_reply
{
  u32 context;
  i32 retval;
  u32 client_index;
  u32 vpe_pid;
};


enum capo_ipset_type : u8 {
  CAPO_IP = 0,           /* Each member is an IP address */
  CAPO_IP_AND_PORT = 1,  /* Each member is "<IP>,(tcp|udp):port" (3-tuple) */
  CAPO_NET = 2,          /* Each member is a CIDR */
};

typedef capo_three_tuple {
  vl_api_address_t address;
  u8 l4_proto;
  u16 port;
};

union capo_ipset_member_val {
  vl_api_address_t address;
  vl_api_prefix_t prefix;
  vl_api_capo_three_tuple_t tuple;
};

typedef capo_ipset_member {
  vl_api_capo_ipset_member_val_t val;
};

define capo_ipset_create
{
  u32 client_index;
  u32 context;
  vl_api_capo_ipset_type_t type;
};

define capo_ipset_create_reply
{
  u32 context;
  i32 retval;
  u32 set_id;
};


autoreply define capo_ipset_add_del_members
{
  u32 client_index;
  u32 context;
  u32 set_id;
  u8 is_add;
  u32 len;
  vl_api_capo_ipset_member_t members[len];
};

autoreply define capo_ipset_delete
{
  u32 client_index;
  u32 context;
  u32 set_id;
};

enum capo_rule_action : u8 {
  CAPO_ALLOW = 0,  // Go to next rule
  CAPO_DENY,       // Drop / reject packet
  CAPO_LOG,        // Ignored for now
  CAPO_PASS,       // Skip remaining rules
};

enum capo_entry_type : u8 {
  CAPO_CIDR = 0,     // simple prefix
  CAPO_PORT_RANGE,
  CAPO_PORT_IP_SET,  // Points to an ip + proto + port set
  CAPO_IP_SET,       // Points to an ip only set
};

typedef capo_port_range {
  u16 start;
  u16 end;    // Inclusive, for a single port start==end
};

typedef capo_set_id {
  u32 set_id;                     // Used for port_ip sets and ip only sets
};

union capo_entry_data {
  vl_api_prefix_t cidr;
  vl_api_capo_port_range_t port_range;
  vl_api_capo_set_id_t set_id;
};

// A rule contains several such entries, each belong to a category
// categories are: [not_]{src,dst}_{cidr,port_range,port_ip_set,ip_set}
// (defined byt the 3 first fields in the rule_entry)
// A rule matches a packet iff:
// - for every "not" category, the source / destination do not match any entry
// - for every positive match category, the source / destination matches at
// least one entry in each category EXCEPT for port ranges and port+ip sets,
// where the packet only needs to match one entry in either category

typedef capo_rule_entry {
  u8 is_src;
  u8 is_not;
  vl_api_capo_entry_type_t type;
  vl_api_capo_entry_data_t data;
};

typedef capo_rule {
  vl_api_capo_rule_action_t action;
  vl_api_address_family_t af;   // v4 or v6 rule

  u8 is_l4_proto;     // Boolean, if set rule matches if proto is l4_proto
  u8 is_not_l4_proto; // Boolean, if set rule matches if proto is not l4_proto
  u8 l4_proto;

  u8 is_icmp_type;
  u8 is_not_icmp_type;
  u8 icmp_type;
  u8 is_icmp_code;      // Only valid if is_icmp_type is set
  u8 is_not_icmp_code;  // Only valid if is_not_icmp_type is set
  u8 icmp_code;

  u32 num_entries;
  vl_api_capo_rule_entry_t matches[num_entries]; // List of other criteria
};

define capo_rule_create {
  u32 client_index;
  u32 context;
  vl_api_capo_rule_t rule;
};

autoreply define capo_rule_update {
  u32 client_index;
  u32 context;
  u32 rule_id;
  vl_api_capo_rule_t rule;
};

define capo_rule_create_reply {
  u32 context;
  i32 retval;
  u32 rule_id;
};

autoreply define capo_rule_delete {
  u32 client_index;
  u32 context;
  u32 rule_id;
};

typedef capo_policy_item {
  u8 is_inbound; // 0 for outbound, 1 for is_inbound
  u32 rule_id;
};

define capo_policy_create {
  u32 client_index;
  u32 context;
  u32 num_items;
  vl_api_capo_policy_item_t rules[num_items];
};

define capo_policy_create_reply {
  u32 context;
  i32 retval;
  u32 policy_id;
};

autoreply define capo_policy_update {
  u32 client_index;
  u32 context;
  u32 policy_id;
  u32 num_items;
  vl_api_capo_policy_item_t rules[num_items];
};

autoreply define capo_policy_delete {
  u32 client_index;
  u32 context;
  u32 policy_id;
};

autoreply define capo_configure_policies {
  u32 client_index;
  u32 context;
  u32 sw_if_index;
  u32 num_policies;
  u32 policy_ids[num_policies];
};
