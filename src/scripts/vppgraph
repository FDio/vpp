#!/usr/bin/env python
# Copyright (c) 2017 Comcast Cable Communications Management, LLC.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Retrieves and renders the VPP graph."""

from __future__ import print_function

import os
import sys
import fnmatch
import argparse

from texttable import Texttable

from vpp_papi import VPP
from vpp_papi_unserialize import VPPUnserializeBuffer
from vpp_papi_graph import VPPNodeThreads


"""A set of common terminal nodes"""
common_terminals = frozenset((
        'error-drop',
        'feature-bitmap-drop',
        'ip4-drop',
        'ip6-drop',
        'mpls-drop',
))


def find_api_dir():
    dirs = []

    if 'VPP_API_DIR' in os.environ:
        dirs.append(os.environ['VPP_API_DIR'])

    # perhaps we're in the 'src/scripts' or 'src/vpp-api/python' dir;
    # in which case, plot a course to likely places in the src tree
    localdir = os.path.dirname(os.path.realpath(__file__))
    localdir_s = localdir.split(os.path.sep)
    srcdir = None
    if localdir_s[-2:] == ['src', 'scripts']:
        # work out the root of the src tree
        srcdir = os.path.sep.join(localdir_s[:-2])
    elif localdir_s[-2:] == ['src', 'vpp-api', 'python']:
        # work out the root of the src tree
        srcdir = os.path.sep.join(localdir_s[:-3])
    if srcdir:
        # try likely dirs
        _x = 'vpp/share/vpp/api/core'
        dirs.append("%s/build-root/install-vpp_debug-native/%s" %
                    (srcdir, _x))
        dirs.append("%s/build-root/install-vpp_release-native/%s" %
                    (srcdir, _x))

    # finally, try the system location
    dirs.append("/usr/share/vpp/api")

    # check the directories; first one wins
    for dir in dirs:
        if os.path.isdir(dir):
            return dir

    return None


def find_api_files(api_dir=None, patterns='*'):
    if api_dir is None:
        api_dir = find_api_dir()
    if isinstance(patterns, list) or isinstance(patterns, tuple):
        patterns = [p.strip() + '.api.json' for p in patterns]
    else:
        patterns = [p.strip() + '.api.json' for p in patterns.split(",")]
    api_files = []
    for root, dirnames, files in os.walk(api_dir):
        # iterate all given patterns and de-dup the result
        files = set(sum([fnmatch.filter(files, p) for p in patterns], []))
        for filename in files:
            api_files.append(os.path.join(api_dir, filename))
    return api_files


def filter_test(args, node):
    if (args.filter_common_terminals and
            node.name in common_terminals):
        return True

    if args.filter_idle and node.stats.clocks == 0:
        return True

    return False


def filter_nodes(args, nodes):
    # Determine number of nodes that point to a given node
    dstn = {}
    if not args.filter_include_orphans:
        for node in nodes:
            for nxtn in node.next_nodes:
                dstn[nxtn.name] = dstn.get(nxtn.name, 0) + 1

    for node in nodes:
        # skip orphaned nodes
        if not (args.filter_include_orphans or node.next_nodes or
                dstn.get(node.name)):
            continue

        if filter_test(args, node):
            continue

        yield node


def render_table(args, nodes):
    t = Texttable()
    t.set_cols_align(['l', 'l', 'l'])
    t.set_cols_valign(['t', 't', 't'])
    rows = [['Node name', 'Statistics', 'Next nodes']]

    for node in filter_nodes(args, nodes):
        rows.append([
            node.name,
            "\n".join((
                "Clocks:   %d" % node.stats.clocks,
                "Calls:    %s" % node.stats.calls,
                "Vectors:  %s" % node.stats.vectors,
                "Suspends: %d" % node.stats.suspends,
            )),
            "\n".join([n.name for n in node.next_nodes
                       if not filter_test(args, n)]),
        ])
    t.add_rows(rows)

    return "".join((t.draw(), "\n"))


def render_dot(args, nodes):
    s = []
    s.append('digraph vlib {')
    s.append('  node [shape=box, fontsize=10];')
    s.append('  edge [arrowhead=vee, arrowsize=0.5];')
    s.append('')

    # Render the graph
    for node in filter_nodes(args, nodes):
        s.append('  "%s" [label="%s"];' % (node.name, node.name))
        for nxtn in node.next_nodes:
            if filter_test(args, nxtn):
                continue
            s.append('    "%s" -> "%s" [label="%s"];' % (
                node.name,
                nxtn.name,
                ""
            ))
        s.append('')

    s.append('}')
    s.append('')

    return "\n".join(s)


renderers = {
    "table": render_table,
    "dot": render_dot,
}


def main():
    ap = argparse.ArgumentParser(
        description="Fetches and renders the VPP node graph.")
    ap.add_argument('--api-dir', metavar="directory",
                    default=find_api_dir(),
                    help="Override the location of the API files; "
                    "otherwise it will be searched for in "
                    "well-known locations. [%(default)s]")
    ap.add_argument('--render-as', '-r',
                    choices=sorted(renderers.keys()),
                    default='table',
                    help="Output format to render the graph as. "
                    "[%(default)s]")
    ap.add_argument('--output-to', '-o', metavar='file',
                    default='-',
                    help="Where to send the output. '-' means "
                    "'stdout'. [%(default)s]")

    fo = ap.add_argument_group('Filtering options')
    fo.add_argument('--filter-include-orphans',
                    action='store_true',
                    help="Do not exclude orphan nodes.")
    fo.add_argument('--filter-common-terminals',
                    action='store_true',
                    help='Exclude common terminal nodes, '
                    'such as error-drop. '
                    'This helps to de-clutter the graph.')
    fo.add_argument('--filter-idle',
                    action='store_true',
                    help='Exclude nodes with no activity.')
    # TODO:
    # --filter-start-at <node>

    args = ap.parse_args()

    api_files = find_api_files(api_dir=args.api_dir, patterns='vpe')
    if not api_files:
        print("ERROR: No JSON API files found in '%s'." % args.api_dir)
        exit(1)

    vpp = VPP(api_files)
    rc = vpp.connect('graphdump')
    # TODO check rc

    rc = vpp.get_node_graph()
    buf = VPPUnserializeBuffer(rc.reply_in_shmem)
    threads = VPPNodeThreads(buf)
    vn = threads.coalesce_threads()

    if args.output_to == '-':
        fp = sys.stdout
    else:
        fp = open(args.output_to, 'w+')

    fn = renderers[args.render_as]
    fp.write(fn(args, vn.nodes))

    if fp != sys.stdout:
        fp.close()
        fp = None

    rc = vpp.disconnect()

if __name__ == '__main__':
    main()


# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
