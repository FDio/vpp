/* Hey Emacs use -*- mode: C -*- */
/*
 * Copyright (c) 2015 Cisco and/or its affiliates.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

option version = "2.1.0";

/*
 * Define services not following the normal conventions here
 */
service {
  rpc memclnt_rx_thread_suspend returns null;
  rpc memclnt_read_timeout returns null;
  rpc rx_thread_exit returns null;
  rpc trace_plugin_msg_ids returns null;
};

/*
 * Create a client registration 
 */
manual_print 
define memclnt_create {
    u32 context;                /* opaque value to be returned in the reply */
    i32 ctx_quota;              /* requested punt context quota */
    u64 input_queue;            /* client's queue */
    string name[64];            /* for show, find by name, whatever */
    u32 api_versions[8];        /* client-server pairs use as desired */
};

define memclnt_create_reply {
    u32 context;                /* opaque value from the create request */
    i32 response;               /* Non-negative = success */
    u64 handle;                 /* handle by which vlib knows this client */
    u32 index;                  /* index, used e.g. by API trace replay */
    u64 message_table;          /* serialized message table in shmem */
};

/*
 * Delete a client registration 
 */
manual_print
define memclnt_delete {
    u32 index;                  /* index, used e.g. by API trace replay */
    u64 handle;               /* handle by which vlib knows this client */
    bool do_cleanup;		/* vlib to cleanup the registration */
};

define memclnt_delete_reply {
    i32 response;               /* Non-negative = success */
    u64 handle;               /* in case the client wonders */
};

/*
 * Client RX thread exit
 */
define rx_thread_exit {
    u8 dummy;
};

/*
 * Client RX thread suspend
 */
define memclnt_rx_thread_suspend {
    u8 dummy;
};

/*
 * Client read timeout
 */
define memclnt_read_timeout {
    u8 dummy;
};

/*
 * RPC
 */
autoreply define rpc_call {
    u32 client_index;
    u32 context;
    u64 function;
    u8 multicast;
    u8 need_barrier_sync;
    u8 send_reply;
    u32 data_len;
    u8 data[data_len];
};

/*
 * Lookup message-ID base by name
 */
define get_first_msg_id {
    u32 client_index;
    u32 context;
    string name[64];
};

define get_first_msg_id_reply {
    u32 context;
    i32 retval;
    u16 first_msg_id;
};

/*
 * Get API version table (includes built-in and plugins)
 */
typedef module_version {
  u32 major;
  u32 minor;
  u32 patch;
  string name[64];
};
define api_versions {
  u32 client_index;
  u32 context;
};
define api_versions_reply {
  u32 context;
  i32 retval;
  u32 count;
  vl_api_module_version_t api_versions[count];
};

/*
 * Trace the plugin message-id allocator
 * so we stand a chance of dealing with different sets of plugins
 * at api trace replay time
 */

manual_print define trace_plugin_msg_ids
{
    u32 client_index;
    u32 context;
    string plugin_name[128];
    u16 first_msg_id;
    u16 last_msg_id;
};

typedef message_table_entry
{
  u16 index;
  string name[64];
};

/*
 * Create a socket client registration. 
 */
define sockclnt_create {
    u32 context;                /* opaque value to be returned in the reply */
    string name[64];                /* for show, find by name, whatever */
};

define sockclnt_create_reply {
    u32 client_index;
    u32 context;                /* opaque value from the create request */
    i32 response;               /* Non-negative = success */
    u32 index;                  /* index, used e.g. by API trace replay */
    u16 count;
    vl_api_message_table_entry_t message_table[count];
};

/*
 * Delete a client registration 
 */
define sockclnt_delete {
    u32 client_index;
    u32 context;
    u32 index;                  /* index, used e.g. by API trace replay */
};

define sockclnt_delete_reply {
    u32 context;
    i32 response;               /* Non-negative = success */
};

/*
 * Initialize shm api over socket api
 */
autoreply define sock_init_shm {
    u32 client_index;
    u32 context;
    u32 requested_size;
    u8 nitems;
    u64 configs[nitems];
};

/* define sock_init_shm_reply {
    u32 client_index;
    u32 context;
    i32 retval;
}; */

/*
 * Memory client ping / response
 * Only sent on inactive connections
 */
autoreply define memclnt_keepalive
{
  u32 client_index;
  u32 context;
};

/** \brief Process a vpe parser cli string request
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param cmd_in_shmem - pointer to cli command string
*/
define cli
{
  u32 client_index;
  u32 context;
  u64 cmd_in_shmem;
};
define cli_inband
{
  u32 client_index;
  u32 context;
  string cmd[];
};

/** \brief vpe parser cli string response
    @param context - sender context, to match reply w/ request
    @param retval - return code for request
    @param reply_in_shmem - Reply string from cli processing if any
*/
define cli_reply
{
  u32 context;
  i32 retval;
  u64 reply_in_shmem;
};
define cli_inband_reply
{
  u32 context;
  i32 retval;
  string reply[];
};

/** \brief Get node index using name request
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param node_name[] - name of the node
*/
define get_node_index
{
  u32 client_index;
  u32 context;
  string node_name[64];
};

/** \brief Get node index using name request
    @param context - sender context, to match reply w/ request
    @param retval - return code for the request
    @param node_index - index of the desired node if found, else ~0
*/
define get_node_index_reply
{
  u32 context;
  i32 retval;
  u32 node_index;
};

/** \brief Set the next node for a given node request
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param node_name[] - node to add the next node to
    @param next_name[] - node to add as the next node
*/
define add_node_next
{
  u32 client_index;
  u32 context;
  string node_name[64];
  string next_name[64];
};

/** \brief IP Set the next node for a given node response
    @param context - sender context, to match reply w/ request
    @param retval - return code for the add next node request
    @param next_index - the index of the next node if success, else ~0
*/
define add_node_next_reply
{
  u32 context;
  i32 retval;
  u32 next_index;
};

/** \brief show_threads display the information about vpp
    threads running on system along with their process id,
    cpu id, physical core and cpu socket.
*/
define show_threads
{
  u32 client_index;
  u32 context;
};

/** \brief thread data
    @param id - thread index
    @param name - thread name i.e. vpp_main or vpp_wk_0
    @param type - thread type i.e. workers or stats
    @param pid - thread Process Id
    @param cpu_id - thread pinned to cpu.
    "CPUs or Logical cores are the number of physical cores times
    the number of threads that can run on each core through
    the use of hyperthreading." (from unix.stackexchange.com)
    @param core - thread pinned to actual physical core.
    @param cpu_socket - thread is running on which cpu socket.
*/
typedef thread_data
{
  u32 id;
  string name[64];
  string type[64];
  u32 pid;
  u32 cpu_id;
  u32 core;
  u32 cpu_socket;
};

/** \brief show_threads_reply
    @param context - returned sender context, to match reply w/ request
    @param retval - return code
    @param count - number of threads in thread_data array
    @param thread_data - array of thread data
*/
define show_threads_reply
{
  u32 context;
  i32 retval;
  u32 count;
  vl_api_thread_data_t thread_data[count];
};

define get_node_graph
{
  u32 client_index;
  u32 context;
};

/** \brief get_node_graph_reply
    @param context - returned sender context, to match reply w/ request
    @param retval - return code
    @param reply_in_shmem - result from vlib_node_serialize, in shared
    memory. Process with vlib_node_unserialize, remember to switch
    heaps and free the result.
*/

define get_node_graph_reply
{
  u32 context;
  i32 retval;
  u64 reply_in_shmem;
};

/** \brief Query relative index via node names
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param node_name - name of node to find relative index from
    @param next_name - next node from node_name to find relative index of
*/
define get_next_index
{
  u32 client_index;
  u32 context;
  string node_name[64];
  string next_name[64];
};

/** \brief Reply for get next node index
    @param context - sender context which was passed in the request
    @param retval - return value
    @param next_index - index of the next_node
*/
define get_next_index_reply
{
  u32 context;
  i32 retval;
  u32 next_index;
};

/** \brief f64 types are not standardized across the wire. Sense wire format in each direction by sending the f64 value 1.0.
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param f64_one - The constant of 1.0.  If you send a different value, expect an rv=VNET_API_ERROR_API_ENDIAN_FAILED.
*/
define get_f64_endian_value
{
  u32 client_index;
  u32 context;
  f64 f64_one [default=1.0];
};

/** \brief get_f64_endian_value reply message
    @param context - sender context which was passed in the request
    @param retval - return value - VNET_API_ERROR_API_ENDIAN_FAILED if f64_one != 1.0
    @param f64_one_result - The value of 'f64 1.0'
*/
define get_f64_endian_value_reply
{
  u32 context;
  u32 retval;
  f64 f64_one_result;
};

/** \brief Verify f64 wire format by sending a value and receiving the value + 1.0
    @param client_index - opaque cookie to identify the sender.
    @param context - sender context, to match reply w/ request.
    @param f64_value - The value you want to test.  Default: 1.0.
*/
define get_f64_increment_by_one
{
  u32 client_index;
  u32 context;
  f64 f64_value [default=1.0];
};

/** \brief get_f64_increment_by_one reply
    @param client_index - opaque cookie to identify the sender.
    @param context - sender context, to match reply w/ request.
    @param f64_value - The input f64_value incremented by 1.0.
*/
define get_f64_increment_by_one_reply
{
  u32 context;
  u32 retval;
  f64 f64_value;
};