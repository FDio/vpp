--- vpp_transport_socket.py	2021-03-31 17:30:25.086320811 +0200
+++ vpp_transport_foreground_socket.py	2021-04-07 16:03:16.023449244 +0200
@@ -1,12 +1,22 @@
 #
 # VPP Unix Domain Socket Transport.
+# A version without background thread handling responses.
+#
+# Users are responsible for issuing enough reads
+# to avoid UDS buffers becoming full.
+#
+# Use only VPPApiClient() with async_thread=False
+# and connect() with do_async=True.
+# For sending, call the wrapped function,
+# for receiving, call read_blocking().
+# You can also access VPPApiClient().transport.socket directly,
+# if you have faster ways to handle binary message.
+# VPPApiClient().transport.last_sent holds last binary message sent,
+# so you do not have to mess with socket to get it.
 #
 import socket
 import struct
-import threading
 import select
-import multiprocessing
-import queue
 import logging
 
 logger = logging.getLogger('vpp_papi.transport')
@@ -28,60 +38,14 @@ class VppTransport:
         self.server_address = server_address
         self.header = struct.Struct('>QII')
         self.message_table = {}
-        # These queues can be accessed async.
-        # They are always up, but replaced on connect.
-        # TODO: Use multiprocessing.Pipe instead of multiprocessing.Queue
-        # if possible.
-        self.sque = multiprocessing.Queue()
-        self.q = multiprocessing.Queue()
-        # The following fields are set in connect().
-        self.message_thread = None
+        self.last_sent = b""
+        # The following field are set in connect().
         self.socket = None
 
-    def msg_thread_func(self):
-        while True:
-            try:
-                rlist, _, _ = select.select([self.socket,
-                                             self.sque._reader], [], [])
-            except socket.error:
-                # Terminate thread
-                logging.error('select failed')
-                self.q.put(None)
-                return
-
-            for r in rlist:
-                if r == self.sque._reader:
-                    # Terminate
-                    self.q.put(None)
-                    return
-
-                elif r == self.socket:
-                    try:
-                        msg = self._read()
-                        if not msg:
-                            self.q.put(None)
-                            return
-                    except socket.error:
-                        self.q.put(None)
-                        return
-                    # Put either to local queue or if context == 0
-                    # callback queue
-                    if self.parent.has_context(msg):
-                        self.q.put(msg)
-                    else:
-                        self.parent.msg_handler_async(msg)
-                else:
-                    raise VppTransportSocketIOError(
-                        2, 'Unknown response from select')
-
-    def connect(self, name, pfx, msg_handler, rx_qlen):
+    def connect(self, name, pfx, rx_qlen):
         # TODO: Reorder the actions and add "roll-backs",
         # to restore clean disconnect state when failure happens durng connect.
 
-        if self.message_thread is not None:
-            raise VppTransportSocketIOError(
-                1, "PAPI socket transport connect: Need to disconnect first.")
-
         # Create a UDS socket
         self.socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
         self.socket.settimeout(self.read_timeout)
@@ -95,17 +59,6 @@ class VppTransport:
 
         self.connected = True
 
-        # Queues' feeder threads from previous connect may still be sending.
-        # Close and join to avoid any errors.
-        self.sque.close()
-        self.q.close()
-        self.sque.join_thread()
-        self.q.join_thread()
-        # Finally safe to replace.
-        self.sque = multiprocessing.Queue()
-        self.q = multiprocessing.Queue()
-        self.message_thread = threading.Thread(target=self.msg_thread_func)
-
         # Initialise sockclnt_create
         sockclnt_create = self.parent.messages['sockclnt_create']
         sockclnt_create_reply = self.parent.messages['sockclnt_create_reply']
@@ -127,9 +80,6 @@ class VppTransport:
             n = m.name
             self.message_table[n] = m.index
 
-        self.message_thread.daemon = True
-        self.message_thread.start()
-
         return 0
 
     def disconnect(self):
@@ -147,15 +97,9 @@ class VppTransport:
         self.connected = False
         if self.socket is not None:
             self.socket.close()
-        if self.sque is not None:
-            self.sque.put(True)  # Terminate listening thread
-        if self.message_thread is not None and self.message_thread.is_alive():
-            # Allow additional connect() calls.
-            self.message_thread.join()
         # Wipe message table, VPP can be restarted with different plugins.
         self.message_table = {}
         # Collect garbage.
-        self.message_thread = None
         self.socket = None
         # Queues will be collected after connect replaces them.
         return rv
@@ -170,7 +114,7 @@ class VppTransport:
         raise NotImplementedError
 
     def get_callback(self, do_async):
-        return self.callback
+        return None
 
     def get_msg_index(self, name):
         try:
@@ -191,6 +135,7 @@ class VppTransport:
         try:
             self.socket.sendall(header)
             self.socket.sendall(buf)
+            self.last_sent = header + buf
         except socket.error as err:
             raise VppTransportSocketIOError(1, 'Sendall error: {err!r}'.format(
                 err=err))
@@ -228,9 +173,5 @@ class VppTransport:
     def read(self, timeout=None):
         if not self.connected:
             raise VppTransportSocketIOError(1, 'Not connected')
-        if timeout is None:
-            timeout = self.read_timeout
-        try:
-            return self.q.get(True, timeout)
-        except queue.Empty:
-            return None
+        # TODO: Implement timeout.
+        return self._read()
