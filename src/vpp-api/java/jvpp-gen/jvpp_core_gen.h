/**
 * This file contains JNI bindings for jvpp Java API.
 * It was generated by jvpp_jni_gen.py based on ['test.api.json'].
 */

// JAVA class reference cache
jclass requestNoArgsClass;
jclass requestNoArgsReplyClass;
jclass requestSingleArgClass;
jclass requestSingleArgReplyClass;
jclass requestTwoArgsClass;
jclass requestTwoArgsReplyClass;
jclass requestWithSingleArrayClass;
jclass requestWithSingleArrayReplyClass;
jclass requestWithArraysClass;
jclass requestWithArraysReplyClass;
jclass requestWithVariableLengthArrayClass;
jclass requestWithVariableLengthArrayReplyClass;
jclass fooDumpClass;
jclass fooDetailsClass;
jclass callbackExceptionClass;

static int cache_class_references(JNIEnv* env) {

    requestNoArgsClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestNoArgs"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    requestNoArgsReplyClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestNoArgsReply"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    requestSingleArgClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestSingleArg"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    requestSingleArgReplyClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestSingleArgReply"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    requestTwoArgsClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestTwoArgs"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    requestTwoArgsReplyClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestTwoArgsReply"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    requestWithSingleArrayClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestWithSingleArray"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    requestWithSingleArrayReplyClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestWithSingleArrayReply"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    requestWithArraysClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestWithArrays"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    requestWithArraysReplyClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestWithArraysReply"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    requestWithVariableLengthArrayClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestWithVariableLengthArray"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    requestWithVariableLengthArrayReplyClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestWithVariableLengthArrayReply"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    fooDumpClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/FooDump"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    fooDetailsClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/FooDetails"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    callbackExceptionClass = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "io/fd/vpp/jvpp/VppCallbackException"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }
    return 0;
}

static void delete_class_references(JNIEnv* env) {

    if (requestNoArgsClass) {
        (*env)->DeleteGlobalRef(env, requestNoArgsClass);
    }
    if (requestNoArgsReplyClass) {
        (*env)->DeleteGlobalRef(env, requestNoArgsReplyClass);
    }
    if (requestSingleArgClass) {
        (*env)->DeleteGlobalRef(env, requestSingleArgClass);
    }
    if (requestSingleArgReplyClass) {
        (*env)->DeleteGlobalRef(env, requestSingleArgReplyClass);
    }
    if (requestTwoArgsClass) {
        (*env)->DeleteGlobalRef(env, requestTwoArgsClass);
    }
    if (requestTwoArgsReplyClass) {
        (*env)->DeleteGlobalRef(env, requestTwoArgsReplyClass);
    }
    if (requestWithSingleArrayClass) {
        (*env)->DeleteGlobalRef(env, requestWithSingleArrayClass);
    }
    if (requestWithSingleArrayReplyClass) {
        (*env)->DeleteGlobalRef(env, requestWithSingleArrayReplyClass);
    }
    if (requestWithArraysClass) {
        (*env)->DeleteGlobalRef(env, requestWithArraysClass);
    }
    if (requestWithArraysReplyClass) {
        (*env)->DeleteGlobalRef(env, requestWithArraysReplyClass);
    }
    if (requestWithVariableLengthArrayClass) {
        (*env)->DeleteGlobalRef(env, requestWithVariableLengthArrayClass);
    }
    if (requestWithVariableLengthArrayReplyClass) {
        (*env)->DeleteGlobalRef(env, requestWithVariableLengthArrayReplyClass);
    }
    if (fooDumpClass) {
        (*env)->DeleteGlobalRef(env, fooDumpClass);
    }
    if (fooDetailsClass) {
        (*env)->DeleteGlobalRef(env, fooDetailsClass);
    }
    if (callbackExceptionClass) {
        (*env)->DeleteGlobalRef(env, callbackExceptionClass);
    }
}


// List of supported API messages used for verification
#define foreach_supported_api_message \
_(control_ping_51077d14) \
_(control_ping_reply_f6b0b8ca) \
_(request_no_args_51077d14) \
_(request_no_args_reply_e8d4e804) \
_(request_single_arg_4199095a) \
_(request_single_arg_reply_e8d4e804) \
_(request_two_args_5655e4d0) \
_(request_two_args_reply_de6526f5) \
_(request_with_single_array_cd91471a) \
_(request_with_single_array_reply_0b35a6a4) \
_(request_with_arrays_e074c053) \
_(request_with_arrays_reply_a38b5e3c) \
_(request_with_variable_length_array_35ea1287) \
_(request_with_variable_length_array_reply_d89de71b) \
_(foo_dump_8ac76db6) \
_(foo_details_e18f0c91) \


// Type handlers


// JNI bindings

/**
 * JNI binding for sending request_no_args message.
 * Generated based on ['test.api.json']:
 * [[u'u16', u'_vl_msg_id'], [u'u32', u'client_index'], [u'u32', u'context'], {   u'crc': u'0x51077d14'}]
 */
JNIEXPORT jint JNICALL Java_io_fd_vpp_jvpp_core_JVppCoreImpl_requestNoArgs0
(JNIEnv * env, jclass clazz) {
    core_main_t *plugin_main = &core_main;
    vl_api_request_no_args_t * mp;
    u32 my_context_id = vppjni_get_context_id (&jvpp_main);



    // create message:
    const size_t _size = sizeof(*mp);
    mp = vl_msg_api_alloc(_size);
    memset (mp, 0, _size);
    mp->_vl_msg_id = ntohs (get_message_id(env, "request_no_args_51077d14"));
    mp->client_index = plugin_main->my_client_index;
    mp->context = clib_host_to_net_u32 (my_context_id);



    // send message:
    if (CLIB_DEBUG > 1)
        clib_warning ("Sending request_no_args message");
    vl_msg_api_send_shmem (plugin_main->vl_input_queue, (u8 *)&mp);
    if ((*env)->ExceptionCheck(env)) {
        return JNI_ERR;
    }
    return my_context_id;
}
/**
 * JNI binding for sending request_single_arg message.
 * Generated based on ['test.api.json']:
 * [[u'u16', u'_vl_msg_id'], [u'u32', u'client_index'], [u'u32', u'context'], [u'u8', u'val_u8'], {   u'crc': u'0x4199095a'}]
 */
JNIEXPORT jint JNICALL Java_io_fd_vpp_jvpp_core_JVppCoreImpl_requestSingleArg0
(JNIEnv * env, jclass clazz, jobject request) {
    core_main_t *plugin_main = &core_main;
    vl_api_request_single_arg_t * mp;
    u32 my_context_id = vppjni_get_context_id (&jvpp_main);
    jclass requestClass = (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestSingleArg");


    jfieldID valU8FieldId = (*env)->GetFieldID(env, requestClass, "valU8", "B");
    jbyte valU8 = (*env)->GetByteField(env, request, valU8FieldId);


    // create message:
    const size_t _size = sizeof(*mp);
    mp = vl_msg_api_alloc(_size);
    memset (mp, 0, _size);
    mp->_vl_msg_id = ntohs (get_message_id(env, "request_single_arg_4199095a"));
    mp->client_index = plugin_main->my_client_index;
    mp->context = clib_host_to_net_u32 (my_context_id);

    mp->val_u8 = valU8;

    // send message:
    if (CLIB_DEBUG > 1)
        clib_warning ("Sending request_single_arg message");
    vl_msg_api_send_shmem (plugin_main->vl_input_queue, (u8 *)&mp);
    if ((*env)->ExceptionCheck(env)) {
        return JNI_ERR;
    }
    return my_context_id;
}
/**
 * JNI binding for sending request_two_args message.
 * Generated based on ['test.api.json']:
 * [   [u'u16', u'_vl_msg_id'],
 *     [u'u32', u'client_index'],
 *     [u'u32', u'context'],
 *     [u'i8', u'val_i8'],
 *     [u'u16', u'val_u16'],
 *     {   u'crc': u'0x5655e4d0'}]
 */
JNIEXPORT jint JNICALL Java_io_fd_vpp_jvpp_core_JVppCoreImpl_requestTwoArgs0
(JNIEnv * env, jclass clazz, jobject request) {
    core_main_t *plugin_main = &core_main;
    vl_api_request_two_args_t * mp;
    u32 my_context_id = vppjni_get_context_id (&jvpp_main);
    jclass requestClass = (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestTwoArgs");


    jfieldID valI8FieldId = (*env)->GetFieldID(env, requestClass, "valI8", "B");
    jbyte valI8 = (*env)->GetByteField(env, request, valI8FieldId);

    jfieldID valU16FieldId = (*env)->GetFieldID(env, requestClass, "valU16", "S");
    jshort valU16 = (*env)->GetShortField(env, request, valU16FieldId);


    // create message:
    const size_t _size = sizeof(*mp);
    mp = vl_msg_api_alloc(_size);
    memset (mp, 0, _size);
    mp->_vl_msg_id = ntohs (get_message_id(env, "request_two_args_5655e4d0"));
    mp->client_index = plugin_main->my_client_index;
    mp->context = clib_host_to_net_u32 (my_context_id);

    mp->val_i8 = valI8;
    mp->val_u16 = clib_host_to_net_u16(valU16);

    // send message:
    if (CLIB_DEBUG > 1)
        clib_warning ("Sending request_two_args message");
    vl_msg_api_send_shmem (plugin_main->vl_input_queue, (u8 *)&mp);
    if ((*env)->ExceptionCheck(env)) {
        return JNI_ERR;
    }
    return my_context_id;
}
/**
 * JNI binding for sending request_with_single_array message.
 * Generated based on ['test.api.json']:
 * [   [u'u16', u'_vl_msg_id'],
 *     [u'u32', u'client_index'],
 *     [u'u32', u'context'],
 *     [u'u8', u'request_array', 16],
 *     {   u'crc': u'0xcd91471a'}]
 */
JNIEXPORT jint JNICALL Java_io_fd_vpp_jvpp_core_JVppCoreImpl_requestWithSingleArray0
(JNIEnv * env, jclass clazz, jobject request) {
    core_main_t *plugin_main = &core_main;
    vl_api_request_with_single_array_t * mp;
    u32 my_context_id = vppjni_get_context_id (&jvpp_main);
    jclass requestClass = (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestWithSingleArray");


    jfieldID requestArrayFieldId = (*env)->GetFieldID(env, requestClass, "requestArray", "[B");
    jbyteArray requestArray = (*env)->GetObjectField(env, request, requestArrayFieldId);


    // create message:
    const size_t _size = sizeof(*mp);
    mp = vl_msg_api_alloc(_size);
    memset (mp, 0, _size);
    mp->_vl_msg_id = ntohs (get_message_id(env, "request_with_single_array_cd91471a"));
    mp->client_index = plugin_main->my_client_index;
    mp->context = clib_host_to_net_u32 (my_context_id);


    if (requestArray) {
        jsize cnt = (*env)->GetArrayLength (env, requestArray);
        
        size_t max_size = 16;
        if (cnt > max_size) cnt = max_size;
        (*env)->GetByteArrayRegion(env, requestArray, 0, cnt, (jbyte *)mp->request_array);
    }


    // send message:
    if (CLIB_DEBUG > 1)
        clib_warning ("Sending request_with_single_array message");
    vl_msg_api_send_shmem (plugin_main->vl_input_queue, (u8 *)&mp);
    if ((*env)->ExceptionCheck(env)) {
        return JNI_ERR;
    }
    return my_context_id;
}
/**
 * JNI binding for sending request_with_arrays message.
 * Generated based on ['test.api.json']:
 * [   [u'u16', u'_vl_msg_id'],
 *     [u'u32', u'client_index'],
 *     [u'u32', u'context'],
 *     [u'u16', u'array1', 2],
 *     [u'u32', u'array2', 4],
 *     [u'u64', u'array3', 8],
 *     {   u'crc': u'0xe074c053'}]
 */
JNIEXPORT jint JNICALL Java_io_fd_vpp_jvpp_core_JVppCoreImpl_requestWithArrays0
(JNIEnv * env, jclass clazz, jobject request) {
    core_main_t *plugin_main = &core_main;
    vl_api_request_with_arrays_t * mp;
    u32 my_context_id = vppjni_get_context_id (&jvpp_main);
    jclass requestClass = (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestWithArrays");


    jfieldID array1FieldId = (*env)->GetFieldID(env, requestClass, "array1", "[S");
    jshortArray array1 = (*env)->GetObjectField(env, request, array1FieldId);

    jfieldID array2FieldId = (*env)->GetFieldID(env, requestClass, "array2", "[I");
    jintArray array2 = (*env)->GetObjectField(env, request, array2FieldId);

    jfieldID array3FieldId = (*env)->GetFieldID(env, requestClass, "array3", "[J");
    jlongArray array3 = (*env)->GetObjectField(env, request, array3FieldId);


    // create message:
    const size_t _size = sizeof(*mp);
    mp = vl_msg_api_alloc(_size);
    memset (mp, 0, _size);
    mp->_vl_msg_id = ntohs (get_message_id(env, "request_with_arrays_e074c053"));
    mp->client_index = plugin_main->my_client_index;
    mp->context = clib_host_to_net_u32 (my_context_id);


    if (array1) {
        jshort * array1ArrayElements = (*env)->GetShortArrayElements(env, array1, NULL);
        size_t _i;
        jsize cnt = (*env)->GetArrayLength(env, array1);
        
        size_t max_size = 2;
        if (cnt > max_size) cnt = max_size;
        for (_i = 0; _i < cnt; _i++) {
            mp->array1[_i] = clib_host_to_net_u16(array1ArrayElements[_i]);
        }
        (*env)->ReleaseShortArrayElements (env, array1, array1ArrayElements, 0);
    }
    

    if (array2) {
        jint * array2ArrayElements = (*env)->GetIntArrayElements(env, array2, NULL);
        size_t _i;
        jsize cnt = (*env)->GetArrayLength(env, array2);
        
        size_t max_size = 4;
        if (cnt > max_size) cnt = max_size;
        for (_i = 0; _i < cnt; _i++) {
            mp->array2[_i] = clib_host_to_net_u32(array2ArrayElements[_i]);
        }
        (*env)->ReleaseIntArrayElements (env, array2, array2ArrayElements, 0);
    }
    

    if (array3) {
        jlong * array3ArrayElements = (*env)->GetLongArrayElements(env, array3, NULL);
        size_t _i;
        jsize cnt = (*env)->GetArrayLength(env, array3);
        
        size_t max_size = 8;
        if (cnt > max_size) cnt = max_size;
        for (_i = 0; _i < cnt; _i++) {
            mp->array3[_i] = clib_host_to_net_u64(array3ArrayElements[_i]);
        }
        (*env)->ReleaseLongArrayElements (env, array3, array3ArrayElements, 0);
    }
    

    // send message:
    if (CLIB_DEBUG > 1)
        clib_warning ("Sending request_with_arrays message");
    vl_msg_api_send_shmem (plugin_main->vl_input_queue, (u8 *)&mp);
    if ((*env)->ExceptionCheck(env)) {
        return JNI_ERR;
    }
    return my_context_id;
}
/**
 * JNI binding for sending request_with_variable_length_array message.
 * Generated based on ['test.api.json']:
 * [   [u'u16', u'_vl_msg_id'],
 *     [u'u32', u'client_index'],
 *     [u'u32', u'context'],
 *     [u'u32', u'vla_size'],
 *     [u'u16', u'vla', 0, u'vla_size'],
 *     {   u'crc': u'0x35ea1287'}]
 */
JNIEXPORT jint JNICALL Java_io_fd_vpp_jvpp_core_JVppCoreImpl_requestWithVariableLengthArray0
(JNIEnv * env, jclass clazz, jobject request) {
    core_main_t *plugin_main = &core_main;
    vl_api_request_with_variable_length_array_t * mp;
    u32 my_context_id = vppjni_get_context_id (&jvpp_main);
    jclass requestClass = (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/RequestWithVariableLengthArray");


    jfieldID vlaSizeFieldId = (*env)->GetFieldID(env, requestClass, "vlaSize", "I");
    jint vlaSize = (*env)->GetIntField(env, request, vlaSizeFieldId);

    jfieldID vlaFieldId = (*env)->GetFieldID(env, requestClass, "vla", "[S");
    jshortArray vla = (*env)->GetObjectField(env, request, vlaFieldId);


    // create message:
    const size_t _size = sizeof(*mp) + vlaSize*sizeof(u16);
    mp = vl_msg_api_alloc(_size);
    memset (mp, 0, _size);
    mp->_vl_msg_id = ntohs (get_message_id(env, "request_with_variable_length_array_35ea1287"));
    mp->client_index = plugin_main->my_client_index;
    mp->context = clib_host_to_net_u32 (my_context_id);

    mp->vla_size = clib_host_to_net_u32(vlaSize);

    if (vla) {
        jshort * vlaArrayElements = (*env)->GetShortArrayElements(env, vla, NULL);
        size_t _i;
        jsize cnt = (*env)->GetArrayLength(env, vla);
        
        size_t max_size = vlaSize;
        if (cnt > max_size) cnt = max_size;
        for (_i = 0; _i < cnt; _i++) {
            mp->vla[_i] = clib_host_to_net_u16(vlaArrayElements[_i]);
        }
        (*env)->ReleaseShortArrayElements (env, vla, vlaArrayElements, 0);
    }
    

    // send message:
    if (CLIB_DEBUG > 1)
        clib_warning ("Sending request_with_variable_length_array message");
    vl_msg_api_send_shmem (plugin_main->vl_input_queue, (u8 *)&mp);
    if ((*env)->ExceptionCheck(env)) {
        return JNI_ERR;
    }
    return my_context_id;
}
/**
 * JNI binding for sending foo_dump message.
 * Generated based on ['test.api.json']:
 * [[u'u16', u'_vl_msg_id'], [u'u32', u'client_index'], [u'u32', u'context'], [u'u32', u'index'], {   u'crc': u'0x8ac76db6'}]
 */
JNIEXPORT jint JNICALL Java_io_fd_vpp_jvpp_core_JVppCoreImpl_fooDump0
(JNIEnv * env, jclass clazz, jobject request) {
    core_main_t *plugin_main = &core_main;
    vl_api_foo_dump_t * mp;
    u32 my_context_id = vppjni_get_context_id (&jvpp_main);
    jclass requestClass = (*env)->FindClass(env, "io/fd/vpp/jvpp/core/dto/FooDump");


    jfieldID indexFieldId = (*env)->GetFieldID(env, requestClass, "index", "I");
    jint index = (*env)->GetIntField(env, request, indexFieldId);


    // create message:
    const size_t _size = sizeof(*mp);
    mp = vl_msg_api_alloc(_size);
    memset (mp, 0, _size);
    mp->_vl_msg_id = ntohs (get_message_id(env, "foo_dump_8ac76db6"));
    mp->client_index = plugin_main->my_client_index;
    mp->context = clib_host_to_net_u32 (my_context_id);

    mp->index = clib_host_to_net_u32(index);

    // send message:
    if (CLIB_DEBUG > 1)
        clib_warning ("Sending foo_dump message");
    vl_msg_api_send_shmem (plugin_main->vl_input_queue, (u8 *)&mp);
    if ((*env)->ExceptionCheck(env)) {
        return JNI_ERR;
    }
    return my_context_id;
}

// Message handlers

/**
 * Handler for request_no_args_reply message.
 * Generated based on ['test.api.json']:
 * [[u'u16', u'_vl_msg_id'], [u'u32', u'context'], [u'i32', u'retval'], {   u'crc': u'0xe8d4e804'}]
 */
static void vl_api_request_no_args_reply_t_handler (vl_api_request_no_args_reply_t * mp)
{
    core_main_t *plugin_main = &core_main;
    JNIEnv *env = jvpp_main.jenv;
    jthrowable exc;

    // for negative result don't send callback message but send error callback
    if (mp->retval<0) {
        call_on_error("request_no_args_reply", mp->context, mp->retval, plugin_main->callbackClass, plugin_main->callbackObject, callbackExceptionClass);
        return;
    }
    if (mp->retval == VNET_API_ERROR_IN_PROGRESS) {
        clib_warning("Result in progress");
        return;
    }

    if (CLIB_DEBUG > 1)
        clib_warning ("Received request_no_args_reply event message");

    jmethodID constructor = (*env)->GetMethodID(env, requestNoArgsReplyClass, "<init>", "()V");

    // User does not have to provide callbacks for all VPP messages.
    // We are ignoring messages that are not supported by user.
    (*env)->ExceptionClear(env); // just in case exception occurred in different place and was not properly cleared
    jmethodID callbackMethod = (*env)->GetMethodID(env, plugin_main->callbackClass, "onRequestNoArgsReply", "(Lio/fd/vpp/jvpp/core/dto/RequestNoArgsReply;)V");
    exc = (*env)->ExceptionOccurred(env);
    if (exc) {
        clib_warning("Unable to extract onRequestNoArgsReply method reference from core plugin's callbackClass. Ignoring message.\n");
        (*env)->ExceptionDescribe(env);
        (*env)->ExceptionClear(env);
        return;
    }

    jobject dto = (*env)->NewObject(env, requestNoArgsReplyClass, constructor);

    jfieldID contextFieldId = (*env)->GetFieldID(env, requestNoArgsReplyClass, "context", "I");
    (*env)->SetIntField(env, dto, contextFieldId, clib_net_to_host_u32(mp->context));


    (*env)->CallVoidMethod(env, plugin_main->callbackObject, callbackMethod, dto);
    // free DTO as per http://stackoverflow.com/questions/1340938/memory-leak-when-calling-java-code-from-c-using-jni
    (*env)->DeleteLocalRef(env, dto);
}
/**
 * Handler for request_single_arg_reply message.
 * Generated based on ['test.api.json']:
 * [[u'u16', u'_vl_msg_id'], [u'u32', u'context'], [u'i32', u'retval'], {   u'crc': u'0xe8d4e804'}]
 */
static void vl_api_request_single_arg_reply_t_handler (vl_api_request_single_arg_reply_t * mp)
{
    core_main_t *plugin_main = &core_main;
    JNIEnv *env = jvpp_main.jenv;
    jthrowable exc;

    // for negative result don't send callback message but send error callback
    if (mp->retval<0) {
        call_on_error("request_single_arg_reply", mp->context, mp->retval, plugin_main->callbackClass, plugin_main->callbackObject, callbackExceptionClass);
        return;
    }
    if (mp->retval == VNET_API_ERROR_IN_PROGRESS) {
        clib_warning("Result in progress");
        return;
    }

    if (CLIB_DEBUG > 1)
        clib_warning ("Received request_single_arg_reply event message");

    jmethodID constructor = (*env)->GetMethodID(env, requestSingleArgReplyClass, "<init>", "()V");

    // User does not have to provide callbacks for all VPP messages.
    // We are ignoring messages that are not supported by user.
    (*env)->ExceptionClear(env); // just in case exception occurred in different place and was not properly cleared
    jmethodID callbackMethod = (*env)->GetMethodID(env, plugin_main->callbackClass, "onRequestSingleArgReply", "(Lio/fd/vpp/jvpp/core/dto/RequestSingleArgReply;)V");
    exc = (*env)->ExceptionOccurred(env);
    if (exc) {
        clib_warning("Unable to extract onRequestSingleArgReply method reference from core plugin's callbackClass. Ignoring message.\n");
        (*env)->ExceptionDescribe(env);
        (*env)->ExceptionClear(env);
        return;
    }

    jobject dto = (*env)->NewObject(env, requestSingleArgReplyClass, constructor);

    jfieldID contextFieldId = (*env)->GetFieldID(env, requestSingleArgReplyClass, "context", "I");
    (*env)->SetIntField(env, dto, contextFieldId, clib_net_to_host_u32(mp->context));


    (*env)->CallVoidMethod(env, plugin_main->callbackObject, callbackMethod, dto);
    // free DTO as per http://stackoverflow.com/questions/1340938/memory-leak-when-calling-java-code-from-c-using-jni
    (*env)->DeleteLocalRef(env, dto);
}
/**
 * Handler for request_two_args_reply message.
 * Generated based on ['test.api.json']:
 * [   [u'u16', u'_vl_msg_id'],
 *     [u'u32', u'context'],
 *     [u'i32', u'retval'],
 *     [u'i8', u'val_i8'],
 *     [u'u16', u'val_u16'],
 *     {   u'crc': u'0xde6526f5'}]
 */
static void vl_api_request_two_args_reply_t_handler (vl_api_request_two_args_reply_t * mp)
{
    core_main_t *plugin_main = &core_main;
    JNIEnv *env = jvpp_main.jenv;
    jthrowable exc;

    // for negative result don't send callback message but send error callback
    if (mp->retval<0) {
        call_on_error("request_two_args_reply", mp->context, mp->retval, plugin_main->callbackClass, plugin_main->callbackObject, callbackExceptionClass);
        return;
    }
    if (mp->retval == VNET_API_ERROR_IN_PROGRESS) {
        clib_warning("Result in progress");
        return;
    }

    if (CLIB_DEBUG > 1)
        clib_warning ("Received request_two_args_reply event message");

    jmethodID constructor = (*env)->GetMethodID(env, requestTwoArgsReplyClass, "<init>", "()V");

    // User does not have to provide callbacks for all VPP messages.
    // We are ignoring messages that are not supported by user.
    (*env)->ExceptionClear(env); // just in case exception occurred in different place and was not properly cleared
    jmethodID callbackMethod = (*env)->GetMethodID(env, plugin_main->callbackClass, "onRequestTwoArgsReply", "(Lio/fd/vpp/jvpp/core/dto/RequestTwoArgsReply;)V");
    exc = (*env)->ExceptionOccurred(env);
    if (exc) {
        clib_warning("Unable to extract onRequestTwoArgsReply method reference from core plugin's callbackClass. Ignoring message.\n");
        (*env)->ExceptionDescribe(env);
        (*env)->ExceptionClear(env);
        return;
    }

    jobject dto = (*env)->NewObject(env, requestTwoArgsReplyClass, constructor);

    jfieldID contextFieldId = (*env)->GetFieldID(env, requestTwoArgsReplyClass, "context", "I");
    (*env)->SetIntField(env, dto, contextFieldId, clib_net_to_host_u32(mp->context));

    jfieldID valI8FieldId = (*env)->GetFieldID(env, requestTwoArgsReplyClass, "valI8", "B");
    (*env)->SetByteField(env, dto, valI8FieldId, mp->val_i8);

    jfieldID valU16FieldId = (*env)->GetFieldID(env, requestTwoArgsReplyClass, "valU16", "S");
    (*env)->SetShortField(env, dto, valU16FieldId, clib_net_to_host_u16(mp->val_u16));


    (*env)->CallVoidMethod(env, plugin_main->callbackObject, callbackMethod, dto);
    // free DTO as per http://stackoverflow.com/questions/1340938/memory-leak-when-calling-java-code-from-c-using-jni
    (*env)->DeleteLocalRef(env, dto);
}
/**
 * Handler for request_with_single_array_reply message.
 * Generated based on ['test.api.json']:
 * [   [u'u16', u'_vl_msg_id'],
 *     [u'u32', u'context'],
 *     [u'i32', u'retval'],
 *     [u'u8', u'reply_array', 16],
 *     {   u'crc': u'0x0b35a6a4'}]
 */
static void vl_api_request_with_single_array_reply_t_handler (vl_api_request_with_single_array_reply_t * mp)
{
    core_main_t *plugin_main = &core_main;
    JNIEnv *env = jvpp_main.jenv;
    jthrowable exc;

    // for negative result don't send callback message but send error callback
    if (mp->retval<0) {
        call_on_error("request_with_single_array_reply", mp->context, mp->retval, plugin_main->callbackClass, plugin_main->callbackObject, callbackExceptionClass);
        return;
    }
    if (mp->retval == VNET_API_ERROR_IN_PROGRESS) {
        clib_warning("Result in progress");
        return;
    }

    if (CLIB_DEBUG > 1)
        clib_warning ("Received request_with_single_array_reply event message");

    jmethodID constructor = (*env)->GetMethodID(env, requestWithSingleArrayReplyClass, "<init>", "()V");

    // User does not have to provide callbacks for all VPP messages.
    // We are ignoring messages that are not supported by user.
    (*env)->ExceptionClear(env); // just in case exception occurred in different place and was not properly cleared
    jmethodID callbackMethod = (*env)->GetMethodID(env, plugin_main->callbackClass, "onRequestWithSingleArrayReply", "(Lio/fd/vpp/jvpp/core/dto/RequestWithSingleArrayReply;)V");
    exc = (*env)->ExceptionOccurred(env);
    if (exc) {
        clib_warning("Unable to extract onRequestWithSingleArrayReply method reference from core plugin's callbackClass. Ignoring message.\n");
        (*env)->ExceptionDescribe(env);
        (*env)->ExceptionClear(env);
        return;
    }

    jobject dto = (*env)->NewObject(env, requestWithSingleArrayReplyClass, constructor);

    jfieldID contextFieldId = (*env)->GetFieldID(env, requestWithSingleArrayReplyClass, "context", "I");
    (*env)->SetIntField(env, dto, contextFieldId, clib_net_to_host_u32(mp->context));

    jfieldID replyArrayFieldId = (*env)->GetFieldID(env, requestWithSingleArrayReplyClass, "replyArray", "[B");
    jbyteArray replyArray = (*env)->NewByteArray(env, 16);
    (*env)->SetByteArrayRegion(env, replyArray, 0, 16, (const jbyte*)mp->reply_array);
    (*env)->SetObjectField(env, dto, replyArrayFieldId, replyArray);
    (*env)->DeleteLocalRef(env, replyArray);


    (*env)->CallVoidMethod(env, plugin_main->callbackObject, callbackMethod, dto);
    // free DTO as per http://stackoverflow.com/questions/1340938/memory-leak-when-calling-java-code-from-c-using-jni
    (*env)->DeleteLocalRef(env, dto);
}
/**
 * Handler for request_with_arrays_reply message.
 * Generated based on ['test.api.json']:
 * [   [u'u16', u'_vl_msg_id'],
 *     [u'u32', u'context'],
 *     [u'i32', u'retval'],
 *     [u'u16', u'array1', 2],
 *     [u'u32', u'array2', 4],
 *     [u'u64', u'array3', 8],
 *     {   u'crc': u'0xa38b5e3c'}]
 */
static void vl_api_request_with_arrays_reply_t_handler (vl_api_request_with_arrays_reply_t * mp)
{
    core_main_t *plugin_main = &core_main;
    JNIEnv *env = jvpp_main.jenv;
    jthrowable exc;

    // for negative result don't send callback message but send error callback
    if (mp->retval<0) {
        call_on_error("request_with_arrays_reply", mp->context, mp->retval, plugin_main->callbackClass, plugin_main->callbackObject, callbackExceptionClass);
        return;
    }
    if (mp->retval == VNET_API_ERROR_IN_PROGRESS) {
        clib_warning("Result in progress");
        return;
    }

    if (CLIB_DEBUG > 1)
        clib_warning ("Received request_with_arrays_reply event message");

    jmethodID constructor = (*env)->GetMethodID(env, requestWithArraysReplyClass, "<init>", "()V");

    // User does not have to provide callbacks for all VPP messages.
    // We are ignoring messages that are not supported by user.
    (*env)->ExceptionClear(env); // just in case exception occurred in different place and was not properly cleared
    jmethodID callbackMethod = (*env)->GetMethodID(env, plugin_main->callbackClass, "onRequestWithArraysReply", "(Lio/fd/vpp/jvpp/core/dto/RequestWithArraysReply;)V");
    exc = (*env)->ExceptionOccurred(env);
    if (exc) {
        clib_warning("Unable to extract onRequestWithArraysReply method reference from core plugin's callbackClass. Ignoring message.\n");
        (*env)->ExceptionDescribe(env);
        (*env)->ExceptionClear(env);
        return;
    }

    jobject dto = (*env)->NewObject(env, requestWithArraysReplyClass, constructor);

    jfieldID contextFieldId = (*env)->GetFieldID(env, requestWithArraysReplyClass, "context", "I");
    (*env)->SetIntField(env, dto, contextFieldId, clib_net_to_host_u32(mp->context));

    jfieldID array1FieldId = (*env)->GetFieldID(env, requestWithArraysReplyClass, "array1", "[S");
    {
        jshortArray array1 = (*env)->NewShortArray(env, 2);
        jshort * array1ArrayElements = (*env)->GetShortArrayElements(env, array1, NULL);
        unsigned int _i;
        for (_i = 0; _i < 2; _i++) {
            array1ArrayElements[_i] = clib_net_to_host_u16(mp->array1[_i]);
        }

        (*env)->ReleaseShortArrayElements(env,  array1, array1ArrayElements, 0);
        (*env)->SetObjectField(env, dto, array1FieldId, array1);
        (*env)->DeleteLocalRef(env, array1);
    }

    jfieldID array2FieldId = (*env)->GetFieldID(env, requestWithArraysReplyClass, "array2", "[I");
    {
        jintArray array2 = (*env)->NewIntArray(env, 4);
        jint * array2ArrayElements = (*env)->GetIntArrayElements(env, array2, NULL);
        unsigned int _i;
        for (_i = 0; _i < 4; _i++) {
            array2ArrayElements[_i] = clib_net_to_host_u32(mp->array2[_i]);
        }

        (*env)->ReleaseIntArrayElements(env,  array2, array2ArrayElements, 0);
        (*env)->SetObjectField(env, dto, array2FieldId, array2);
        (*env)->DeleteLocalRef(env, array2);
    }

    jfieldID array3FieldId = (*env)->GetFieldID(env, requestWithArraysReplyClass, "array3", "[J");
    {
        jlongArray array3 = (*env)->NewLongArray(env, 8);
        jlong * array3ArrayElements = (*env)->GetLongArrayElements(env, array3, NULL);
        unsigned int _i;
        for (_i = 0; _i < 8; _i++) {
            array3ArrayElements[_i] = clib_net_to_host_u64(mp->array3[_i]);
        }

        (*env)->ReleaseLongArrayElements(env,  array3, array3ArrayElements, 0);
        (*env)->SetObjectField(env, dto, array3FieldId, array3);
        (*env)->DeleteLocalRef(env, array3);
    }


    (*env)->CallVoidMethod(env, plugin_main->callbackObject, callbackMethod, dto);
    // free DTO as per http://stackoverflow.com/questions/1340938/memory-leak-when-calling-java-code-from-c-using-jni
    (*env)->DeleteLocalRef(env, dto);
}
/**
 * Handler for request_with_variable_length_array_reply message.
 * Generated based on ['test.api.json']:
 * [   [u'u16', u'_vl_msg_id'],
 *     [u'u32', u'context'],
 *     [u'i32', u'retval'],
 *     [u'u32', u'vla_size'],
 *     [u'u16', u'vla', 0, u'vla_size'],
 *     {   u'crc': u'0xd89de71b'}]
 */
static void vl_api_request_with_variable_length_array_reply_t_handler (vl_api_request_with_variable_length_array_reply_t * mp)
{
    core_main_t *plugin_main = &core_main;
    JNIEnv *env = jvpp_main.jenv;
    jthrowable exc;

    // for negative result don't send callback message but send error callback
    if (mp->retval<0) {
        call_on_error("request_with_variable_length_array_reply", mp->context, mp->retval, plugin_main->callbackClass, plugin_main->callbackObject, callbackExceptionClass);
        return;
    }
    if (mp->retval == VNET_API_ERROR_IN_PROGRESS) {
        clib_warning("Result in progress");
        return;
    }

    if (CLIB_DEBUG > 1)
        clib_warning ("Received request_with_variable_length_array_reply event message");

    jmethodID constructor = (*env)->GetMethodID(env, requestWithVariableLengthArrayReplyClass, "<init>", "()V");

    // User does not have to provide callbacks for all VPP messages.
    // We are ignoring messages that are not supported by user.
    (*env)->ExceptionClear(env); // just in case exception occurred in different place and was not properly cleared
    jmethodID callbackMethod = (*env)->GetMethodID(env, plugin_main->callbackClass, "onRequestWithVariableLengthArrayReply", "(Lio/fd/vpp/jvpp/core/dto/RequestWithVariableLengthArrayReply;)V");
    exc = (*env)->ExceptionOccurred(env);
    if (exc) {
        clib_warning("Unable to extract onRequestWithVariableLengthArrayReply method reference from core plugin's callbackClass. Ignoring message.\n");
        (*env)->ExceptionDescribe(env);
        (*env)->ExceptionClear(env);
        return;
    }

    jobject dto = (*env)->NewObject(env, requestWithVariableLengthArrayReplyClass, constructor);

    jfieldID contextFieldId = (*env)->GetFieldID(env, requestWithVariableLengthArrayReplyClass, "context", "I");
    (*env)->SetIntField(env, dto, contextFieldId, clib_net_to_host_u32(mp->context));

    jfieldID vlaSizeFieldId = (*env)->GetFieldID(env, requestWithVariableLengthArrayReplyClass, "vlaSize", "I");
    (*env)->SetIntField(env, dto, vlaSizeFieldId, clib_net_to_host_u32(mp->vla_size));

    jfieldID vlaFieldId = (*env)->GetFieldID(env, requestWithVariableLengthArrayReplyClass, "vla", "[S");
    {
        jshortArray vla = (*env)->NewShortArray(env, clib_host_to_net_u32(mp->vla_size));
        jshort * vlaArrayElements = (*env)->GetShortArrayElements(env, vla, NULL);
        unsigned int _i;
        for (_i = 0; _i < clib_host_to_net_u32(mp->vla_size); _i++) {
            vlaArrayElements[_i] = clib_net_to_host_u16(mp->vla[_i]);
        }

        (*env)->ReleaseShortArrayElements(env,  vla, vlaArrayElements, 0);
        (*env)->SetObjectField(env, dto, vlaFieldId, vla);
        (*env)->DeleteLocalRef(env, vla);
    }


    (*env)->CallVoidMethod(env, plugin_main->callbackObject, callbackMethod, dto);
    // free DTO as per http://stackoverflow.com/questions/1340938/memory-leak-when-calling-java-code-from-c-using-jni
    (*env)->DeleteLocalRef(env, dto);
}
/**
 * Handler for foo_details message.
 * Generated based on ['test.api.json']:
 * [[u'u16', u'_vl_msg_id'], [u'u32', u'context'], [u'u32', u'index'], {   u'crc': u'0xe18f0c91'}]
 */
static void vl_api_foo_details_t_handler (vl_api_foo_details_t * mp)
{
    core_main_t *plugin_main = &core_main;
    JNIEnv *env = jvpp_main.jenv;
    jthrowable exc;


    if (CLIB_DEBUG > 1)
        clib_warning ("Received foo_details event message");

    jmethodID constructor = (*env)->GetMethodID(env, fooDetailsClass, "<init>", "()V");

    // User does not have to provide callbacks for all VPP messages.
    // We are ignoring messages that are not supported by user.
    (*env)->ExceptionClear(env); // just in case exception occurred in different place and was not properly cleared
    jmethodID callbackMethod = (*env)->GetMethodID(env, plugin_main->callbackClass, "onFooDetails", "(Lio/fd/vpp/jvpp/core/dto/FooDetails;)V");
    exc = (*env)->ExceptionOccurred(env);
    if (exc) {
        clib_warning("Unable to extract onFooDetails method reference from core plugin's callbackClass. Ignoring message.\n");
        (*env)->ExceptionDescribe(env);
        (*env)->ExceptionClear(env);
        return;
    }

    jobject dto = (*env)->NewObject(env, fooDetailsClass, constructor);

    jfieldID contextFieldId = (*env)->GetFieldID(env, fooDetailsClass, "context", "I");
    (*env)->SetIntField(env, dto, contextFieldId, clib_net_to_host_u32(mp->context));

    jfieldID indexFieldId = (*env)->GetFieldID(env, fooDetailsClass, "index", "I");
    (*env)->SetIntField(env, dto, indexFieldId, clib_net_to_host_u32(mp->index));


    (*env)->CallVoidMethod(env, plugin_main->callbackObject, callbackMethod, dto);
    // free DTO as per http://stackoverflow.com/questions/1340938/memory-leak-when-calling-java-code-from-c-using-jni
    (*env)->DeleteLocalRef(env, dto);
}


// Registration of message handlers in vlib
#define foreach_api_reply_handler \
_(request_no_args_reply_e8d4e804, request_no_args_reply) \
_(request_single_arg_reply_e8d4e804, request_single_arg_reply) \
_(request_two_args_reply_de6526f5, request_two_args_reply) \
_(request_with_single_array_reply_0b35a6a4, request_with_single_array_reply) \
_(request_with_arrays_reply_a38b5e3c, request_with_arrays_reply) \
_(request_with_variable_length_array_reply_d89de71b, request_with_variable_length_array_reply) \
_(foo_details_e18f0c91, foo_details) \

