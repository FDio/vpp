#!/usr/bin/env python
#
# Copyright (c) 2018 Cisco and/or its affiliates.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from string import Template

_JVPP_C_TEMPLATE = Template("""/**
 * This file contains JNI bindings for jvpp Java API.
 * It was generated by jvpp_jni_gen.py based on $json_filename.
 */

// JAVA class reference cache
$class_cache

// List of supported API messages used for verification
$api_verification

// JNI bindings
$jni_implementations

// Message handlers
$msg_handlers

// Registration of message handlers in vlib
$handler_registration
""")

_CLASS_CACHE_TEMPLATE = Template("""
$class_references

static int cache_class_references(JNIEnv* env) {
    $create_references
    return 0;
}

static void delete_class_references(JNIEnv* env) {
    $delete_references
}""")


def _generate_class_cache(plugin_name, messages):
    references = [(
        msg.java_name_lower,
        'io/fd/vpp/jvpp/%s/dto/%s' % (plugin_name, msg.java_name_upper)
    ) for msg in messages]
    references.append(('callbackException', 'io/fd/vpp/jvpp/VppCallbackException'))
    return _CLASS_CACHE_TEMPLATE.substitute(
        class_references=_generate_class_references(references),
        create_references=_generate_create_references(references),
        delete_references=_generate_delete_references(references)
    )


def _generate_class_references(references):
    return "\n".join("jclass %sClass;" % r[0] for r in references)


_CREATE_GLOBAL_REF_TEMPLATE = Template("""
    ${ref_name}Class = (jclass)(*env)->NewGlobalRef(env, (*env)->FindClass(env, "${fqn_name}"));
    if ((*env)->ExceptionCheck(env)) {
        (*env)->ExceptionDescribe(env);
        return JNI_ERR;
    }""")


def _generate_create_references(references):
    items = []
    # todo
    # class_name = 'io/fd/vpp/jvpp/VppCallbackException'
    for r in references:
        items.append(_CREATE_GLOBAL_REF_TEMPLATE.substitute(
            ref_name=r[0],
            fqn_name=r[1]
        ))
    return "".join(items)


_DELETE_CLASS_INVOCATION_TEMPLATE = Template("""
    if (${ref_name}Class) {
        (*env)->DeleteGlobalRef(env, ${ref_name}Class);
    }""")


def _generate_delete_references(references):
    items = []
    for r in references:
        items.append(_DELETE_CLASS_INVOCATION_TEMPLATE.substitute(ref_name=r[0]))
    return "".join(items)


class JniGenerator(object):
    def __init__(self, model, logger):
        self.model = model
        self.logger = logger

    def generate(self):
        model = self.model
        self.logger.debug("Generating jvpp C for %s" % model.json_api_files)

        plugin_name = model.plugin_name
        with open("jvpp_%s_gen.h" % plugin_name, "w") as f:
            f.write(_JVPP_C_TEMPLATE.substitute(
                json_filename=model.json_api_files,
                class_cache=_generate_class_cache(plugin_name, model.messages),
                api_verification="//todo api_verification",
                jni_implementations="//todo jni_implementations",
                msg_handlers="//todo msg_handlers",
                handler_registration="//todo handler_registration", ))
