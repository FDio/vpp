
package io.fd.vpp.jvpp.core.future;

/**
 * <p>Async facade callback setting values to future objects
 * <br>It was generated by jvpp_future_facade_gen.py based on ['test.api.json'].
 */
public final class FutureJVppCoreFacadeCallback implements io.fd.vpp.jvpp.core.callback.JVppCoreGlobalCallback {

    private final java.util.Map<java.lang.Integer, java.util.concurrent.CompletableFuture<? extends io.fd.vpp.jvpp.dto.JVppReply<?>>> requests;
    // FIXME private final io.fd.vpp.jvpp.core.notification.GlobalCoreEventCallback notificationCallback;
    private static final java.util.logging.Logger LOG = java.util.logging.Logger.getLogger(FutureJVppCoreFacadeCallback.class.getName());

    public FutureJVppCoreFacadeCallback(
        final java.util.Map<java.lang.Integer, java.util.concurrent.CompletableFuture<? extends io.fd.vpp.jvpp.dto.JVppReply<?>>> requestMap,
        final io.fd.vpp.jvpp.core.notification.GlobalCoreEventCallback notificationCallback) {
        this.requests = requestMap;
        this.notificationCallback = notificationCallback;
    }

    @Override
    @SuppressWarnings("unchecked")
    public void onError(io.fd.vpp.jvpp.VppCallbackException reply) {
        final java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<?>> completableFuture;

        synchronized(requests) {
            completableFuture = (java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<?>>) requests.get(reply.getCtxId());
        }

        if(completableFuture != null) {
            completableFuture.completeExceptionally(reply);

            synchronized(requests) {
                requests.remove(reply.getCtxId());
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void onControlPingReply(final io.fd.vpp.jvpp.dto.ControlPingReply reply) {
        java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<?>> completableFuture;

        final int replyId = reply.context;
        synchronized(requests) {
            completableFuture = (java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<?>>) requests.get(replyId);

            if(completableFuture != null) {
                // Finish dump call
                if (completableFuture instanceof io.fd.vpp.jvpp.future.AbstractFutureJVppInvoker.CompletableDumpFuture) {
                    completableFuture.complete(((io.fd.vpp.jvpp.future.AbstractFutureJVppInvoker.CompletableDumpFuture) completableFuture).getReplyDump());
                    // Remove future mapped to dump call context id
                    requests.remove(((io.fd.vpp.jvpp.future.AbstractFutureJVppInvoker.CompletableDumpFuture) completableFuture).getContextId());
                } else {
                    // reply to regular control ping, complete the future
                    completableFuture.complete(reply);
                }
                requests.remove(replyId);
            } else {
                // future not yet created by writer, create new future, complete it and put to map under ping id
                completableFuture = new java.util.concurrent.CompletableFuture<>();
                completableFuture.complete(reply);
                requests.put(replyId, completableFuture);
            }
        }
    }


    @Override
    @SuppressWarnings("unchecked")
    public void onRequestNoArgsReply(final io.fd.vpp.jvpp.core.dto.RequestNoArgsReply reply) {
        java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestNoArgs>> completableFuture;
        final int replyId = reply.context;
        if (LOG.isLoggable(java.util.logging.Level.FINE)) {
            LOG.fine(String.format("Received RequestNoArgsReply event message: %s", reply));
        }
        synchronized(requests) {
            completableFuture =
            (java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestNoArgs>>) requests.get(replyId);

            if(completableFuture != null) {
                // received reply on request, complete future created by sender and remove it from map
                completableFuture.complete(reply);
                requests.remove(replyId);
            } else {
                // reply received before writer created future,
                // create new future, complete it and put into map to
                // notify sender that reply is already received
                completableFuture = new  java.util.concurrent.CompletableFuture<>();
                completableFuture.complete(reply);
                requests.put(replyId, completableFuture);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void onRequestSingleArgReply(final io.fd.vpp.jvpp.core.dto.RequestSingleArgReply reply) {
        java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestSingleArg>> completableFuture;
        final int replyId = reply.context;
        if (LOG.isLoggable(java.util.logging.Level.FINE)) {
            LOG.fine(String.format("Received RequestSingleArgReply event message: %s", reply));
        }
        synchronized(requests) {
            completableFuture =
            (java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestSingleArg>>) requests.get(replyId);

            if(completableFuture != null) {
                // received reply on request, complete future created by sender and remove it from map
                completableFuture.complete(reply);
                requests.remove(replyId);
            } else {
                // reply received before writer created future,
                // create new future, complete it and put into map to
                // notify sender that reply is already received
                completableFuture = new  java.util.concurrent.CompletableFuture<>();
                completableFuture.complete(reply);
                requests.put(replyId, completableFuture);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void onRequestTwoArgsReply(final io.fd.vpp.jvpp.core.dto.RequestTwoArgsReply reply) {
        java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestTwoArgs>> completableFuture;
        final int replyId = reply.context;
        if (LOG.isLoggable(java.util.logging.Level.FINE)) {
            LOG.fine(String.format("Received RequestTwoArgsReply event message: %s", reply));
        }
        synchronized(requests) {
            completableFuture =
            (java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestTwoArgs>>) requests.get(replyId);

            if(completableFuture != null) {
                // received reply on request, complete future created by sender and remove it from map
                completableFuture.complete(reply);
                requests.remove(replyId);
            } else {
                // reply received before writer created future,
                // create new future, complete it and put into map to
                // notify sender that reply is already received
                completableFuture = new  java.util.concurrent.CompletableFuture<>();
                completableFuture.complete(reply);
                requests.put(replyId, completableFuture);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void onRequestWithSingleArrayReply(final io.fd.vpp.jvpp.core.dto.RequestWithSingleArrayReply reply) {
        java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestWithSingleArray>> completableFuture;
        final int replyId = reply.context;
        if (LOG.isLoggable(java.util.logging.Level.FINE)) {
            LOG.fine(String.format("Received RequestWithSingleArrayReply event message: %s", reply));
        }
        synchronized(requests) {
            completableFuture =
            (java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestWithSingleArray>>) requests.get(replyId);

            if(completableFuture != null) {
                // received reply on request, complete future created by sender and remove it from map
                completableFuture.complete(reply);
                requests.remove(replyId);
            } else {
                // reply received before writer created future,
                // create new future, complete it and put into map to
                // notify sender that reply is already received
                completableFuture = new  java.util.concurrent.CompletableFuture<>();
                completableFuture.complete(reply);
                requests.put(replyId, completableFuture);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void onRequestWithArraysReply(final io.fd.vpp.jvpp.core.dto.RequestWithArraysReply reply) {
        java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestWithArrays>> completableFuture;
        final int replyId = reply.context;
        if (LOG.isLoggable(java.util.logging.Level.FINE)) {
            LOG.fine(String.format("Received RequestWithArraysReply event message: %s", reply));
        }
        synchronized(requests) {
            completableFuture =
            (java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestWithArrays>>) requests.get(replyId);

            if(completableFuture != null) {
                // received reply on request, complete future created by sender and remove it from map
                completableFuture.complete(reply);
                requests.remove(replyId);
            } else {
                // reply received before writer created future,
                // create new future, complete it and put into map to
                // notify sender that reply is already received
                completableFuture = new  java.util.concurrent.CompletableFuture<>();
                completableFuture.complete(reply);
                requests.put(replyId, completableFuture);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void onRequestWithVariableLengthArrayReply(final io.fd.vpp.jvpp.core.dto.RequestWithVariableLengthArrayReply reply) {
        java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestWithVariableLengthArray>> completableFuture;
        final int replyId = reply.context;
        if (LOG.isLoggable(java.util.logging.Level.FINE)) {
            LOG.fine(String.format("Received RequestWithVariableLengthArrayReply event message: %s", reply));
        }
        synchronized(requests) {
            completableFuture =
            (java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestWithVariableLengthArray>>) requests.get(replyId);

            if(completableFuture != null) {
                // received reply on request, complete future created by sender and remove it from map
                completableFuture.complete(reply);
                requests.remove(replyId);
            } else {
                // reply received before writer created future,
                // create new future, complete it and put into map to
                // notify sender that reply is already received
                completableFuture = new  java.util.concurrent.CompletableFuture<>();
                completableFuture.complete(reply);
                requests.put(replyId, completableFuture);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void onFooDetails(final io.fd.vpp.jvpp.core.dto.FooDetails reply) {
        io.fd.vpp.jvpp.future.AbstractFutureJVppInvoker.CompletableDumpFuture<io.fd.vpp.jvpp.core.dto.FooDetailsReplyDump> completableFuture;
        final int replyId = reply.context;
        if (LOG.isLoggable(java.util.logging.Level.FINE)) {
            LOG.fine(String.format("Received FooDetails event message: %s", reply));
        }
        synchronized(requests) {
            completableFuture = (io.fd.vpp.jvpp.future.AbstractFutureJVppInvoker.CompletableDumpFuture<io.fd.vpp.jvpp.core.dto.FooDetailsReplyDump>) requests.get(replyId);

            if(completableFuture == null) {
                // reply received before writer created future,
                // create new future, and put into map to notify sender that reply is already received,
                // following details replies will add information to this future
                completableFuture = new io.fd.vpp.jvpp.future.AbstractFutureJVppInvoker.CompletableDumpFuture<>(replyId,
                    new io.fd.vpp.jvpp.core.dto.FooDetailsReplyDump());
                requests.put(replyId, completableFuture);
            }
            completableFuture.getReplyDump().fooDetails.add(reply);
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void onRequestWithCustomTypeReply(final io.fd.vpp.jvpp.core.dto.RequestWithCustomTypeReply reply) {
        java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestWithCustomType>> completableFuture;
        final int replyId = reply.context;
        if (LOG.isLoggable(java.util.logging.Level.FINE)) {
            LOG.fine(String.format("Received RequestWithCustomTypeReply event message: %s", reply));
        }
        synchronized(requests) {
            completableFuture =
            (java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestWithCustomType>>) requests.get(replyId);

            if(completableFuture != null) {
                // received reply on request, complete future created by sender and remove it from map
                completableFuture.complete(reply);
                requests.remove(replyId);
            } else {
                // reply received before writer created future,
                // create new future, complete it and put into map to
                // notify sender that reply is already received
                completableFuture = new  java.util.concurrent.CompletableFuture<>();
                completableFuture.complete(reply);
                requests.put(replyId, completableFuture);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void onRequestWithCustomTypeArrayReply(final io.fd.vpp.jvpp.core.dto.RequestWithCustomTypeArrayReply reply) {
        java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestWithCustomTypeArray>> completableFuture;
        final int replyId = reply.context;
        if (LOG.isLoggable(java.util.logging.Level.FINE)) {
            LOG.fine(String.format("Received RequestWithCustomTypeArrayReply event message: %s", reply));
        }
        synchronized(requests) {
            completableFuture =
            (java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestWithCustomTypeArray>>) requests.get(replyId);

            if(completableFuture != null) {
                // received reply on request, complete future created by sender and remove it from map
                completableFuture.complete(reply);
                requests.remove(replyId);
            } else {
                // reply received before writer created future,
                // create new future, complete it and put into map to
                // notify sender that reply is already received
                completableFuture = new  java.util.concurrent.CompletableFuture<>();
                completableFuture.complete(reply);
                requests.put(replyId, completableFuture);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void onRequestWithCustomTypeVlaReply(final io.fd.vpp.jvpp.core.dto.RequestWithCustomTypeVlaReply reply) {
        java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestWithCustomTypeVla>> completableFuture;
        final int replyId = reply.context;
        if (LOG.isLoggable(java.util.logging.Level.FINE)) {
            LOG.fine(String.format("Received RequestWithCustomTypeVlaReply event message: %s", reply));
        }
        synchronized(requests) {
            completableFuture =
            (java.util.concurrent.CompletableFuture<io.fd.vpp.jvpp.dto.JVppReply<io.fd.vpp.jvpp.core.dto.RequestWithCustomTypeVla>>) requests.get(replyId);

            if(completableFuture != null) {
                // received reply on request, complete future created by sender and remove it from map
                completableFuture.complete(reply);
                requests.remove(replyId);
            } else {
                // reply received before writer created future,
                // create new future, complete it and put into map to
                // notify sender that reply is already received
                completableFuture = new  java.util.concurrent.CompletableFuture<>();
                completableFuture.complete(reply);
                requests.put(replyId, completableFuture);
            }
        }
    }

}
