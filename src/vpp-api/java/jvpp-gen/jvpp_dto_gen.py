#!/usr/bin/env python
#
# Copyright (c) 2018 Cisco and/or its affiliates.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pprint
from string import Template

_REQUEST_TEMPLATE = Template("""
package $plugin_package.dto;

/**
 * <p>This class represents request DTO.
 * <br>It was generated by dto_gen.py based on $json_filename:
 * <pre>
$json_definition
 * </pre>
 */
public final class $class_name implements io.fd.vpp.jvpp.dto.JVppRequest {
$fields
$hash_code
$equals
$to_string
$send
}
""")


def _generate_request_dto(msg, model):
    msg_java_name = msg.java_name
    fields = filter(_is_request_field, msg.fields)
    return _REQUEST_TEMPLATE.substitute(
        plugin_package=model.plugin_package,
        json_filename="// fixme msg.json_filename",
        json_definition=_api_message_to_javadoc(model.json_messages_by_name[msg.name]),
        class_name=msg_java_name,
        fields=_generate_fields(fields),
        hash_code=_generate_hash_code(fields),
        equals=_generate_equals(msg_java_name, fields),
        to_string=_generate_to_string(msg, _is_request_field),
        send=_generate_send(model, msg, _is_request_field))


def _api_message_to_javadoc(api_message):
    """ Converts vpe.api message description to javadoc """
    str = pprint.pformat(api_message, indent=4, width=120, depth=None)
    return " * " + str.replace("\n", "\n * ")


def _is_request_field(field):
    # Skip fields that are hidden to the jvpp user (handled by JNI layer)
    return field.name not in {'_vl_msg_id', 'client_index', 'context'}


_FIELD_TEMPLATE = Template("""    public $type $name;""")


def _generate_fields(fields):
    return "\n".join(map(lambda f: _FIELD_TEMPLATE.substitute(type=f.type.java_name, name=f.java_name), fields))


_HASH_CODE_TEMPLATE = Template("""
    @Override
    @io.fd.vpp.jvpp.coverity.SuppressFBWarnings("UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD")
    public int hashCode() {
        return java.util.Objects.hash($fields);
    }""")


def _generate_hash_code(fields):
    # todo would using properties remove need for 'lambda'?
    return _HASH_CODE_TEMPLATE.substitute(fields=", ".join(map(lambda f: f.java_name, fields)))


_EQUALS_TEMPLATE = Template("""
    @Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
$comparisons
        return true;
    }""")

_EQUALS_OTHER_TEMPLATE = Template("""
        final $cls_name other = ($cls_name) o;

""")

_EQUALS_FIELD_TEMPLATE = Template("""        if (!java.util.Objects.equals(this.$field_name, other.$field_name)) {
            return false;
        }
""")


def _generate_equals(msg_java_name, fields):
    comparisons = ""
    for f in fields:
        comparisons += _EQUALS_FIELD_TEMPLATE.substitute(field_name=f.java_name)
    if comparisons != "":
        comparisons = _EQUALS_OTHER_TEMPLATE.substitute(cls_name=msg_java_name) + comparisons
    return _EQUALS_TEMPLATE.substitute(comparisons=comparisons)


_TO_STRING_TEMPLATE = Template("""
    @Override
    public String toString() {
        return "$cls_name{"
$to_string_fields
            + "}";
    }""")

_TO_STRING_FIELD_TEMPLATE = Template("""            + \"$field_name=\" + $field_name + ", \"""")


def _generate_to_string(msg_java_name, fields):
    fields = "\n".join(map(
        lambda f: _TO_STRING_FIELD_TEMPLATE.substitute(field_name=f.java_name),
        filter(name_filter, msg.fields)
    ))
    return _TO_STRING_TEMPLATE.substitute(cls_name=msg.java_name, fields=fields)


_SEND_TEMPLATE = Template("""
    @Override
    public int send(final io.fd.vpp.jvpp.JVpp jvpp) throws io.fd.vpp.jvpp.VppInvocationException {
        return (($plugin_package.JVpp${plugin_name})jvpp).$method_name($args);
    }""")


def _generate_send(model, msg, name_filter):
    return _SEND_TEMPLATE.substitute(
        plugin_package=model.plugin_package,
        plugin_name=model.plugin_name,
        method_name=msg.java_method_name,
        args="" if len(filter(name_filter, msg.fields)) == 0 else "this"
    )


_REPLY_TEMPLATE = Template("""
package $plugin_package.dto;

/**
 * <p>This class represents reply DTO.
 * <br>It was generated by dto_gen.py based on $json_filename:
 * <pre>
$json_definition
 * </pre>
 */
public final class $class_name implements io.fd.vpp.jvpp.dto.JVppReply<$plugin_package.dto.$request_name> {
$fields
$hash_code
$equals
$to_string
}
""")


def _generate_reply_dto(msg, model):
    msg_java_name = msg.java_name
    fields = filter(_is_request_field, msg.fields)
    return _REPLY_TEMPLATE.substitute(
        plugin_package=model.plugin_package,
        json_filename="// fixme msg.json_filename",
        json_definition=_api_message_to_javadoc(model.json_messages_by_name[msg.name]),
        class_name=msg_java_name,
        request_name=msg.request,
        fields=_generate_fields(fields),
        hash_code=_generate_hash_code(fields),
        equals=_generate_equals(msg_java_name, fields),
        to_string=_generate_to_string(msg, _is_reply_field))


def _is_reply_field(field):
    # Skip fields that are hidden to the jvpp user:
    # * _vl_msg_id is handled at JNI layer,
    # * negative retval is mapped to java exception,
    # * context is visible to allow matching replies with requests at Java layer.
    return field.name not in {'_vl_msg_id', 'retval'}


class DtoGenerator(object):
    def __init__(self, model, logger):
        self.model = model
        self.logger = logger

    def generate(self):
        model = self.model
        for msg in model.messages:
            # todo more logs
            self.logger.debug("Generating DTO for message %s" % msg)
            # before push, change to getters or properties
            class_name = msg.java_name
            # todo(?): use dict instead of if/else (would require message type parameter)
            # another parameter is to have subclasses with generate_xxx methods
            # (disadvantage: if new api/or thing to be generated/ is added then one needs to add
            # generate_xxx to all classes

            # yet another idea is visitor pattern
            if hasattr(msg, 'reply'):
                dto = _generate_request_dto(msg, model)
            elif hasattr(msg, 'request'):
                dto = _generate_reply_dto(msg, model)
            else:
                self.logger.warn("Unsupported message: %s" % msg)
                continue
            with open('%s.java' % class_name, "w") as f:
                f.write(dto)


"""
1) generate code just for requests (done)
- structure (done)
- fields (done)
- hash_code (done)
- equals (done)
- to_string (done)
- send (done)

2) add generation for replies (done)

3) callbacks

4) C impl
* test it works end to end

5) dumps and details

6) Revisit structure of generator

7) Arrays

8) Struct types

9) Future facade

10) Events

11) Callback facade

12) Tests (optional)

** update model and unit tests for model creation 
** write tests for code generation


"""
