#!/usr/bin/env python
#
# Copyright (c) 2018 Cisco and/or its affiliates.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from string import Template

from jvpp_json_parser import is_request, is_reply, is_retval

_REQUEST_TEMPLATE = Template("""
package $plugin_package.dto;

/**
 * <p>This class represents request DTO.
 * <br>It was generated by dto_gen.py based on $json_filename:
 * <pre>
$json_definition
 * </pre>
 */
public final class $class_name implements io.fd.vpp.jvpp.dto.JVppRequest {
$fields
$hash_code
$equals
$to_string
$send
}
""")


def _generate_request_dto(msg, model):
    msg_java_name_upper = msg.java_name_upper
    fields = msg.fields
    return _REQUEST_TEMPLATE.substitute(
        plugin_package=model.plugin_package,
        json_filename=model.json_api_files,
        json_definition=msg.doc,
        class_name=msg_java_name_upper,
        fields=_generate_fields(fields),
        hash_code=_generate_hash_code(fields),
        equals=_generate_equals(msg_java_name_upper, fields),
        to_string=_generate_to_string(msg_java_name_upper, fields),
        send=_generate_send(model, msg))


_FIELD_TEMPLATE = Template("""    public $type $name;""")


def _generate_fields(fields):
    return "\n".join(_FIELD_TEMPLATE.substitute(type=f.type.java_name, name=f.java_name) for f in fields)


_HASH_CODE_TEMPLATE = Template("""
    @Override
    @io.fd.vpp.jvpp.coverity.SuppressFBWarnings("UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD")
    public int hashCode() {
        return java.util.Objects.hash($fields);
    }""")


def _generate_hash_code(fields):
    return _HASH_CODE_TEMPLATE.substitute(fields=", ".join(f.java_name for f in fields))


_EQUALS_TEMPLATE = Template("""
    @Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
$comparisons
        return true;
    }""")

_EQUALS_OTHER_TEMPLATE = Template("""
        final $cls_name other = ($cls_name) o;

""")

_EQUALS_FIELD_TEMPLATE = Template("""        if (!java.util.Objects.equals(this.$field_name, other.$field_name)) {
            return false;
        }""")


def _generate_equals(msg_java_name, fields):
    comparisons = "\n".join(_EQUALS_FIELD_TEMPLATE.substitute(field_name=f.java_name) for f in fields)
    if comparisons != "":
        comparisons = _EQUALS_OTHER_TEMPLATE.substitute(cls_name=msg_java_name) + comparisons
    return _EQUALS_TEMPLATE.substitute(comparisons=comparisons)


_TO_STRING_TEMPLATE = Template("""
    @Override
    public String toString() {
        return "$cls_name{"
$to_string_fields
            + "}";
    }""")

_TO_STRING_FIELD_TEMPLATE = Template("""            + \"$field_name=\" + $field_name + ", \"""")


def _generate_to_string(msg_java_name, fields):
    return _TO_STRING_TEMPLATE.substitute(
        cls_name=msg_java_name,
        to_string_fields="\n".join(_TO_STRING_FIELD_TEMPLATE.substitute(field_name=f.java_name) for f in fields)
    )


_SEND_TEMPLATE = Template("""
    @Override
    public int send(final io.fd.vpp.jvpp.JVpp jvpp) throws io.fd.vpp.jvpp.VppInvocationException {
        return (($plugin_package.JVpp${plugin_name})jvpp).$method_name($args);
    }""")


def _generate_send(model, msg):
    return _SEND_TEMPLATE.substitute(
        plugin_package=model.plugin_package,
        plugin_name=model.plugin_java_name,
        method_name=msg.java_name_lower,
        args="this" if msg.has_fields else ""
    )


_REPLY_TEMPLATE = Template("""
package $plugin_package.dto;

/**
 * <p>This class represents reply DTO.
 * <br>It was generated by dto_gen.py based on $json_filename:
 * <pre>
$json_definition
 * </pre>
 */
public final class $class_name implements io.fd.vpp.jvpp.dto.JVppReply<$plugin_package.dto.$request_name> {
$fields
$hash_code
$equals
$to_string
}
""")


def _generate_reply_dto(msg, model):
    msg_java_name_upper = msg.java_name_upper
    # Negative retval is mapped to java exception, so filter it out:
    fields = filter(lambda(field): not is_retval(field), msg.fields)
    return _REPLY_TEMPLATE.substitute(
        plugin_package=model.plugin_package,
        json_filename=model.json_api_files,
        json_definition=msg.doc,
        class_name=msg_java_name_upper,
        request_name=msg.request,
        fields=_generate_fields(fields),
        hash_code=_generate_hash_code(fields),
        equals=_generate_equals(msg_java_name_upper, fields),
        to_string=_generate_to_string(msg_java_name_upper, fields))


class DtoGenerator(object):
    def __init__(self, model, logger):
        self.model = model
        self.logger = logger

    def generate(self):
        model = self.model
        self.logger.debug("Generating DTOs for %s" % model.json_api_files)
        for msg in model.messages:
            class_name = msg.java_name_upper
            # todo(?): use dict instead of if/else (would require message type parameter)
            # another parameter is to have subclasses with generate_xxx methods
            # (disadvantage: if new api/or thing to be generated/ is added then one needs to add
            # generate_xxx to all classes
            # yet another idea is visitor pattern

            if is_request(msg):
                dto = _generate_request_dto(msg, model)
            elif is_reply(msg):
                dto = _generate_reply_dto(msg, model)
            else:
                self.logger.warn("Failed to generate DTO for: %s. Message type is not supported." % msg)
                continue
            with open("%s.java" % class_name, "w") as f:
                f.write(dto)
