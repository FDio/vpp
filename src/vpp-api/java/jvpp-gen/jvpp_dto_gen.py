#!/usr/bin/env python
#
# Copyright (c) 2018 Cisco and/or its affiliates.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from string import Template

REQUEST_TEMPLATE = Template("""
package $plugin_package.dto;

/**
 * <p>This class represents request DTO.
 * <br>It was generated by dto_gen.py based on $json_filename:
 * <pre>
$json_definition
 * </pre>
 */
public final class $class_name implements io.fd.vpp.jvpp.dto.JVppRequest {

$fields

$hash_code

$equals

$to_string

$send

}
""")


def generate_request_dto(msg, model):
    plugin_package = model.plugin_package
    class_name = msg.java_name
    return REQUEST_TEMPLATE.substitute(plugin_package=plugin_package,
                                       json_filename="// fixme msg.json_filename",
                                       json_definition=model.json_messages_by_name,
                                       class_name=class_name,
                                       fields=generate_request_fields(msg),
                                       hash_code="//fixme hash_code",
                                       equals="//fixme equals",
                                       to_string="//fixme to_string",
                                       send="//fixme send")


REPLY_TEMPLATE = Template("""
package $plugin_package.dto;

/**
 * <p>This class represents reply DTO.
 * <br>It was generated by dto_gen.py based on $json_filename:
 * <pre>
$json_definition
 * </pre>
 */
public final class $class_name implements io.fd.vpp.jvpp.dto.JVppReply<$plugin_package.dto.$request_name> {

$fields

$hash_code

$equals

$to_string

}
""")


def generate_reply_dto(msg, model):
    plugin_package = model.plugin_package
    class_name = msg.java_name
    return REPLY_TEMPLATE.substitute(plugin_package=plugin_package,
                                     json_filename="// fixme msg.json_filename",
                                     json_definition=model.json_messages_by_name,
                                     class_name=class_name,
                                     request_name=msg.request,
                                     fields=generate_reply_fields(msg),
                                     hash_code="//fixme hash_code",
                                     equals="//fixme equals",
                                     to_string="//fixme to_string")


FIELD_TEMPLATE = Template("""    public $type $name;\n""")


def generate_request_fields(msg):
    fields = ""
    for f in msg.fields:
        if f.name in {'_vl_msg_id', 'client_index', 'context'}:
            # skip fields that are hidden to the jvpp user (handled by JNI layer)
            continue
        fields += FIELD_TEMPLATE.substitute(type=f.type.java_name,
                                            name=f.java_name)
    return fields


def generate_reply_fields(msg):
    fields = ""
    for f in msg.fields:
        if f.name in {'_vl_msg_id', 'retval'}:
            # skip fields that are hidden to the jvpp user
            # (_vl_msg_id is handled at JNI layer, negative retval is mapped to java exception)
            # context is visible to allow matching replies with requests at Java layer
            continue
        fields += FIELD_TEMPLATE.substitute(type=f.type.java_name,
                                            name=f.java_name)
    return fields


class DtoGenerator(object):
    def __init__(self, model, logger):
        self.model = model
        self.logger = logger

    def generate(self):
        model = self.model
        for msg in model.messages:
            self.logger.debug("Generating DTO for message %s" % msg);
            # before push, change to getters or properties
            class_name = msg.java_name
            # todo(?): use dict instead of if/else (would require message type parameter)
            # another parameter is to have subclasses with generate_xxx methods
            # (disadvantage: if new api/or thing to be generated/ is added then one needs to add
            # generate_xxx to all classes

            # yet another idea is visitor pattern
            if hasattr(msg, 'reply'):
                dto = generate_request_dto(msg, model)
            elif hasattr(msg, 'request'):
                dto = generate_reply_dto(msg, model)
            else:
                self.logger.warn("Unsupported message: %s" % msg)
                continue
            with open('%s.java' % class_name, "w") as f:
                f.write(dto)


"""
1) generate code just for requests
- structure (done)
- fields (done)

- hash_code
- equals
- to_string
- send


** add generation for replies to find best structure

** update model and unit tests for model creation

** write tests for code generation

2) callbacks

3) C impl
* test it works end to end

4) dumps and details

5) Arrays

6) Struct types

7) Future facade

8) Events

9) Callback facade

"""
