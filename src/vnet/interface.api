vl_api_version 1.0.0

/** \brief Set flags on the interface
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - index of the interface to set flags on
    @param admin_up_down - set the admin state, 1 = up, 0 = down
    @param link_up_down - Oper state sent on change event, not used in config.
*/
autoreply define sw_interface_set_flags
{
  u32 client_index;
  u32 context;
  u32 sw_if_index;
  /* 1 = up, 0 = down */
  u8 admin_up_down;
};

/** \brief Set interface MTU
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - index of the interface to set MTU on
    @param mtu - MTU
*/
autoreply define sw_interface_set_mtu
{
  u32 client_index;
  u32 context;
  u32 sw_if_index;
  u16 mtu;
};

/** \brief Interface Event generated by want_interface_events
    @param client_index - opaque cookie to identify the sender
    @param pid - client pid registered to receive notification
    @param sw_if_index - index of the interface of the event
    @param admin_up_down - The administrative state; 1 = up, 0 = down
    @param link_up_down - The operational state; 1 = up, 0 = down
    @param deleted - interface was deleted
*/
define sw_interface_event
{
  u32 client_index;
  u32 pid;
  u32 sw_if_index;
  u8 admin_up_down;
  u8 link_up_down;
  u8 deleted;
};

/** \brief Register for interface events
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param enable_disable - 1 => register for events, 0 => cancel registration
    @param pid - sender's pid
*/
autoreply define want_interface_events
{
  u32 client_index;
  u32 context;
  u32 enable_disable;
  u32 pid;
};

/** \brief Interface details structure (fix this) 
    @param sw_if_index - index of the interface
    @param sup_sw_if_index - index of parent interface if any, else same as sw_if_index  
    @param l2_address_length - length of the interface's l2 address
    @param pid - the interface's l2 address
    @param interface_name - name of the interface
    @param link_duplex - 1 if half duplex, 2 if full duplex
    @param link_speed - 1 = 10M, 2 = 100M, 4 = 1G, 8 = 10G, 16 = 40G, 32 = 100G
    @param link_MTU - max. transmittion unit
    @param sub_if_id - A number 0-N to uniquely identify this subif on super if
    @param sub_dot1ad - 0 = dot1q, 1 = dot1ad
    @param sub_dot1ah - 1 = dot1ah, 0 = otherwise
    @param sub_number_of_tags - Number of tags (0 - 2)
    @param sub_outer_vlan_id
    @param sub_inner_vlan_id
    @param sub_exact_match
    @param sub_default
    @param sub_outer_vlan_id_any
    @param sub_inner_vlan_id_any
    @param vtr_op - vlan tag rewrite operation
    @param vtr_push_dot1q
    @param vtr_tag1
    @param vtr_tag2
    @param pbb_outer_tag - translate pbb s-tag
    @param pbb_b_dmac[6] - B-tag remote mac address
    @param pbb_b_smac[6] - B-tag local mac address
    @param pbb_b_vlanid - B-tag vlanid
    @param pbb_i_sid - I-tag service id
*/
define sw_interface_details
{
  u32 context;
  u32 sw_if_index;

  /* index of sup interface (e.g. hw interface).
     equal to sw_if_index for super hw interface. */
  u32 sup_sw_if_index;

  /* Layer 2 address, if applicable */
  u32 l2_address_length;
  u8 l2_address[8];

  /* Interface name */
  u8 interface_name[64];

  /* 1 = up, 0 = down */
  u8 admin_up_down;
  u8 link_up_down;

  /* 1 = half duplex, 2 = full duplex */
  u8 link_duplex;

  /* 1 = 10M, 2 = 100M, 4 = 1G, 8 = 10G, 16 = 40G, 32 = 100G */
  u8 link_speed;

  /* MTU */
  u16 link_mtu;

  /* Subinterface ID. A number 0-N to uniquely identify this subinterface under the super interface */
  u32 sub_id;

  /* 0 = dot1q, 1=dot1ad */
  u8 sub_dot1ad;
  /* 1 = dot1h, 1=otherwise */
  u8 sub_dot1ah;

  /* Number of tags 0-2 */
  u8 sub_number_of_tags;
  u16 sub_outer_vlan_id;
  u16 sub_inner_vlan_id;
  u8 sub_exact_match;
  u8 sub_default;
  u8 sub_outer_vlan_id_any;
  u8 sub_inner_vlan_id_any;

  /* vlan tag rewrite state */
  u32 vtr_op;
  u32 vtr_push_dot1q;		// ethertype of first pushed tag is dot1q/dot1ad
  u32 vtr_tag1;			// first pushed tag
  u32 vtr_tag2;			// second pushed tag
  u8 tag[64];
  
  /* pbb tag rewrite info */
  u16 outer_tag;
  u8  b_dmac[6];
  u8  b_smac[6];
  u16 b_vlanid;
  u32 i_sid;
};

/* works */
define sw_interface_dump
{
  u32 client_index;
  u32 context;
  u8 name_filter_valid;
  u8 name_filter[49];
};

/** \brief Set or delete one or all ip addresses on a specified interface
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - index of the interface to add/del addresses 
    @param is_add - add address if non-zero, else delete
    @param is_ipv6 - if non-zero the address is ipv6, else ipv4
    @param del_all - if non-zero delete all addresses on the interface
    @param address_length - address length in bytes, 4 for ip4, 16 for ip6
    @param address - array of address bytes
*/
autoreply define sw_interface_add_del_address
{
  u32 client_index;
  u32 context;
  u32 sw_if_index;
  u8 is_add;
  u8 is_ipv6;
  u8 del_all;
  u8 address_length;
  u8 address[16];
};

/** \brief Associate the specified interface with a fib table
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - index of the interface
    @param is_ipv6 - if non-zero ipv6, else ipv4
    @param vrf_id - fib table/vrd id to associate the interface with
*/
autoreply define sw_interface_set_table
{
  u32 client_index;
  u32 context;
  u32 sw_if_index;
  u8 is_ipv6;
  u32 vrf_id;
};

/** \brief Get VRF id assigned to interface
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - index of the interface
*/
define sw_interface_get_table
{
  u32 client_index;
  u32 context;
  u32 sw_if_index;
  u8 is_ipv6;
};

/** \brief Reply to get_sw_interface_vrf
    @param context - sender context which was passed in the request
    @param vrf_id - VRF id assigned to the interface
*/
define sw_interface_get_table_reply
{
  u32 context;
  i32 retval;
  u32 vrf_id;
};

typeonly manual_print manual_endian define vlib_counter
{
  u64 packets;			/**< packet counter */
  u64 bytes;			/**< byte counter  */
};

/** \brief Combined interface counter data type for vnet_interface_combined_counters
    @param sw_if_index - interface indexes for counters
    @param rx_packets - received packet count
    @param rx_bytes - received byte count
    @param tx_packets - transmitted packet count
    @param tx_bytes - transmitted byte count

*/
typeonly manual_print manual_endian define vnet_combined_counter
{
  u32 sw_if_index;
  u64 rx_packets;			/**< packet counter */
  u64 rx_bytes;			/**< byte counter  */
  u64 tx_packets;			/**< packet counter */
  u64 tx_bytes;			/**< byte counter  */
};

/** \brief Simple interface counter data type for vnet_interface_simple_counters
    @param sw_if_index - interface indexes for counters
    @param drop - RX or TX drops due to buffer starvation
    @param punt - used with VNET "punt" disposition
    @param rx_ip4 - received IP4 packets
    @param rx_ip6 - received IP6 packets
    @param rx_no_buffer - no RX buffers available
    @param rx_miss - receive misses
    @param rx_error - receive errors
    @param tx_error - transmit errors
    @param rx_mpls - received MPLS packet

*/
typeonly manual_print manual_endian define vnet_simple_counter
{
  u32 sw_if_index;
  u64 drop;
  u64 punt;
  u64 rx_ip4;
  u64 rx_ip6;
  u64 rx_no_buffer;
  u64 rx_miss;
  u64 rx_error;
  u64 tx_error;
  u64 rx_mpls;
};

/** \brief Simple stats counters structure
    @param vnet_counter_type- such as ip4, ip6, punts, etc
    @param first_sw_if_index - first sw index in block of index, counts
    @param count - number of counters, equal to the number of interfaces in
      this stats block
    @param data - contiguous block of u64 counters

    vnet_counter_type defined in enums - plural - in vnet/interface.h
*/
manual_print manual_endian define vnet_interface_simple_counters
{
  u8 vnet_counter_type;
  u32 first_sw_if_index;
  u32 count;
  u64 data[count];
};

/** \brief Combined stats counters structure
    @param vnet_counter_type- such as ip4, ip6, punts, etc
    @param first_sw_if_index - first sw index in block of index, counts
    @param count - number of counters, equal to the number of interfaces in
      this stats block
    @param data - contiguous block of vlib_counter_t structures

    vnet_counter_type defined in enums - plural - in vnet/interface.h
*/
manual_print manual_endian define vnet_interface_combined_counters
{
  u8 vnet_counter_type;
  u32 first_sw_if_index;
  u32 count;
  vl_api_vlib_counter_t data[count];
};


/** \brief Simple per interface stats counters structure
    @param count - number of elements in message
    @param timestamp - u32 vlib timestamp for control plane
    @param data[count] - vl_api_vnet_simple_counter_t 

*/
manual_print manual_endian define vnet_per_interface_simple_counters
{
  u32 count;
  u32 timestamp;
  vl_api_vnet_simple_counter_t data[count];
};

/** \brief Combined stats counters structure per interface
    @param count - number of elements in message
    @param timestamp - u32 vlib timestamp for control plane
    @param data[count] - vl_api_vnet_combined_counter_t
*/
manual_print manual_endian define vnet_per_interface_combined_counters
{
  u32 count;
  u32 timestamp;
  vl_api_vnet_combined_counter_t data[count];
};

/** \brief Set unnumbered interface add / del request
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - interface with an IP address
    @param unnumbered_sw_if_index - interface which will use the address
    @param is_add - if non-zero set the association, else unset it
*/
autoreply define sw_interface_set_unnumbered
{
  u32 client_index;
  u32 context;
  u32 sw_if_index;		/* use this intfc address */
  u32 unnumbered_sw_if_index;	/* on this interface */
  u8 is_add;
};

/** \brief Clear interface statistics
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - index of the interface to clear statistics
*/
autoreply define sw_interface_clear_stats
{
  u32 client_index;
  u32 context;
  u32 sw_if_index;
};

/** \brief Set / clear software interface tag
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - the interface
    @param add_del - 1 = add, 0 = delete
    @param tag - an ascii tag
*/
autoreply define sw_interface_tag_add_del 
{
    u32 client_index;
    u32 context;
    u8 is_add;
    u32 sw_if_index;
    u8 tag[64];
};

/** \brief Set an interface's MAC address
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - the interface whose MAC will be set
    @param mac_addr - the new MAC address
*/
autoreply define sw_interface_set_mac_address
{
    u32 client_index;
    u32 context;
    u32 sw_if_index;
    u8 mac_address[6];
};

/** \brief Set an interface's rx-mode
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - the interface whose rx-mode will be set
    @param queue_id_valid - 1 = the queue_id field is valid. 0 means all
      queue_id's
    @param queue_id - the queue number whose rx-mode will be set. Only valid
      if queue_id_valid is 1
    @param mode - polling=1, interrupt=2, adaptive=3
*/
autoreply define sw_interface_set_rx_mode
{
    u32 client_index;
    u32 context;
    u32 sw_if_index;
    u8 queue_id_valid;
    u32 queue_id;
    u8 mode;
};

/* Gross kludge, DGMS */
autoreply define interface_name_renumber
{
  u32 client_index;
  u32 context;
  u32 sw_if_index;
  u32 new_show_dev_instance;
};

define create_subif
{
  u32 client_index;
  u32 context;
  u32 sw_if_index;
  u32 sub_id;

  /* These fields map directly onto the subif template */
  u8 no_tags;
  u8 one_tag;
  u8 two_tags;
  u8 dot1ad;			// 0 = dot1q, 1=dot1ad
  u8 exact_match;
  u8 default_sub;
  u8 outer_vlan_id_any;
  u8 inner_vlan_id_any;
  u16 outer_vlan_id;
  u16 inner_vlan_id;
};

define create_subif_reply
{
  u32 context;
  i32 retval;
  u32 sw_if_index;
};

/** \brief Create a new subinterface with the given vlan id
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - software index of the new vlan's parent interface
    @param vlan_id - vlan tag of the new interface
*/
define create_vlan_subif
{
  u32 client_index;
  u32 context;
  u32 sw_if_index;
  u32 vlan_id;
};

/** \brief Reply for the vlan subinterface create request
    @param context - returned sender context, to match reply w/ request
    @param retval - return code
    @param sw_if_index - software index allocated for the new subinterface
*/
define create_vlan_subif_reply
{
  u32 context;
  i32 retval;
  u32 sw_if_index;
};

/** \brief Delete sub interface request
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - sw index of the interface that was created by create_subif
*/
autoreply define delete_subif {
  u32 client_index;
  u32 context;
  u32 sw_if_index;
};

/** \brief Create loopback interface request
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param mac_address - mac addr to assign to the interface if none-zero
*/
define create_loopback
{
  u32 client_index;
  u32 context;
  u8 mac_address[6];
};

/** \brief Create loopback interface response
    @param context - sender context, to match reply w/ request
    @param sw_if_index - sw index of the interface that was created
    @param retval - return code for the request
*/
define create_loopback_reply
{
  u32 context;
  i32 retval;
  u32 sw_if_index;
};

/** \brief Create loopback interface instance request
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param mac_address - mac addr to assign to the interface if none-zero
    @param is_specified - if non-0, a specific user_instance is being requested
    @param user_instance - requested instance, ~0 => dynamically allocate
*/
define create_loopback_instance
{
  u32 client_index;
  u32 context;
  u8 mac_address[6];
  u8 is_specified;
  u32 user_instance;
};

/** \brief Create loopback interface instance response
    @param context - sender context, to match reply w/ request
    @param sw_if_index - sw index of the interface that was created
    @param retval - return code for the request
*/
define create_loopback_instance_reply
{
  u32 context;
  i32 retval;
  u32 sw_if_index;
};

/** \brief Delete loopback interface request
    @param client_index - opaque cookie to identify the sender
    @param context - sender context, to match reply w/ request
    @param sw_if_index - sw index of the interface that was created
*/
autoreply define delete_loopback
{
  u32 client_index;
  u32 context;
  u32 sw_if_index;
};

/*
 * Local Variables:
 * eval: (c-set-style "gnu")
 * End:
 */
