{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "5afe4b84_a5a018ef",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1388
      },
      "writtenOn": "2024-06-20T08:19:26Z",
      "side": 1,
      "message": "recheck",
      "revId": "b9ed5d89e6c2ea158cf2834c4a7636243d3b0f28",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9ca75c09_b05b30be",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1388
      },
      "writtenOn": "2024-06-20T10:15:48Z",
      "side": 1,
      "message": "This is a rework of https://gerrit.fd.io/r/c/vpp/+/27141 with a fix for the problem because of which the patch was reverted in https://gerrit.fd.io/r/c/vpp/+/27346",
      "revId": "b9ed5d89e6c2ea158cf2834c4a7636243d3b0f28",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "134ec6b8_45cd438b",
        "filename": "src/vnet/bonding/cli.c",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 680
      },
      "writtenOn": "2024-06-21T15:13:37Z",
      "side": 1,
      "message": "When this code is actually getting executed in the main thread, the state and condition of the bond interface might have changed such that link up/link down event might not be valid anymore. I think we should pass the sw_if_index and event to this function. When this function is run, grab the bif from the sw_if_index. Based on the event link up/down, test the condition again prior to calling vnet_hw_interface_set_flags so that we don\u0027t erroneously set the flags to the wrong state.",
      "revId": "b9ed5d89e6c2ea158cf2834c4a7636243d3b0f28",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "95ec4900_52ba1305",
        "filename": "src/vnet/bonding/cli.c",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 680
      },
      "writtenOn": "2024-06-21T15:23:07Z",
      "side": 1,
      "message": "On a second thought, we have a bond_process already. Why not take advantage of it and send the event to bond process to handle it instead?",
      "parentUuid": "134ec6b8_45cd438b",
      "revId": "b9ed5d89e6c2ea158cf2834c4a7636243d3b0f28",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "27e59742_65e368f2",
        "filename": "src/vnet/bonding/cli.c",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1388
      },
      "writtenOn": "2024-06-24T12:19:35Z",
      "side": 1,
      "message": "\u003e When this code is actually getting executed in the main thread, the state and condition of the bond interface might have changed such that link up/link down event might not be valid anymore. I think we should pass the sw_if_index and event to this function. When this function is run, grab the bif from the sw_if_index. Based on the event link up/down, test the condition again prior to calling vnet_hw_interface_set_flags so that we don\u0027t erroneously set the flags to the wrong state.\n\nIf two events occur in a row where the first one causes the link to change and the second one changes it back, two RPCs will be scheduled one by another. The first one will make the initial change and the second one will revert it. This will be done in a single iteration of the main thread\u0027s main loop and under a barrier sync. So I don\u0027t expect any problems.\n\nThe same thing would happen if the link was updated immediately without calling RPCs. There would be two changes to the link in a raw too. The second change would cancel the first one. However, was the first one erroneous?\n\n\u003e On a second thought, we have a bond_process already. Why not take advantage of it and send the event to bond process to handle it instead?\n\nThis approach might also work. However, processes are not executed under a barrier sync. And more code would be required in order to handle the case you mentioned above.",
      "parentUuid": "95ec4900_52ba1305",
      "revId": "b9ed5d89e6c2ea158cf2834c4a7636243d3b0f28",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b6e3fb25_2a9fbc5b",
        "filename": "src/vnet/bonding/cli.c",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 680
      },
      "writtenOn": "2024-06-24T18:40:13Z",
      "side": 1,
      "message": "The bond interface can be deleted by the time this routine is run. The same hw_if_index may be recycled and used for other interface.\n\nIt is nice to have bond_process to handle events serially rather than introducing RPCs.",
      "parentUuid": "27e59742_65e368f2",
      "revId": "b9ed5d89e6c2ea158cf2834c4a7636243d3b0f28",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab327ada_a980b0ee",
        "filename": "src/vnet/bonding/cli.c",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1388
      },
      "writtenOn": "2024-06-25T11:40:15Z",
      "side": 1,
      "message": "\u003e The bond interface can be deleted by the time this routine is run. The same hw_if_index may be recycled and used for other interface.\n\nIn theory, yes. But do you know what series of events could lead to this in practice? I see that RPCs are always executed before API requests are processed. In other words, before an interface can be deleted by the control plane and hw_if_index recycled.\n\nBy the way, bond_process accepts hw_if_index and thus, also suffers from the case you are mentioning. However, in the case of a process node, it is real that it may be executed after a series of API requests of deleting a bond and creating another interface (that will get the same hw_if_index). And the event will be processed for the wrong interface.\n\n\u003e It is nice to have bond_process to handle events serially rather than introducing RPCs.\n\nRPCs are also executed serially.\n\nI think RPCs exist for a reason. Their goal is to be able to run unsafe code. And I think the goal of a process node is to be able to execute periodic tasks. No safety is implied.",
      "parentUuid": "b6e3fb25_2a9fbc5b",
      "revId": "b9ed5d89e6c2ea158cf2834c4a7636243d3b0f28",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b4aa85d_774de606",
        "filename": "src/vnet/bonding/cli.c",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 680
      },
      "writtenOn": "2024-06-26T18:36:21Z",
      "side": 1,
      "message": "I am thinking some race condition like this may happen albeit rare. The API/CLI to delete the bond interface is already in the queue, waiting for the barrier due to the worker thread is running and making this RPC call. As soon as this worker thread is done, the CLI/API to delete the bond interface is able to obtain the barrier sync and run to delete the bond interface before the RPC message gets to run.",
      "parentUuid": "ab327ada_a980b0ee",
      "revId": "b9ed5d89e6c2ea158cf2834c4a7636243d3b0f28",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    }
  ]
}