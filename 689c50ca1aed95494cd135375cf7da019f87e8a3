{
  "comments": [
    {
      "key": {
        "uuid": "bbadd277_96131c7f",
        "filename": "src/vlib/buffer_node.h",
        "patchSetId": 1
      },
      "lineNbr": 348,
      "author": {
        "id": 9
      },
      "writtenOn": "2021-09-08T14:39:40Z",
      "side": 1,
      "message": "Why uppercase? It is function....",
      "revId": "689c50ca1aed95494cd135375cf7da019f87e8a3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4014d3d4_12e0af76",
        "filename": "src/vlib/buffer_node.h",
        "patchSetId": 1
      },
      "lineNbr": 348,
      "author": {
        "id": 361
      },
      "writtenOn": "2021-09-08T14:48:11Z",
      "side": 1,
      "message": "No reason apart from my habit to use small static inline masquerading as macros.\nI can make it a macro or make it lower case, as you prefer.",
      "parentUuid": "bbadd277_96131c7f",
      "revId": "689c50ca1aed95494cd135375cf7da019f87e8a3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "143f8104_4f5789f9",
        "filename": "src/vnet/session/session_node.c",
        "patchSetId": 1
      },
      "lineNbr": 1667,
      "author": {
        "id": 193
      },
      "writtenOn": "2021-09-08T15:37:47Z",
      "side": 1,
      "message": "To avoid surprises each time the function is used, and duplicated code, why don\u0027t we do this in vlib_buffer_enqueue_to_next? And related to that, if arguments are not always vectors, we won\u0027t be able to avoid seg faults, will we?",
      "range": {
        "startLine": 1663,
        "startChar": 1,
        "endLine": 1667,
        "endChar": 43
      },
      "revId": "689c50ca1aed95494cd135375cf7da019f87e8a3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a086ed0_07d546bb",
        "filename": "src/vnet/session/session_node.c",
        "patchSetId": 1
      },
      "lineNbr": 1667,
      "author": {
        "id": 361
      },
      "writtenOn": "2021-09-08T16:02:27Z",
      "side": 1,
      "message": "Not really: the most common situation is the typical VPP node doignsomething like this:\n  u32 buffers[VLIB_FRAME_SIZE];\n  u16 nexts[VLIB_FRAMSE_SIZE];\n  ...\n  vlib_buffer_enqueue_to_next (vm, buffers, next, n);\nThis does not exhibits the issue because VLIB_FRAME_SIZE is a multiple of 64, so we won\u0027t access elements past the arrays.\nThe issue happens when the size of the arrays are not a multiple of 64 elements: in that case, we will load the last elements + overflow for up to 64 (because vectorized functions loading elements in bulk).\n\nAnd this also prevents to do that transparently in vlib_buffer_enqueue_to_next() because most of the time, we used arrays declared on the stack so we can reallocate them.\n\nMaybe a middle-ground could be to provide a specific function for vectors, but then what if someone wants to use it with a non-vector dynamically allocated array? Plus there was only 2 occurences in the codebase (fixed here) so far.\n\nBut I agree, this is inherently fragile. I tried to come up with a way to bail out at compile time but failed. I think the only bullet-proof way would be for clib_mask_compare_u16() and clib_mask_compare_u32() to not rely on the overflow optimization but Damjan was not fond of that.\nFortunately, ASan should detect that and we might be able to turn it on in CI some day :)",
      "parentUuid": "143f8104_4f5789f9",
      "range": {
        "startLine": 1663,
        "startChar": 1,
        "endLine": 1667,
        "endChar": 43
      },
      "revId": "689c50ca1aed95494cd135375cf7da019f87e8a3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea7b4dab_54b889c0",
        "filename": "src/vnet/session/session_node.c",
        "patchSetId": 1
      },
      "lineNbr": 1667,
      "author": {
        "id": 193
      },
      "writtenOn": "2021-09-08T16:08:28Z",
      "side": 1,
      "message": "Ow, should\u0027ve been more specific. I meant your middle ground solution, i.e., have 2 vlib_buffer_enqueue_to_next, the one we use today and another, say vlib_buffer_enqueue_to_next_vec, that makes sure the vectors have appropriate lengths. If we think these two examples are exceptions, then yeah, let\u0027s not bother. \n\nAnd +1 on ASan CI :-)",
      "parentUuid": "8a086ed0_07d546bb",
      "range": {
        "startLine": 1663,
        "startChar": 1,
        "endLine": 1667,
        "endChar": 43
      },
      "revId": "689c50ca1aed95494cd135375cf7da019f87e8a3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    }
  ]
}