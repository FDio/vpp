{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "509eb554_852c7696",
        "filename": "src/plugins/http/http_timer.h",
        "patchSetId": 2
      },
      "lineNbr": 62,
      "author": {
        "id": 193
      },
      "writtenOn": "2024-09-23T17:21:38Z",
      "side": 1,
      "message": "Thanks for the catch! But to avoid tw main and worker races I think we should be solving this in http_timer_process_expired_cb just like we are for tcp. \n\nWe already have the spinlock there so let\u0027s do 2 iterations over expired_timers:\n- in the first, let\u0027s invalidate hc-\u003etimer_handle (as opposed to doing it in http_conn_timeout_cb) and mark the connection as having a pending timer\n- and in the second let\u0027s do the rpcs\n\nThen, in timer stop, remove the pending flag if we have one. In update, start the timer if timer_handle \u003d\u003d ~0. \n\nIn http_conn_timeout_cb we should not timeout the connection if the timer is not pending and we should avoid expiring if the timer has been rearmed (update case). That is, if we stop the timer while its handler is pending, we accept it as a stop.",
      "revId": "b829d9b936dd70053581807aaadab9ba39a2155f",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8180111d_27883141",
        "filename": "src/plugins/http/http_timer.h",
        "patchSetId": 2
      },
      "lineNbr": 62,
      "author": {
        "id": 1737
      },
      "writtenOn": "2024-09-24T01:06:43Z",
      "side": 1,
      "message": "1. Getting http_conn_t is not safe in http_timer_process_expired_cb\n2. There maybe rx\u0027event in session rpc pending ring before timer timeout rpc",
      "parentUuid": "509eb554_852c7696",
      "revId": "b829d9b936dd70053581807aaadab9ba39a2155f",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "776b9523_03cba933",
        "filename": "src/plugins/http/http_timer.h",
        "patchSetId": 2
      },
      "lineNbr": 62,
      "author": {
        "id": 193
      },
      "writtenOn": "2024-09-24T02:15:34Z",
      "side": 1,
      "message": "1. It is safe to read the connection structs, it\u0027s not safe to alloc/free them (see pool_get_aligned_safe). \n2. Not sure I follow this concern. The rx events are processed typically in session_input, rpcs in session_node. All of those are handled on the worker that owns the session, hence the rpc from main. If the session timer gets updated while rpc is pending handling, we should accept it as a timely update. \n\nAnother important thing to keep in mind here is that timer handles can be reused. If a timer handle TH for http conn X expires and RPC is programmed but before handler is called 1) the timer handle TH is reused for connection Y and 2) either stop/update are called conn X for TH, it will break conn Y. \n\nSo it\u0027s critical to mark the handle as invalid ASAP on the http connection",
      "parentUuid": "8180111d_27883141",
      "revId": "b829d9b936dd70053581807aaadab9ba39a2155f",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    }
  ]
}