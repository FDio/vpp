{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "011e87e5_85c63053",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 2551
      },
      "writtenOn": "2024-12-10T19:03:58Z",
      "side": 1,
      "message": "updated.",
      "revId": "4274102bc1babcb8cd8f52810f9af67d13101bbf",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "479de5a5_6b7492e2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 2551
      },
      "writtenOn": "2025-01-10T16:55:39Z",
      "side": 1,
      "message": "Hi Dave,\nI wonder if you could spare sometime to review this change ?\nThanks,\nDau",
      "revId": "4274102bc1babcb8cd8f52810f9af67d13101bbf",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "000a7ccc_1bb1fba4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 361
      },
      "writtenOn": "2025-01-14T15:59:11Z",
      "side": 1,
      "message": "Do we really want to add more parsers in vnet?\nThere are a couple of alternative already.\n\nYou can use \u0027hex\u0027 to match for Geneve here as you already know the option size etc. To help you generate the right \u0027hex\u0027-based stanza, you can use eg. scapy:\n-------8\u003c-------8\u003c-------8\u003c-------8\u003c-------8\u003c-------8\u003c-------\nfrom scapy.all import *\nfrom scapy.contrib.geneve import *\n\n# compute mask \u0026 match by XOR-ing a template packet\np \u003d (Ether()/IP(chksum\u003d0)/UDP(chksum\u003d0)/GENEVE()/Ether()/IP(chksum\u003d0)/UDP(chksum\u003d0))\ntmpl \u003d raw(p)\n\n# compute \u0026 print mask\np[GENEVE].vni \u003d 0xffffff\nuser \u003d p[GENEVE].payload\nuser[IP].src \u003d \u0027255.255.255.255\u0027\nmask \u003d raw(p)\nmask \u003d \"\".join((\"{:02x}\".format(a ^ b) for a, b in zip(tmpl, mask)))\n\n# compute \u0026 print match\np[GENEVE].vni \u003d 1\nuser \u003d p[GENEVE].payload\nuser[IP].src \u003d \u00271.1.1.1\u0027\nmatch \u003d raw(p)\nmatch \u003d \"\".join((\"{:02x}\".format(a ^ b) for a, b in zip(tmpl, match)))\n\nprint(\"classify filter pcap mask hex \" + mask + \" match hex \" + match)\n-------8\u003c-------8\u003c-------8\u003c-------8\u003c-------8\u003c-------8\u003c-------\n\nAn alternative could be to adapt extras/packetforge for this.\n\nAnother alternative is src/plugins/bpf_trace_filter which allows you to use BPF for filters which already supports Geneve.\n\nThoughts?",
      "revId": "4274102bc1babcb8cd8f52810f9af67d13101bbf",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7b20d16_dc0c6c8d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 3021
      },
      "writtenOn": "2025-01-14T16:04:55Z",
      "side": 1,
      "message": "a while back i tried the bpf_trace_filter and it worked great for tracing geneve encapped packets, but i couldn\u0027t get it to work for generating filtered pcaps. maybe i was doing it wrong, but i gave up.",
      "parentUuid": "000a7ccc_1bb1fba4",
      "revId": "4274102bc1babcb8cd8f52810f9af67d13101bbf",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d150c88_eae25309",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 361
      },
      "writtenOn": "2025-01-14T16:11:03Z",
      "side": 1,
      "message": "So initially, you had to specify a classify filter alongside the bpf filter for pcap on the basis that bpf filter evaluation is costly, so you should prefilter. For example, filter on geneve vni (which is fixed offset) with classifier and then apply bpf to those.\nBut we recognized you might just want to just use bpf and pay the cost, and this was changed in Dec: https://gerrit.fd.io/r/c/vpp/+/41933\nMaybe that was your issue?",
      "parentUuid": "f7b20d16_dc0c6c8d",
      "revId": "4274102bc1babcb8cd8f52810f9af67d13101bbf",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef8d7c0e_26009d17",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 3021
      },
      "writtenOn": "2025-01-14T16:16:23Z",
      "side": 1,
      "message": "very possible. i was trying this last July. my note mentioned:\nset trace filter function bpf_trace_filter\nset bpf trace filter {{geneve \u0026\u0026 tcp port 243}}\ntrace add memif-input 100 filter\n\nwhich worked well, then a day later I said \"i still haven\u0027t figured out how to get the filter working for pcap, keeps complaining i don\u0027t have a classifier configured or something.\" ðŸ˜Š",
      "parentUuid": "0d150c88_eae25309",
      "revId": "4274102bc1babcb8cd8f52810f9af67d13101bbf",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a049cf6e_6e17ac53",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 2551
      },
      "writtenOn": "2025-01-14T16:33:01Z",
      "side": 1,
      "message": "Hi Benoit, I was using the hex but it\u0027s hard to document for others to use when there\u0027s a customer issue and it\u0027s required to capture the pcap. This is just make it easier to document. I also couldn\u0027t get the bpf working with the pcap back then. I could try it again on the latest build.",
      "revId": "4274102bc1babcb8cd8f52810f9af67d13101bbf",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "A maximum vote is required for the \u0027Code-Review\u0027 label.                         A minumum vote is blocking."
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX AND -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX","label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "4274102bc1babcb8cd8f52810f9af67d13101bbf",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Verified",
        "description": {
          "value": "A maximum \u0027Verified\u0027 vote is required for the \u0027Verified\u0027 label. A minimum vote is blocking."
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Verified\u003dMAX AND -label:Verified\u003dMIN"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Verified=MAX AND -label:Verified=MIN"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["label:Verified=MAX"],"failingAtoms":["label:Verified=MIN"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "4274102bc1babcb8cd8f52810f9af67d13101bbf",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}