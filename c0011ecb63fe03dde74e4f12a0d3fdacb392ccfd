{
  "comments": [
    {
      "key": {
        "uuid": "3a3291f1_c2d7abec",
        "filename": "src/vlib/buffer.h",
        "patchSetId": 3
      },
      "lineNbr": 126,
      "author": {
        "id": 7
      },
      "writtenOn": "2017-01-31T22:25:48Z",
      "side": 1,
      "message": "This is a good reason to spend one of these bytes...",
      "revId": "c0011ecb63fe03dde74e4f12a0d3fdacb392ccfd",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a3291f1_22f8af7b",
        "filename": "src/vlib/buffer_funcs.h",
        "patchSetId": 3
      },
      "lineNbr": 534,
      "author": {
        "id": 7
      },
      "writtenOn": "2017-01-31T22:25:48Z",
      "side": 1,
      "message": "Head_end_offset \u003d end of per-clone variable portion of the packet. The split-point between replicated / editable octets, and \"read-only, do not disturb\" octets.",
      "revId": "c0011ecb63fe03dde74e4f12a0d3fdacb392ccfd",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a3291f1_a2049f7e",
        "filename": "src/vlib/buffer_funcs.h",
        "patchSetId": 3
      },
      "lineNbr": 547,
      "author": {
        "id": 7
      },
      "writtenOn": "2017-01-31T22:25:48Z",
      "side": 1,
      "message": "ASSERT(n_buffers \u003e 0) // trust me, it will happen",
      "revId": "c0011ecb63fe03dde74e4f12a0d3fdacb392ccfd",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a3291f1_4203bb73",
        "filename": "src/vlib/buffer_funcs.h",
        "patchSetId": 3
      },
      "lineNbr": 549,
      "author": {
        "id": 7
      },
      "writtenOn": "2017-01-31T22:25:48Z",
      "side": 1,
      "message": "Is one cache line the right \"just effing copy the buffer\" threshold? I would have guessed that maybe 2 or 3 lines was the crossover point...",
      "revId": "c0011ecb63fe03dde74e4f12a0d3fdacb392ccfd",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a3291f1_8209a397",
        "filename": "src/vlib/buffer_funcs.h",
        "patchSetId": 3
      },
      "lineNbr": 551,
      "author": {
        "id": 7
      },
      "writtenOn": "2017-01-31T22:25:48Z",
      "side": 1,
      "message": "Might consider returning src_buffer in buffers[0], to make loop more obvious for (i \u003d 1; i \u003c n_buffers; i++) or some such",
      "revId": "c0011ecb63fe03dde74e4f12a0d3fdacb392ccfd",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a3291f1_e2daa716",
        "filename": "src/vlib/buffer_funcs.h",
        "patchSetId": 3
      },
      "lineNbr": 587,
      "author": {
        "id": 766
      },
      "writtenOn": "2017-01-31T22:32:00Z",
      "side": 1,
      "message": "If the buffer gets cloned again, would that overwrite the clone_count established first time? So that a given src_bufffer should only be cloned once? (This call does a straight write of the field which is different from the vlib_buffer_attach_clone() call below that a) does an add rather than a set, and b) uses an __sync call to do it.)",
      "revId": "c0011ecb63fe03dde74e4f12a0d3fdacb392ccfd",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a3291f1_02f5b382",
        "filename": "src/vlib/buffer_funcs.h",
        "patchSetId": 3
      },
      "lineNbr": 603,
      "author": {
        "id": 766
      },
      "writtenOn": "2017-01-31T22:32:00Z",
      "side": 1,
      "message": "I initially misunderstood the usage pattern for this routine to involve first a vlib_buffer_clone(), then a vlib_buffer_attach_clone() to attach the cloned buffer to a head. Looking at how clone_count reference count is handled, that would lead to a memory leak.\n\nIn general, looking further, seems that a) the intent is that cloning can\u0027t be nested (can\u0027t clone if the buffer chain already contains a clone) and that error isn\u0027t checked for (silent buffer leak vs. adding a new flag that records that next_buffer was filled in by a cloning operation).\n\nThat\u0027s fine if so -- just making sure I understand the properties of the two APIs.",
      "range": {
        "startLine": 603,
        "startChar": 0,
        "endLine": 603,
        "endChar": 24
      },
      "revId": "c0011ecb63fe03dde74e4f12a0d3fdacb392ccfd",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a3291f1_02ced35a",
        "filename": "src/vlib/buffer_funcs.h",
        "patchSetId": 3
      },
      "lineNbr": 610,
      "author": {
        "id": 766
      },
      "writtenOn": "2017-01-31T22:32:00Z",
      "side": 1,
      "message": "Looks like missing ~ above. The line as written clears all flags _except_ TOTAL_LENGTH_VALID when the intent is probably to clear _just_ TOTAL_LENGTH_VALID.",
      "revId": "c0011ecb63fe03dde74e4f12a0d3fdacb392ccfd",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a3291f1_e2f18796",
        "filename": "src/vlib/buffer_funcs.h",
        "patchSetId": 3
      },
      "lineNbr": 618,
      "author": {
        "id": 7
      },
      "writtenOn": "2017-01-31T22:25:48Z",
      "side": 1,
      "message": "Why is this an atomic op? Is there any danger that the buffer will have been freed before the clone_count increment takes effect?",
      "revId": "c0011ecb63fe03dde74e4f12a0d3fdacb392ccfd",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    }
  ]
}