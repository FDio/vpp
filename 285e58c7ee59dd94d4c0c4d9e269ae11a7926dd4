{
  "comments": [
    {
      "key": {
        "uuid": "2811a064_37742604",
        "filename": "src/vnet/bonding/device.c",
        "patchSetId": 4
      },
      "lineNbr": 167,
      "author": {
        "id": 79
      },
      "writtenOn": "2018-05-15T23:44:12Z",
      "side": 1,
      "message": "Since you\u0027re returning a u32, it seems like you could hash this as two integers XORed for fewer instructions (1 versus 7).  You\u0027d need to do something more with the result than simply a modulus but you\u0027d have cycles in hand.\n\nAlso, since you are (almost certainly) %2\u0027ing the result, and x%2 \u003d\u003d x\u00261, you are losing 7/8 of your entropy.  This applies to all your functions, though in the other cases it\u0027s 31/32 of your entropy.\n\nGiven you\u0027re doing it on a value which - here - is 0..255, you\u0027re going to find poor bond balancing at higher bond counts.  Probably we don\u0027t get high enough to care.\n\nYou should examining the ECMP code, which must also be hashing.  You should be sharing code with it if at all possible, so that hashing improvements benefit both components.\n\nConsider using something like tghe SSE4.2 CRC32 function - it has a polynomial included that spreads the entropy across all of the bits as it incorporates more data.",
      "revId": "285e58c7ee59dd94d4c0c4d9e269ae11a7926dd4",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ebf0b0a0_f62c77f0",
        "filename": "src/vnet/bonding/device.c",
        "patchSetId": 4
      },
      "lineNbr": 181,
      "author": {
        "id": 79
      },
      "writtenOn": "2018-05-15T23:44:12Z",
      "side": 1,
      "message": "You could skip the first two bytes of the MAC and hash the last four with an XOR.  Since the first bytes have fixed bits (most packets aren\u0027t multicast) it has less entropy in than the rest.",
      "revId": "285e58c7ee59dd94d4c0c4d9e269ae11a7926dd4",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "02888314_4c7a6fed",
        "filename": "src/vnet/bonding/device.c",
        "patchSetId": 4
      },
      "lineNbr": 181,
      "author": {
        "id": 9
      },
      "writtenOn": "2018-05-16T20:18:27Z",
      "side": 1,
      "message": "People tend to put any kind of junk into mac address those days with virtual nics so better to hash everything...",
      "parentUuid": "ebf0b0a0_f62c77f0",
      "revId": "285e58c7ee59dd94d4c0c4d9e269ae11a7926dd4",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fba9653e_fbbc8dd9",
        "filename": "src/vnet/bonding/device.c",
        "patchSetId": 4
      },
      "lineNbr": 181,
      "author": {
        "id": 79
      },
      "writtenOn": "2018-05-16T20:26:20Z",
      "side": 1,
      "message": "They do, but there are things you can\u0027t get away with - mcast and bcast MACs are different from unicast.  I\u0027m only saying that if you wanted to drop bytes from the MAC in the name of speed those are the two with least entropy because there are a set of predetermined values certain bits there can take - the rest of the MAC is wide open.\n\nIt\u0027s not the greatest optimisation, anyway - more of a concern here is we\u0027re probably only seeing the 6 bottom bits in our hashing entropy in most circumstances.",
      "parentUuid": "02888314_4c7a6fed",
      "revId": "285e58c7ee59dd94d4c0c4d9e269ae11a7926dd4",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6cee3dcf_a7c546d7",
        "filename": "src/vnet/bonding/device.c",
        "patchSetId": 4
      },
      "lineNbr": 181,
      "author": {
        "id": 680
      },
      "writtenOn": "2018-05-16T20:37:31Z",
      "side": 1,
      "message": "For L3, you suggest using CRC as done by lb_hash_hash(). For L2, do you recommend using CRC also or is simple XOR hash good enough?",
      "parentUuid": "fba9653e_fbbc8dd9",
      "revId": "285e58c7ee59dd94d4c0c4d9e269ae11a7926dd4",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "56527434_2e53d973",
        "filename": "src/vnet/bonding/device.c",
        "patchSetId": 4
      },
      "lineNbr": 181,
      "author": {
        "id": 79
      },
      "writtenOn": "2018-05-16T20:59:08Z",
      "side": 1,
      "message": "Looking at the code for lb_hash_hash (which takes 5x u64s) I would probably steal liberally from that.  My guess is that it will be faster than your XOR code as well.  If you look at the non-SSE version it uses a polynomial after applying the XOR, which will spread the entropy around the data in the non-SSE4.2 case (which I doubt will come up in most cases, though I guess someone should come up with a nice ARM version).\n\nIf you had an hash_apply_l[23] set of functions that added the value into a hash rather than making a separate hash you had to merge, you could use crc32 repeatedly on your multiple sources.  Its output is actually a u32 and there is also a u32 version and a u16 version (both of which still generate 32 bit outputs).\n\nhttps://software.intel.com/sites/landingpage/IntrinsicsGuide/#text\u003dcrc\u0026expand\u003d1246,1245,1244",
      "parentUuid": "6cee3dcf_a7c546d7",
      "revId": "285e58c7ee59dd94d4c0c4d9e269ae11a7926dd4",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9d283ff5_808c3d7e",
        "filename": "src/vnet/bonding/device.c",
        "patchSetId": 4
      },
      "lineNbr": 181,
      "author": {
        "id": 78
      },
      "writtenOn": "2018-05-16T21:03:56Z",
      "side": 1,
      "message": "If we can assume src mac field is always 32-bit aligned...\nFor this particular function, the code uses 10 XORs.\nGiven that src and dst are always adjacent, it would be cheaper to consider the buffer starting at src offset to be an array of 3 x u32 numbers, XOR the 3 numbers (using typecast) and then xor the 4 bytes of the u32 result to get the same result for a cost of 5 XORs (half cost).",
      "parentUuid": "56527434_2e53d973",
      "revId": "285e58c7ee59dd94d4c0c4d9e269ae11a7926dd4",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d1de5fd6_0c245e1f",
        "filename": "src/vnet/bonding/device.c",
        "patchSetId": 4
      },
      "lineNbr": 181,
      "author": {
        "id": 79
      },
      "writtenOn": "2018-05-16T23:01:07Z",
      "side": 1,
      "message": "I don\u0027t know about the alignment.  I do see there that that same function can be useful with 32, 16 and 8 bit inputs and since we\u0027re after a hash a meaningful CRC isn\u0027t really a requirement, so we can deal with alignment with different instructions if we must.",
      "parentUuid": "9d283ff5_808c3d7e",
      "revId": "285e58c7ee59dd94d4c0c4d9e269ae11a7926dd4",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    }
  ]
}