{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8833c9ce_96a7ea04",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 2220
      },
      "writtenOn": "2024-02-28T12:58:01Z",
      "side": 1,
      "message": "Hello guys,\nThis patch fixes broken nat-t scnerio, where 2 flows udp/500 and udp/4500 are received from different queues (and go to different workers as well).\nHowever, I decided not to memorize ike sa (e.g. by creating hash table worker_by_rspi) and hand it over to the corresponding worker rather than handing everything over to the main thread.\nIt will open a window for a couple of simplifications (I can include them to this patch or to the next one). Also, I don\u0027t think we really need MT enabled plugin as dataplane for ipsec is already processed by multiple workers w/o issues.\nWhat do you think?",
      "revId": "9621c0237c1df11047f5dae67272426affcaaf81",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a86e2d4d_d58a49ae",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 361
      },
      "writtenOn": "2024-03-04T15:20:25Z",
      "side": 1,
      "message": "I think the idea of having a single thread responsible for an IKE SA is sound, but I\u0027m a bit wary of handoff\u0027ing everything to the main thread: that would open the main thread to DoS in this case.\nI understand that avoid maintaining a table to steer the SA to the correct worker, but as you\u0027ll create an entry anyway, I\u0027m not sure what the benefit is here?",
      "revId": "9621c0237c1df11047f5dae67272426affcaaf81",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e72323cd_c803ac65",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 2220
      },
      "writtenOn": "2024-03-04T20:26:50Z",
      "side": 1,
      "message": "For DoS - I think we have a natural limit with 1k queue size for the handover packets. In case of DoS the excess will be dropped and the main thread should be good. Though an attack still can force vpp to drop some valid ike packets in this case.\n\nRegarding simplifications, I\u0027m just in favour of having a simpler implementation of IKE. I don\u0027t have strong arguments, only small ones:\n* for nat-t + multi-workers + multi-queue we will be handing over almost all the packets to original thread anyway (so why just don\u0027t hand it over to the main thread instead)\n* no need to call rpc_call_main_thread every time from a worker\n* it will be much more error-proof in terms of synchronization (although I don\u0027t know any issues with that)\n* less memory footprint (as we can get rid of per-thread data)\n* wireguard plugin has the same approach (main thread for control packets)\n\nPersonally, I have in production vpp with this patch (and another one that fixes phase 2 rekeying for initiator) and now it\u0027s much more stable than before.\n\nAnyway, it\u0027s up to maintainers to decide. If you want - I can handover the packets  to the serving worker by the rspi field.",
      "parentUuid": "a86e2d4d_d58a49ae",
      "revId": "9621c0237c1df11047f5dae67272426affcaaf81",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ad099691_da0168b9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 2220
      },
      "writtenOn": "2024-03-13T15:57:29Z",
      "side": 1,
      "message": "Let\u0027s agree on the logic and I will adjust the patch correspondingly. I can keep the desired behaviour for me in my local repo :)",
      "revId": "9621c0237c1df11047f5dae67272426affcaaf81",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bb479e44_9be19807",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 361
      },
      "writtenOn": "2024-03-15T09:39:54Z",
      "side": 1,
      "message": "I fully agree with the goal of having a simpler ike implementation.\nWhat about always handoff to the 1st worker instead? I\u0027d feel more comfortable than main thread processing packets...",
      "revId": "9621c0237c1df11047f5dae67272426affcaaf81",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "828fad9a_2fd3793d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 2220
      },
      "writtenOn": "2024-05-14T16:42:11Z",
      "side": 1,
      "message": "my main concert is that I won\u0027t be able to simplify a couple of things I wanted to simplify. (e.g. get rid of vl_api_rpc_call_main_thread and atomics).\n\nalso (concerning my next patches for ikev2), it\u0027d be a bit more difficult to do a cleanup of old remote ids. I noticed that sometimes phase 2 expires, than immediately expires phase 1 and strongswan asks for a phase 2 rekey again. while we still have an old remote id present - the current implementation fails to process this request and sessions goes to unknown state. I fixed that by calling the cleanup directly from rekeying code when this is the case (this works fine if we are executing it on main thread).\n\nmy last argument would be - look, the wireguard plugin has the similar approach with handing off packets to main thread :) \n\nbut if you say you\u0027d be more comfortable with control packets on the 1st worker only - so it is. I will rework this patch later this week.\n\nPS I also thought about keeping current behaviour with sessions mapped to 1 worker, but I don\u0027t see a simple proper solution for that:\n* we can\u0027t dispatch stateless-ly based on rpsi (e.g. next_worker \u003d rspi % workers_num ) - since phase 1 rekeying change the rspi and packets could get processed by another worker\n* basic hash table isn\u0027t thread safe, so the only way to maintain one hash table to determine the next worker is clib_bihash. this looks like an overkill to me.",
      "parentUuid": "bb479e44_9be19807",
      "revId": "9621c0237c1df11047f5dae67272426affcaaf81",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    }
  ]
}