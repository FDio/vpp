{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c5159714_d8f8ae06",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 680
      },
      "writtenOn": "2025-09-26T21:12:13Z",
      "side": 1,
      "message": "Do we really need the spinlock? It looks like the race condition is for these 2 variables,\nn_since_last_int\nint_deadline\nCan we use clib_atomic operation on them and not use spinlock?",
      "revId": "1e08ee2a4620ffbbeece38d4433f4adac0ba03f1",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ff47f558_80551c02",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1388
      },
      "writtenOn": "2025-09-29T07:12:20Z",
      "side": 1,
      "message": "I guess atomics would work too. Actually, spinlock is based on them too. So I think it is simpler and probably better to run one atomic operation (for `int_lock`) instead of two (for `n_since_last_int` and `int_deadline`).\n\nI wonder why you don\u0027t like the spinlock? Now, only one thread will be locked and only for a very short period of time. And spinlocks, as I know, are good in such cases.",
      "parentUuid": "c5159714_d8f8ae06",
      "revId": "1e08ee2a4620ffbbeece38d4433f4adac0ba03f1",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3e37b9f5_a292afd9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 680
      },
      "writtenOn": "2025-09-29T15:50:27Z",
      "side": 1,
      "message": "The application for spinlock is to protect a large section of code. For the race condition of a simple variable, it makes more sense to use atomic operations and not spinlock unless you tell me atomic operations do not work.",
      "parentUuid": "ff47f558_80551c02",
      "revId": "1e08ee2a4620ffbbeece38d4433f4adac0ba03f1",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "696a4ff9_04e0cf12",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1388
      },
      "writtenOn": "2025-09-30T12:03:45Z",
      "side": 1,
      "message": "Can you clarify your expectations of using atomic operations? Do you expect to see a better performance or to make the code follow the guidelines?",
      "parentUuid": "3e37b9f5_a292afd9",
      "revId": "1e08ee2a4620ffbbeece38d4433f4adac0ba03f1",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6fc53835_3329103a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 680
      },
      "writtenOn": "2025-09-30T22:08:21Z",
      "side": 1,
      "message": "Vratko, would you please run csit vhost performance test on this patch to ensure that there is no degradation?",
      "revId": "1e08ee2a4620ffbbeece38d4433f4adac0ba03f1",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3094db39_b1aa1fec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1388
      },
      "writtenOn": "2025-11-06T10:48:32Z",
      "side": 1,
      "message": "I\u0027d like to clarify more on the possibility of using atomic operations in this particular case.\n\n\u003e For the race condition of a simple variable, it makes more sense to use atomic operations and not spinlock [...]\n\nThe point is that this patch doesn\u0027t fix a race condition of a simple variable. It fixes a race of the decision-making procedure. Basically, we can divide the procedure on these three steps: (1) read the controlling variables, (2) make the decision based on them, and (3) write/reset the controlling variables. And the bigger the gap is between (1) and (3), the higher are the chances for the race. In order to fix the race, the whole procedure needs to happen as a single, uninterrupted step. This is what the spinlock does. Otherwise, we can\u0027t fully eliminate the race. Even if we make (1) and (3) atomic, it doesn\u0027t guarantee that the whole decision will be atomic. It would still be possible for two threads to atomically read the variables about the same time, duplicate the decision, and atomically write/reset the variables.\n\nI guess the race may be fixed not using a spinlock. One of the ways I can think of is to make (1) atomic and do atomic compare-and-swap on step (3). Then, if (3) succedes, meaning the values we have read on step (1) are still valid, we can proceed to the syscall. If it fails, meaning the other thread has changed the values since our read, we can tell what exactly has changed (time or the number), whether our decision is still actual or the other thread outperformed us and we should skip the syscall. However, there will likely be needed a version of compare-and-swap that can work with 128 bit values to be able to reset the controlling variables in one step (they are f64 and u16). And such version may not be supported.",
      "parentUuid": "696a4ff9_04e0cf12",
      "revId": "1e08ee2a4620ffbbeece38d4433f4adac0ba03f1",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "440fec1f_d2a8d228",
        "filename": "src/plugins/vhost/vhost_user.c",
        "patchSetId": 2
      },
      "lineNbr": 1260,
      "author": {
        "id": 680
      },
      "writtenOn": "2025-09-26T21:12:13Z",
      "side": 1,
      "message": "txq is init but not lock. When the code enters here, we\u0027d do unlock.",
      "revId": "1e08ee2a4620ffbbeece38d4433f4adac0ba03f1",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e933d7b7_f35205ab",
        "filename": "src/plugins/vhost/vhost_user.c",
        "patchSetId": 2
      },
      "lineNbr": 1260,
      "author": {
        "id": 1388
      },
      "writtenOn": "2025-09-29T07:12:20Z",
      "side": 1,
      "message": "Right, just to simplify the code, because unlock is safe to do any number of times. For example, in vhost_user_output.c, `vring_lock` is locked only if the queue is shared, but unlock happens unconditionally.",
      "parentUuid": "440fec1f_d2a8d228",
      "revId": "1e08ee2a4620ffbbeece38d4433f4adac0ba03f1",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b939a52_2758684f",
        "filename": "src/plugins/vhost/vhost_user.c",
        "patchSetId": 2
      },
      "lineNbr": 1266,
      "author": {
        "id": 680
      },
      "writtenOn": "2025-09-26T21:12:13Z",
      "side": 1,
      "message": "Same here",
      "revId": "1e08ee2a4620ffbbeece38d4433f4adac0ba03f1",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    }
  ]
}