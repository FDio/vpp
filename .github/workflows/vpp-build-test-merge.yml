name: vpp-build-test-merge
# This workflow can be triggered ONLY manually (workflow_dispatch) or by other workflows (workflow_call)

on:
  # Manual trigger via UI/API
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to test (master, stable/2502, stable/2506)'
        required: true
        default: 'master'
        type: choice
        options:
          - master
          - stable/2502
          - stable/2506
      commit_sha:
        description: 'Exact commit SHA to build/test/merge (optional)'
        required: false
        type: string
      builder_type:
        description: 'Builder image type (prod or sandbox)'
        required: false
        default: 'prod'
        type: choice
        options:
          - prod
          - sandbox
      build_type:
        description: 'Build type selection (debug, release, or both)'
        required: false
        default: 'both'
        type: choice
        options:
          - both
          - debug
          - release
      reason:
        description: 'Reason for manual trigger'
        required: false
        default: 'Manual VPP Build and Test'
      make_parallel_jobs:
        description: 'MAKE_PARALLEL_JOBS value (number of parallel make jobs)'
        required: false
        default: '16'
        type: string
      Build:
        description: 'Run only build phase (no tests, no merge)'
        required: false
        default: false
        type: boolean
      Test:
        description: 'Run build + test phases (skip merge)'
        required: false
        default: false
        type: boolean
      Merge:
        description: 'Run build + merge phases (skip tests)'
        required: false
        default: false
        type: boolean
  # Invocation from other workflows
  workflow_call:
    inputs:
      branch:
        description: 'Branch to test'
        required: false
        default: 'master'
        type: string
      commit_sha:
        description: 'Exact commit SHA to build/test/merge'
        required: false
        type: string
      builder_type:
        description: 'Builder image type (prod or sandbox)'
        required: false
        default: 'prod'
        type: string
      build_type:
        description: 'Build type selection (debug, release, or both)'
        required: false
        default: 'both'
        type: string
      reason:
        description: 'Reason for trigger'
        required: false
        default: 'Called from another workflow'
        type: string
      make_parallel_jobs:
        description: 'MAKE_PARALLEL_JOBS value (number of parallel make jobs)'
        required: false
        default: '16'
        type: string
      Build:
        description: 'Run only build phase (no tests, no merge)'
        required: false
        default: false
        type: boolean
      Test:
        description: 'Run build + test phases (skip merge)'
        required: false
        default: false
        type: boolean
      Merge:
        description: 'Run build + merge phases (skip tests)'
        required: false
        default: false
        type: boolean

defaults:
  run:
    shell: bash

jobs:
  setup-env:
    runs-on:
      - self-hosted
      - nomad
      - fdio:arch=amd64
      - fdio:class=builder
      - fdio:namespace=sandbox
    outputs:
      runner_ip: ${{ steps.set_vars.outputs.runner_ip }}
      runner_name: ${{ steps.set_vars.outputs.runner_name }}
      target_branch: ${{ steps.determine_branch.outputs.branch }}
    steps:
      - name: Set runner info
        id: set_vars
        run: |
          echo "runner_ip=$(hostname -I | cut -d' ' -f1)" >> $GITHUB_OUTPUT
          echo "runner_name=$(hostname)" >> $GITHUB_OUTPUT

      - name: Determine target branch
        id: determine_branch
        run: |
          # For workflow_call, use the branch from the inputs if provided
          if [[ -n "${{ inputs.branch }}" ]]; then
            SELECTED_BRANCH="${{ inputs.branch }}"
            echo "Using branch from workflow_call: $SELECTED_BRANCH"
            echo "branch=$SELECTED_BRANCH" >> $GITHUB_OUTPUT
          else
            # For manual workflow_dispatch, use provided input or default to master
            SELECTED_BRANCH="${{ github.event.inputs.branch || 'master' }}"
            echo "Using manually selected branch: $SELECTED_BRANCH"
            echo "branch=$SELECTED_BRANCH" >> $GITHUB_OUTPUT
          fi

  vpp-verify:
    needs: setup-env
    runs-on:
      - self-hosted
      - nomad
      - fdio:arch=${{ matrix.executor-arch }}
      - fdio:class=builder
      - fdio:namespace=sandbox
      - fdio:image=${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: ['ubuntu2404', 'ubuntu2204', 'debian12']
        branch: [master, stable/2502, stable/2506]
        executor-arch: ['x86_64', 'aarch64']
        build_type: ${{ (inputs.build_type == 'debug' || github.event.inputs.build_type == 'debug') && fromJson('["debug"]') || (inputs.build_type == 'release' || github.event.inputs.build_type == 'release') && fromJson('["release"]') || fromJson('["debug", "release"]') }}
        exclude:
          # Exclude debian12 on aarch64 for all builds
          - os: 'debian12'
            executor-arch: 'aarch64'

          # Debug build exclusions - only keep [master, ubuntu2204, x86_64]
          # Exclude non-master branches for debug builds
          - build_type: 'debug'
            branch: 'stable/2502'
          - build_type: 'debug'
            branch: 'stable/2506'

          # Exclude non-ubuntu2204 OS for debug builds
          - build_type: 'debug'
            os: 'ubuntu2404'
          - build_type: 'debug'
            os: 'debian12'

          # Exclude aarch64 architecture for debug builds
          - build_type: 'debug'
            executor-arch: 'aarch64'
    if: >-
      (
        github.event_name == 'workflow_dispatch' ||
        github.event_name == 'workflow_call'
      )

    env:
      # VPP source directory path inside the container
      VPP_SRC_DIR: /scratch/docker-build/vpp
      # Ensures uniqueness per run
      CACHE_DATE: ${{ github.run_id }}
      STREAM: ${{ matrix.branch == 'master' && 'master' || matrix.branch == 'stable/2502' && '2502' || '2506' }}
      MAKE_PARALLEL_JOBS: ${{ inputs.make_parallel_jobs || github.event.inputs.make_parallel_jobs || '16' }}
      MAKE_TEST_OS: ${{ matrix.os == 'ubuntu2204' && 'ubuntu-22.04' || matrix.os == 'ubuntu2404' && 'ubuntu-24.04' || 'debian-12' }}
      MAKE_TEST_MULTIWORKER_OS: 'debian-12'
      VPPAPIGEN_TEST_OS: ${{ matrix.os == 'ubuntu2204' && 'ubuntu-22.04' || matrix.os == 'ubuntu2404' && 'ubuntu-24.04' || 'debian-12' }}
      OS: ${{ matrix.os }}
      EXECUTOR_ARCH: ${{ matrix.executor-arch }}
      GERRIT_BRANCH: ${{ matrix.branch }}
      BUILD_TIMEOUT: 120
      DOCKER_TEST: 1
      TEST_RETRIES: 3
      SHM_SIZE: ${{ matrix.executor-arch == 'aarch64' && '4096M' || '2048M' }}
      OS_ID: ${{ matrix.os == 'debian12' && 'debian' || 'ubuntu' }}
      OS_VERSION_ID: ${{ matrix.os == 'ubuntu2204' && '22.04' || matrix.os == 'ubuntu2404' && '24.04' || matrix.os == 'debian12' && '12' }}
      OS_ARCH: ${{ matrix.executor-arch }}
      SHOULD_RUN: ${{ matrix.branch == needs.setup-env.outputs.target_branch }}
      CCACHE_DIR: /scratch/ccache/${{ matrix.os }}-${{ matrix.executor-arch }}

    steps:
      - name: Skip non-matching branch combinations
        if: ${{ env.SHOULD_RUN == 'false' }}
        run: |
          echo "Skipping job because matrix.branch='${{ matrix.branch }}' does not match target_branch='${{ needs.setup-env.outputs.target_branch }}'."
          exit 0

      - name: Checkout code
        if: ${{ env.SHOULD_RUN == 'true' }}
        uses: actions/checkout@v4
        with:
          # Prefer explicit commit SHA if provided, else branch
          ref: ${{ inputs.commit_sha || github.event.inputs.commit_sha || inputs.branch || github.event.inputs.branch || github.ref }}
          fetch-depth: 0

      - name: Determine phase selection (Build/Test/Merge)
        if: ${{ env.SHOULD_RUN == 'true' }}
        run: |
          set -euo pipefail
          BUILD_INPUT='${{ inputs.Build || github.event.inputs.Build }}'
          TEST_INPUT='${{ inputs.Test || github.event.inputs.Test }}'
          MERGE_INPUT='${{ inputs.Merge || github.event.inputs.Merge }}'
          RUN_TEST_PHASE=true
          RUN_MERGE_PHASE=true
          # Precedence: Build > Test > Merge (if multiple true)
          if [[ "$BUILD_INPUT" == 'true' ]]; then
            RUN_TEST_PHASE=false
            RUN_MERGE_PHASE=false
            PHASE_MODE='BUILD'
          elif [[ "$TEST_INPUT" == 'true' ]]; then
            RUN_TEST_PHASE=true
            RUN_MERGE_PHASE=false
            PHASE_MODE='TEST'
          elif [[ "$MERGE_INPUT" == 'true' ]]; then
            RUN_TEST_PHASE=false
            RUN_MERGE_PHASE=true
            PHASE_MODE='MERGE'
          else
            PHASE_MODE='FULL'
          fi
          echo "RUN_TEST_PHASE=${RUN_TEST_PHASE}" >> $GITHUB_ENV
          echo "RUN_MERGE_PHASE=${RUN_MERGE_PHASE}" >> $GITHUB_ENV
          echo "PHASE_MODE=${PHASE_MODE}" >> $GITHUB_ENV
          echo "Selected phase mode: ${PHASE_MODE} (RUN_TEST_PHASE=${RUN_TEST_PHASE} RUN_MERGE_PHASE=${RUN_MERGE_PHASE})"

      - name: Prepare ccache
        if: ${{ env.SHOULD_RUN == 'true' }}
        timeout-minutes: 2
        shell: bash
        run: |
          set -euo pipefail
          if command -v ccache >/dev/null 2>&1; then
            echo "Preparing ccache directory: ${CCACHE_DIR}";
            mkdir -p "${CCACHE_DIR}" || true
            export CCACHE_DIR
            echo "ccache version: $(ccache --version | head -1)"
          else
            echo "ccache not installed in this container; skipping cache setup";
          fi

      - name: Setup executor environment
        if: ${{ env.SHOULD_RUN == 'true' }}
        timeout-minutes: 5
        run: |
          set -e
          if [ -f ".ci/scripts/vpp/setup_executor_env.sh" ]; then
            echo "Setting up executor environment..."
            chmod +x .ci/scripts/vpp/setup_executor_env.sh
            # Use 'set -e' to ensure the script failure causes step failure
            .ci/scripts/vpp/setup_executor_env.sh
            echo "Environment setup completed successfully"
          else
            echo "ERROR: Required script setup_executor_env.sh not found at .ci/scripts/vpp/setup_executor_env.sh"
            echo "Environment setup is required for merge operations"
            exit 1
          fi

      - name: Build on ${{ matrix.os }} ${{ matrix.executor-arch }}
        if: ${{ env.SHOULD_RUN == 'true' }}
        run: |
          echo "Running on ${{ matrix.os }} ${{ matrix.executor-arch }}"
          echo "BRANCH: ${{ matrix.branch }}"
          echo "TARGET_BRANCH: ${{ needs.setup-env.outputs.target_branch }}"

      - name: Display platform fingerprint
        if: ${{ env.SHOULD_RUN == 'true' }}
        timeout-minutes: 1
        run: |
          echo "Platform details:"
          uname -a
          lsb_release -a || true
          echo "Host information:"
          echo "Host IP: ${HOST_IP}"
          echo "Host Hostname: ${HOST_HOSTNAME}"

      - name: Display host resources
        if: ${{ env.SHOULD_RUN == 'true' }}
        run: |
          echo "CPU cores available:"
          nproc
          echo "Memory available:"
          free -h
          echo "Disk space:"
          df -h

      - name: Set up Docker Buildx
        if: ${{ env.SHOULD_RUN == 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker images
        if: ${{ env.SHOULD_RUN == 'true' }}
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          # Force a complete cache refresh by updating the .github/docker-version file to invalidate the cache
          key: ${{ runner.os }}-buildx-${{ matrix.os }}-${{ matrix.executor-arch }}-${{ hashFiles('.github/docker-version') }}
          restore-keys: |
            ${{ runner.os }}-buildx-${{ matrix.os }}-${{ matrix.executor-arch }}-
            ${{ runner.os }}-buildx-

      - name: Display all environment variables in the Docker Executor Container
        if: ${{ env.SHOULD_RUN == 'true' }}
        timeout-minutes: 5
        run: |
          echo "=== All Docker executor environment variables ==="
          env | sort

      - name: Integrate latest code changes with Docker Executor VPP_SRC_DIR
        if: ${{ env.SHOULD_RUN == 'true' }}
        timeout-minutes: 5
        shell: bash
        run: |
          # Synchronize files from GitHub workspace to the VPP source directory
          # This ensures that the latest code changes are available in the Docker Executor container
          if [ -d "${VPP_SRC_DIR}" ]; then
            apt-get update && apt-get install -y rsync
            # Mark the directory as safe for git operations
            git config --global --add safe.directory ${VPP_SRC_DIR}
            # Update all files that have changed into the VPP build directory
            # Exclude all git-related files and directories
            rsync -av \
              --exclude='.git/' \
              --exclude='.gitignore' \
              --exclude='.gitattributes' \
              --exclude='.gitmodules' \
              --exclude='.git_commit_template.txt' \
              --exclude='.gitreview' \
              "$GITHUB_WORKSPACE/" "${VPP_SRC_DIR}/"

            # Reset the git index to match the current state after rsync
            cd ${VPP_SRC_DIR}
            if ! git reset; then
              echo "ERROR: Git reset failed. The git repository may be corrupted."
              exit 1
            fi
          else
            echo "ERROR: Expected VPP directory ${VPP_SRC_DIR} does not exist!"
            echo "The Docker container should have this directory pre-created."
            echo "Please Check Docker Executor Container Configuration."
            exit 1
          fi

      - name: Ensure exact commit presence inside Docker Executor VPP_SRC_DIR(post-sync)
        if: ${{ env.SHOULD_RUN == 'true' }}
        timeout-minutes: 5
        shell: bash
        run: |
          set -euo pipefail
          cd ${VPP_SRC_DIR}
          TARGET_COMMIT='${{ inputs.commit_sha || github.event.inputs.commit_sha }}'
          if [ -n "$TARGET_COMMIT" ]; then
            echo "Requested commit SHA: $TARGET_COMMIT"
            # Ensure commit object exists locally
            if ! git rev-parse --verify "$TARGET_COMMIT^{commit}" >/dev/null 2>&1; then
              echo "Commit not present in container repo; fetching..."
              git fetch --no-tags origin "$TARGET_COMMIT" || git fetch --no-tags --prune origin
            fi
            echo "Checking out pinned commit..."
            git checkout --quiet "$TARGET_COMMIT"
            ACTUAL=$(git rev-parse HEAD)
            if [ "$ACTUAL" != "$TARGET_COMMIT" ]; then
              echo "ERROR: Expected commit $TARGET_COMMIT but at $ACTUAL" >&2
              exit 1
            fi
            CLEAN=$(git status --porcelain | wc -l | tr -d ' ')
            if [ "$CLEAN" != "0" ]; then
              echo "WARNING: Working tree dirty after syncing files; this may indicate local modifications relative to pinned commit." >&2
              git status --short || true
            fi
            echo "Pinned to commit $ACTUAL"
            echo "COMMIT_UNDER_TEST=$ACTUAL" >> $GITHUB_ENV
          else
            ACTUAL=$(git rev-parse HEAD || echo 'unknown')
            echo "No explicit commit_sha provided; using current HEAD $ACTUAL"
            echo "COMMIT_UNDER_TEST=$ACTUAL" >> $GITHUB_ENV
          fi
          echo "::notice title=Commit Under Test::$(git rev-parse HEAD || echo 'unknown')"

      - name: Set working directory
        if: ${{ env.SHOULD_RUN == 'true' }}
        timeout-minutes: 1
        run: |
          cd ${VPP_SRC_DIR}
          echo "Switched to repo: $(pwd)"

      - name: Remount /dev/shm for Docker
        if: ${{ env.SHOULD_RUN == 'true' }}
        timeout-minutes: 1
        run: |
          sudo mount -o remount /dev/shm -o size=${SHM_SIZE} || true

      - name: Install VPP build dependencies
        if: ${{ env.SHOULD_RUN == 'true' }}
        timeout-minutes: 30
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          make UNATTENDED=yes install-dep

      - name: Install VPP external dependencies
        if: ${{ env.SHOULD_RUN == 'true' }}
        timeout-minutes: 30
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          echo "Using optimized script: setup_vpp_ext_deps.sh for installing VPP external dependencies..."
          if [ -f ".ci/scripts/vpp/setup_vpp_ext_deps.sh" ]; then
            chmod +x .ci/scripts/vpp/setup_vpp_ext_deps.sh
            .ci/scripts/vpp/setup_vpp_ext_deps.sh
            echo "Optimized external dependency installation completed"
          fi

          # Always run the standard make target as well to ensure all dependencies are properly installed
          echo "Installing VPP external dependencies using standard make target..."
          make UNATTENDED=yes install-ext-deps
          echo "Standard external dependency installation completed"

      - name: Build static vppctl
        if: ${{ env.SHOULD_RUN == 'true' }}
        timeout-minutes: 5
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          echo "Building static vppctl"
          if [ -f extras/scripts/build_static_vppctl.sh ]; then
            extras/scripts/build_static_vppctl.sh
          else
            echo "ERROR: Required script extras/scripts/build_static_vppctl.sh not found!"
            exit 1
          fi

      - name: Install test dependencies
        if: ${{ env.SHOULD_RUN == 'true' && env.RUN_TEST_PHASE == 'true' }}
        timeout-minutes: 30
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          make UNATTENDED=yes test-dep

      - name: Build VPP (Debug)
        if: ${{ env.SHOULD_RUN == 'true' && matrix.build_type == 'debug' }}
        continue-on-error: true
        timeout-minutes: 60
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          echo "Building VPP in debug mode (non-voting)"
          make UNATTENDED=yes build

      - name: Build VPP (Release)
        if: ${{ env.SHOULD_RUN == 'true' && matrix.build_type == 'release' }}
        timeout-minutes: 60
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          echo "Building VPP in release mode"
          make UNATTENDED=yes build-release

      - name: Package verification
        if: ${{ env.SHOULD_RUN == 'true' }}
        timeout-minutes: 60
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          make UNATTENDED=yes pkg-verify

      - name: Determine test parallelism (TEST_JOBS)
        if: ${{ env.SHOULD_RUN == 'true' && env.RUN_TEST_PHASE == 'true' }}
        timeout-minutes: 2
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${MAKE_PARALLEL_JOBS}" ]; then
            echo "Setting TEST_JOBS to MAKE_PARALLEL_JOBS=${MAKE_PARALLEL_JOBS}";
            echo "TEST_JOBS=${MAKE_PARALLEL_JOBS}" >> $GITHUB_ENV
          else
            echo "MAKE_PARALLEL_JOBS not set; using auto for TEST_JOBS";
            echo "TEST_JOBS=auto" >> $GITHUB_ENV
          fi

      - name: Run vppapigen test (conditional)
        if: ${{ env.SHOULD_RUN == 'true' && env.RUN_TEST_PHASE == 'true' && contains(env.VPPAPIGEN_TEST_OS, format('{0}-{1}', env.OS_ID, env.OS_VERSION_ID)) }}
        timeout-minutes: 15
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          src/tools/vppapigen/test_vppapigen.py

      - name: Ensure test dependencies before make test
        if: ${{ env.SHOULD_RUN == 'true' && env.RUN_TEST_PHASE == 'true' }}
        timeout-minutes: 15
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          echo "Re-installing test dependencies before running make test"
          make UNATTENDED=yes test-dep

      - name: Run make test (Debug build)
        if: ${{ env.SHOULD_RUN == 'true' && env.RUN_TEST_PHASE == 'true' && contains(env.MAKE_TEST_OS, format('{0}-{1}', env.OS_ID, env.OS_VERSION_ID)) && matrix.build_type == 'debug' }}
        continue-on-error: true
        timeout-minutes: 120
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          echo "Running tests for debug build (non-voting) with TEST_JOBS=${TEST_JOBS}"
          make COMPRESS_FAILED_TEST_LOGS=yes TEST_JOBS=${TEST_JOBS} RETRIES=${TEST_RETRIES} UNATTENDED=yes FAILED_DIR=/tmp/vpp-failed-unittests test-debug

      - name: Run make test (Release build)
        if: ${{ env.SHOULD_RUN == 'true' && env.RUN_TEST_PHASE == 'true' && contains(env.MAKE_TEST_OS, format('{0}-{1}', env.OS_ID, env.OS_VERSION_ID)) && matrix.build_type == 'release' }}
        timeout-minutes: 120
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          echo "Running tests for release build with TEST_JOBS=${TEST_JOBS}"
          make COMPRESS_FAILED_TEST_LOGS=yes TEST_JOBS=${TEST_JOBS} RETRIES=${TEST_RETRIES} UNATTENDED=yes FAILED_DIR=/tmp/vpp-failed-unittests test

      - name: Run multiworker tests (Debug build)
        if: ${{ env.SHOULD_RUN == 'true' && env.RUN_TEST_PHASE == 'true' && contains(env.MAKE_TEST_MULTIWORKER_OS, format('{0}-{1}', env.OS_ID, env.OS_VERSION_ID)) && matrix.build_type == 'debug' }}
        continue-on-error: true
        timeout-minutes: 120
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          echo "Running multiworker tests for debug build (non-voting) with TEST_JOBS=${TEST_JOBS}"
          if git grep -q VPP_WORKER_CONFIG ; then
            make VPP_WORKER_CONFIG="workers 2" COMPRESS_FAILED_TEST_LOGS=yes RETRIES=${TEST_RETRIES} TEST_JOBS=${TEST_JOBS} UNATTENDED=yes FAILED_DIR=/tmp/vpp-failed-unittests-multiworker test-debug
          elif git grep -q VPP_WORKER_COUNT ; then
            make VPP_WORKER_COUNT="2" COMPRESS_FAILED_TEST_LOGS=yes RETRIES=${TEST_RETRIES} TEST_JOBS=${TEST_JOBS} UNATTENDED=yes FAILED_DIR=/tmp/vpp-failed-unittests-multiworker test-debug
          else
            echo "No worker config found, skipping multiworker test"
          fi

      - name: Run multiworker tests (Release build)
        if: ${{ env.SHOULD_RUN == 'true' && env.RUN_TEST_PHASE == 'true' && contains(env.MAKE_TEST_MULTIWORKER_OS, format('{0}-{1}', env.OS_ID, env.OS_VERSION_ID)) && matrix.build_type == 'release' }}
        timeout-minutes: 120
        shell: bash
        run: |
          set -euxo pipefail
          cd ${VPP_SRC_DIR}
          echo "Running multiworker tests for release build with TEST_JOBS=${TEST_JOBS}"
          if git grep -q VPP_WORKER_CONFIG ; then
            make VPP_WORKER_CONFIG="workers 2" COMPRESS_FAILED_TEST_LOGS=yes RETRIES=${TEST_RETRIES} TEST_JOBS=${TEST_JOBS} UNATTENDED=yes FAILED_DIR=/tmp/vpp-failed-unittests-multiworker test
          elif git grep -q VPP_WORKER_COUNT ; then
            make VPP_WORKER_COUNT="2" COMPRESS_FAILED_TEST_LOGS=yes RETRIES=${TEST_RETRIES} TEST_JOBS=${TEST_JOBS} UNATTENDED=yes FAILED_DIR=/tmp/vpp-failed-unittests-multiworker test
          else
            echo "No worker config found, skipping multiworker test"
          fi

      - name: Sanitize PCAP filenames by removing colon
        if: ${{ env.SHOULD_RUN == 'true' && env.RUN_TEST_PHASE == 'true' }}
        timeout-minutes: 15
        run: |
          cd /tmp
          echo "Sanitizing PCAP filenames in /tmp for upload"
          if ls -d ./vpp-unittest-* >/dev/null 2>&1; then
            find ./vpp-unittest-* -type f -name "*:*" 2>/dev/null | while read f; do
              echo "Renaming: $f"
              mv "$f" "$(echo $f | tr ':' '_')"
            done
            echo "Filename sanitization complete"
          else
            echo "No vpp-unittest-* directories found in /tmp, skipping PCAP filename sanitization"
          fi

      - name: Upload test results
        if: ${{ env.SHOULD_RUN == 'true' && env.RUN_TEST_PHASE == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.os }}-${{ matrix.branch }}-${{ matrix.executor-arch }}-${{ matrix.build_type }}
          path: |
            /tmp/vpp-unittest-*/
            /tmp/vpp-failed-unittests*/
          retention-days: 10

      - name: Report test success
        if: ${{ env.SHOULD_RUN == 'true' && env.RUN_TEST_PHASE == 'true' && (success() || matrix.build_type == 'debug') }}
        timeout-minutes: 1
        run: |
          # Determine if this is a PR
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_INFO="PR #${{ github.event.pull_request.number }} from ${{ github.event.pull_request.head.label }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TRIGGER_REASON="${{ github.event.inputs.reason }}"
            PR_INFO="Manual trigger: ${TRIGGER_REASON}"
          else
            PR_INFO=""
          fi

          if [[ "${{ matrix.build_type }}" == "debug" ]]; then
            echo "::notice title=Test Results::📝 Debug build tests completed (non-voting) on ${{ matrix.os }}-${{ matrix.branch }}-${{ matrix.executor-arch }}-${{ matrix.build_type }} ${PR_INFO}"
            echo "==============================================="
            echo "📝 COMPLETED: Debug build tests finished (non-voting - success/failure doesn't affect workflow status)"
          else
            echo "::notice title=Test Results::✅ All VPP tests have passed successfully on ${{ matrix.os }}-${{ matrix.branch }}-${{ matrix.executor-arch }}-${{ matrix.build_type }} ${PR_INFO}"
            echo "==============================================="
            echo "✅ SUCCESS: All VPP tests completed successfully!"
          fi
          echo "OS: ${{ matrix.os }}"
          echo "Branch: ${{ matrix.branch }}"
          echo "Architecture: ${{ matrix.executor-arch }}"
          echo "Build Type: ${{ matrix.build_type }}"
          echo "Builder Type: ${{ inputs.builder_type || github.event.inputs.builder_type || 'prod' }}"
          echo "Event: ${{ github.event_name }}${{ github.event_name == 'pull_request' && ' (PR #' || '' }}${{ github.event_name == 'pull_request' && github.event.pull_request.number || '' }}${{ github.event_name == 'pull_request' && ')' || '' }}${{ github.event_name == 'workflow_dispatch' && format(' ({0})', github.event.inputs.reason) || '' }}"
          echo "Host Runner Machine: ${HOST_HOSTNAME} (${HOST_IP})"
          echo "==============================================="

      - name: Execute merge operation
        if: ${{ env.SHOULD_RUN == 'true' && env.RUN_MERGE_PHASE == 'true' }}
        timeout-minutes: 20
        shell: bash
        run: |
          set -euo pipefail
          echo "Executing merge operation...Work in progress.."




