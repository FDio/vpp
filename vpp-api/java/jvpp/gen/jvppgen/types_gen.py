#!/usr/bin/env python
#
# Copyright (c) 2016 Cisco and/or its affiliates.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
from string import Template

import util
import jni_gen

type_template = Template("""
package $plugin_package.$type_package;

/**
 * <p>This class represents $c_type_name type definition.
 * <br>It was generated by types_gen.py based on $inputfile preparsed data:
 * <pre>
$docs
 * </pre>
 */
public final class $java_type_name {
$fields
}
""")

field_template = Template("""    public $type $name;\n""")


def generate_type_fields(type):
    """
    Generates fields for class representing typeonly definition
    :param type: python representation of typeonly definition
    :return: string representing class fields
    """
    fields = ""
    for t in zip(type['types'], type['args']):
        field_name = util.underscore_to_camelcase(t[1])
        fields += field_template.substitute(type=util.jni_2_java_type_mapping[t[0]],
                                            name=field_name)
    return fields


object_array_dto_field_setter_template = Template("""
    {
        jclass ${field_reference_name}Class = (*env)->FindClass(env, "${classFQN}");
        jobjectArray ${field_reference_name} = (*env)->NewObjectArray(env, ${field_length}, ${field_reference_name}Class, 0);
        unsigned int _i;
        for (_i = 0; _i < ${field_length}; _i++) {
            jmethodID ${field_reference_name}Constructor = (*env)->GetMethodID(env, ${field_reference_name}Class, "<init>", "()V");
            jobject ${field_reference_name}ArrayElement = (*env)->NewObject(env, ${field_reference_name}Class,  ${field_reference_name}Constructor);

            ${typeInitialization}

            (*env)->SetObjectArrayElement(env, ${field_reference_name}, _i, ${field_reference_name}ArrayElement);
        }
        (*env)->SetObjectField(env, dto, ${field_reference_name}FieldId, ${field_reference_name});
    }
""")

def generate_types(types_list, plugin_package, types_package, inputfile):
    """jvpp_c_gen
    Generates Java representation of custom types defined in api file. Allows
    :param types_list:
    :param plugin_package:
    :param types_package:
    :param inputfile:
    :return:
    """
    print "Generating custom types"

    if not os.path.exists(types_package):
        raise Exception("%s folder is missing" % types_package)

    for type in types_list:
        c_type_name = type['name']
        java_type_name = util.underscore_to_camelcase_upper(type['name'])
        dto_path = os.path.join(types_package, java_type_name + ".java")

        fields = generate_type_fields(type)

        dto_file = open(dto_path, 'w')
        dto_file.write(type_template.substitute(plugin_package=plugin_package,
                                                type_package=types_package,
                                                c_type_name=c_type_name,
                                                inputfile=inputfile,
                                                docs=util.api_message_to_javadoc(type),
                                                java_type_name=java_type_name,
                                                fields=fields
                                                ))

        # add type to jni_2_java_type_mapping:
        # todo fix vpe.api to use type_name instead of vl_api_type_name_t
        type_name = "vl_api_" + c_type_name + "_t"
        java_fqn = "%s.%s.%s" % (plugin_package, types_package, java_type_name)
        util.vpp_2_jni_type_mapping[type_name] = java_fqn
        util.jni_2_java_type_mapping[java_fqn] = java_fqn
        util.jni_2_java_type_mapping[java_fqn + "Array"] = java_fqn + "[]"
        jni_name = java_fqn.replace('.', "/")
        jni_signature = "L" + jni_name + ";"
        util.jni_2_signature_mapping[java_fqn] = "L" + jni_name + ";"
        util.jni_2_signature_mapping[java_fqn + "Array"] = "[" + jni_signature
        util.jni_field_accessors[java_fqn] = "ObjectField"
        util.jni_field_accessors[java_fqn + "Array"] = "ObjectField"
        jni_gen.dto_field_setter_templates[type_name] = Template("// FIXME SETTER !!")

        handler_name = c_type_name
        ref_name = "${field_reference_name}"
        typeInitialization = ""
        for t in zip(type['c_types'], type['types'], type['args'], type['lengths']):
            c_type = t[0]
            jni_type = t[1]
            c_name = "${c_name}[_i]." + t[2]
            java_ref_name = "${c_name}" + util.underscore_to_camelcase_upper(t[2])
            java_field_name = util.underscore_to_camelcase(t[2])
            field_length = t[3][0]
            is_variable_len_array = t[3][1]
            length_field_type = None
            object_name = "${field_reference_name}ArrayElement"
            if is_variable_len_array:
                length_field_type = type['c_types'][type['args'].index(field_length)]
            typeInitialization += jni_gen.jni_reply_handler(handler_name, ref_name, c_type, jni_type, c_name,
                                                            java_ref_name, java_field_name, field_length,
                                                            is_variable_len_array, length_field_type, object_name=object_name)

        jni_gen.dto_field_setter_templates[type_name + "[]"] = Template(
                object_array_dto_field_setter_template.substitute(
                        field_reference_name="${field_reference_name}",
                        field_length="${field_length}",
                        classFQN=jni_name,
                        typeInitialization=typeInitialization)
        )

        dto_file.flush()
        dto_file.close()

