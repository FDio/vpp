{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a19a838c_88d602d9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1698
      },
      "writtenOn": "2023-06-06T16:44:08Z",
      "side": 1,
      "message": "Hi",
      "revId": "fdcb4db02c4442a59b8c7c0204316a2f76b13d42",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8d4dc763_7092a99f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 2220
      },
      "writtenOn": "2023-06-06T18:54:36Z",
      "side": 1,
      "message": "Hello Dave,\nHello Nathan,\n\nLooks like I\u0027ve broken the `sw_interface_set_tx_placement` type while I was trying to fix `sw_interface_tx_placement_details`.\n\nHowever, with this patch applied the following code is generated for `sw_interface_tx_placement_details` auto-endian type:\n\n```\nstatic inline void vl_api_sw_interface_tx_placement_details_t_endian (vl_api_sw_interface_tx_placement_details_t *a)\n{\n    int i __attribute__((unused));\n    a-\u003e_vl_msg_id \u003d clib_net_to_host_u16(a-\u003e_vl_msg_id);\n    /* a-\u003eclient_index \u003d a-\u003eclient_index (no-op) */\n    a-\u003econtext \u003d clib_net_to_host_u32(a-\u003econtext);\n    vl_api_interface_index_t_endian(\u0026a-\u003esw_if_index);\n    a-\u003equeue_id \u003d clib_net_to_host_u32(a-\u003equeue_id);\n    /* a-\u003eshared \u003d a-\u003eshared (no-op) */\n    a-\u003earray_size \u003d clib_net_to_host_u32(a-\u003earray_size);\n    ASSERT((u32)a-\u003earray_size \u003c\u003d (u32)VL_API_MAX_ARRAY_SIZE);\n    for (i \u003d 0; i \u003c a-\u003earray_size; i++) {\n        a-\u003ethreads[i] \u003d clib_net_to_host_u32(a-\u003ethreads[i]);\n    }\n}\n```\n\nSo, it changes the endianess of the array length and then iterates from 0 to a converted value. The example of dumping the tx_placement is below.\n\n```\nDBGvpp# \nThread 1 \"vpp_main\" received signal SIGSEGV, Segmentation fault.\n0x00007ffff70ebeb1 in vl_api_sw_interface_tx_placement_details_t_endian (a\u003d0x13004c728) at CMakeFiles/vnet/interface.api.h:1684\n1684            a-\u003ethreads[i] \u003d clib_net_to_host_u32(a-\u003ethreads[i]);\n(gdb) bt\n#0  0x00007ffff70ebeb1 in vl_api_sw_interface_tx_placement_details_t_endian (a\u003d0x13004c728) at CMakeFiles/vnet/interface.api.h:1684\n#1  0x00007ffff70fc35b in send_interface_tx_placement_details (all_queues\u003d0x7fffbc917698, index\u003d0, rp\u003d0x1301cab10, native_context\u003d0) at /home/zstas/vpp/src/vnet/interface_api.c:1231\n#2  0x00007ffff70eb61f in vl_api_sw_interface_tx_placement_get_t_handler (mp\u003d0x1300980f0) at /home/zstas/vpp/src/vnet/interface_api.c:1299\n#3  0x00007ffff7f89adf in vl_mem_api_handler_with_vm_node (am\u003d0x7ffff7f7f2a8 \u003capi_global_main\u003e, vlib_rp\u003d0x130029000, the_msg\u003d0x1300980f0, vm\u003d0x7fffb6a00740, node\u003d0x7fffb792a240, is_private\u003d0 \u0027\\000\u0027) at /home/zstas/vpp/src/vlibmemory/memory_api.c:835\n#4  0x00007ffff7f894fe in void_mem_api_handle_msg_i (am\u003d0x7ffff7f7f2a8 \u003capi_global_main\u003e, vlib_rp\u003d0x130029000, vm\u003d0x7fffb6a00740, node\u003d0x7fffb792a240, is_private\u003d0 \u0027\\000\u0027) at /home/zstas/vpp/src/vlibmemory/memory_api.c:910\n#5  0x00007ffff7f89485 in vl_mem_api_handle_msg_main (vm\u003d0x7fffb6a00740, node\u003d0x7fffb792a240) at /home/zstas/vpp/src/vlibmemory/memory_api.c:921\n#6  0x00007ffff7f94d9c in vl_api_clnt_process (vm\u003d0x7fffb6a00740, node\u003d0x7fffb792a240, f\u003d0x0) at /home/zstas/vpp/src/vlibmemory/memclnt_api.c:359\n#7  0x00007ffff6f36e1d in vlib_process_bootstrap (_a\u003d140736200354744) at /home/zstas/vpp/src/vlib/main.c:1221\n#8  0x00007ffff6e58fd8 in clib_calljmp () at /home/zstas/vpp/src/vppinfra/longjmp.S:123\n#9  0x00007fffb33aabb0 in ?? ()\n#10 0x00007ffff6f368b9 in vlib_process_startup (vm\u003d0x8, p\u003d0x7ffff6f3958b \u003cdispatch_suspended_process+763\u003e, f\u003d0x7fffb33aacc0) at /home/zstas/vpp/src/vlib/main.c:1246\n#11 0x00007ffff6eb3a1c in vec_mem_size (v\u003d0x7fffb6a00740) at /home/zstas/vpp/src/vppinfra/vec.c:15\n(gdb) f 1\n#1  0x00007ffff70fc35b in send_interface_tx_placement_details (all_queues\u003d0x7fffbc917698, index\u003d0, rp\u003d0x1301cab10, native_context\u003d0) at /home/zstas/vpp/src/vnet/interface_api.c:1231\n(gdb) p/x *rmp\n$3 \u003d {_vl_msg_id \u003d 0xea02, client_index \u003d 0x0, context \u003d 0x0, sw_if_index \u003d 0x1000000, queue_id \u003d 0x0, shared \u003d 0x1, array_size \u003d 0x2000000, threads \u003d 0x13004c73f}\n```",
      "revId": "fdcb4db02c4442a59b8c7c0204316a2f76b13d42",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d42e7d28_71b9c9c6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 10
      },
      "writtenOn": "2023-06-06T19:32:33Z",
      "side": 1,
      "message": "Hmm, that means that the array_size was not converted to network order by whomever sent the message.  Where/how was the message created?",
      "parentUuid": "8d4dc763_7092a99f",
      "revId": "fdcb4db02c4442a59b8c7c0204316a2f76b13d42",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f0b2bbcc_0a492236",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 2220
      },
      "writtenOn": "2023-06-07T07:32:56Z",
      "side": 1,
      "message": "That\u0027s the tricky part.\n`sw_interface_set_tx_placement` is sent by the remote end (vapi client).\n`sw_interface_tx_placement_details` is sent set by vpp.\n\nIn the 1st case we need to change the array_size\u0027s endianness and then iterate.\nIn the 2nd case we need to iterate and then change the endianness.\n\nThe only solution which I see here is to distinguish between requests and replies (_reply, _details types) and to apply different logic.",
      "parentUuid": "d42e7d28_71b9c9c6",
      "revId": "fdcb4db02c4442a59b8c7c0204316a2f76b13d42",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bda10fed_fbff7b7c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 2220
      },
      "writtenOn": "2023-06-07T08:19:04Z",
      "side": 1,
      "message": "Okay, seems for me like a dirty hack, but at least it works. I was able to call `sw_interface_set_tx_placement` and then `sw_interface_tx_placement_details`.\n\n```\ndiff --git a/src/tools/vppapigen/vppapigen_c.py b/src/tools/vppapigen/vppapigen_c.py\nindex 26a348f39..570ebb9c5 100755\n--- a/src/tools/vppapigen/vppapigen_c.py\n+++ b/src/tools/vppapigen/vppapigen_c.py\n@@ -1250,10 +1250,12 @@ static inline void vl_api_{name}_t_endian (vl_api_{name}_t *a)\n \n         output +\u003d signature.format(name\u003dt.name)\n \n-        # make Array type appear before the others:\n+        # Only for replies:\n+        # make Array type appear before the others\n         # some arrays have dynamic length, and we want to iterate over\n         # them before changing endiann for the length field\n-        t.block.sort(key\u003dlambda x: x.type)\n+        if( t.name.endswith( \u0027_reply\u0027 ) or t.name.endswith( \u0027_details\u0027 ) ):\n+            t.block.sort(key\u003dlambda x: x.type)\n \n         for o in t.block:\n             output +\u003d endianfun_obj(o)\ndiff --git a/src/vnet/interface_api.c b/src/vnet/interface_api.c\nindex c3e78e5c7..c9403ca9e 100644\n--- a/src/vnet/interface_api.c\n+++ b/src/vnet/interface_api.c\n@@ -1214,7 +1214,7 @@ out:\n static void\n send_interface_tx_placement_details (vnet_hw_if_tx_queue_t **all_queues,\n                                     u32 index, vl_api_registration_t *rp,\n-                                    u32 native_context)\n+                                    u32 context)\n {\n   vnet_main_t *vnm \u003d vnet_get_main ();\n   vl_api_sw_interface_tx_placement_details_t *rmp;\n@@ -1223,7 +1223,6 @@ send_interface_tx_placement_details (vnet_hw_if_tx_queue_t **all_queues,\n   uword *bitmap \u003d q[0]-\u003ethreads;\n   u32 hw_if_index \u003d q[0]-\u003ehw_if_index;\n   vnet_hw_interface_t *hw_if \u003d vnet_get_hw_interface (vnm, hw_if_index);\n-  u32 context \u003d clib_host_to_net_u32 (native_context);\n \n   n_bits \u003d clib_bitmap_count_set_bits (bitmap);\n   u32 n \u003d n_bits * sizeof (u32);\n\n```",
      "parentUuid": "f0b2bbcc_0a492236",
      "revId": "fdcb4db02c4442a59b8c7c0204316a2f76b13d42",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4ed29105_18858797",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 10
      },
      "writtenOn": "2023-06-07T16:09:35Z",
      "side": 1,
      "message": "If sw_interface_tx_placement_details is sent set by vpp (i.e. the message contents are in host order), then the generated code needs to use \u0027clib_host_to_net_\u003csize\u003e\u0027 functions in addition to changing the endianness after processing the contents of the array.\n\nSo while your hack works, it is not correct and I don\u0027t think it should be merged.\n\nThe correct solution is to have \u0027to-network\u0027 autoendian code generation and \u0027to-host\u0027 autoendian code generation based on whether the api message is outbound (i.e. _reply or _details) or inbound (all the rest).  \n\nI\u0027m not a fan of parsing the message name to identify outbound messages, but adding that context to the api definition is not feasible at this point.  At the very least, the nomenclature used to identify outbound messages should be documented and/or \u0027non-reply\u0027 outbound message definitions with autoendian arrays should have a comment included with them to identify what part of the message name is being used to identify it as being an outbound message.\n\nI will work on updating this gerrit change to implement the correct solution.",
      "parentUuid": "bda10fed_fbff7b7c",
      "revId": "fdcb4db02c4442a59b8c7c0204316a2f76b13d42",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7dda77bf_f445cc92",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 2220
      },
      "writtenOn": "2023-06-07T17:09:30Z",
      "side": 1,
      "message": "Fully agreed that this is a dirty hack indeed and it shouldn\u0027t be merged. Look forward to the correct implementation and please let me know if I can assist in any way (e.g. testing). Thanks Dave!",
      "parentUuid": "4ed29105_18858797",
      "revId": "fdcb4db02c4442a59b8c7c0204316a2f76b13d42",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "62f7ae22_12dbe10e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 10
      },
      "writtenOn": "2023-06-08T20:44:32Z",
      "side": 1,
      "message": "Hopefully Patchset 3 is an acceptable solution.\n\nI will add a comment to the _reply_t_endian \u0026 _details_t_endian generated functions explaining why the all fields are reversed.  Ideally just the array_size \u0026 array fields would be swapped in the functions with variable length arrays, but doing so would have made the code generator too complicated.\n\n@Nathan, @Stanislav, please test in your environment.",
      "parentUuid": "7dda77bf_f445cc92",
      "revId": "fdcb4db02c4442a59b8c7c0204316a2f76b13d42",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    }
  ]
}