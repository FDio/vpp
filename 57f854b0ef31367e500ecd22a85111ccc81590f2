{
  "comments": [
    {
      "key": {
        "uuid": "a15b2936_c6e46414",
        "filename": "src/vnet/crypto/crypto.c",
        "patchSetId": 1
      },
      "lineNbr": 342,
      "author": {
        "id": 189
      },
      "writtenOn": "2019-09-09T10:28:37Z",
      "side": 1,
      "message": "Use indices instead of pointers as pool_get_zero() can reallocate.",
      "range": {
        "startLine": 342,
        "startChar": 5,
        "endLine": 342,
        "endChar": 25
      },
      "revId": "57f854b0ef31367e500ecd22a85111ccc81590f2",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf8721b8_71646466",
        "filename": "src/vnet/ipsec/esp_encrypt.c",
        "patchSetId": 1
      },
      "lineNbr": 238,
      "author": {
        "id": 189
      },
      "writtenOn": "2019-09-06T10:08:02Z",
      "side": 1,
      "message": "this function returns number of ops enqueued. If the return value is less than total number of ops -\u003e queues are full. I think we might want to introduce a new error counter for packets dropped due to full queues.",
      "range": {
        "startLine": 238,
        "startChar": 15,
        "endLine": 238,
        "endChar": 37
      },
      "revId": "57f854b0ef31367e500ecd22a85111ccc81590f2",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1d4d4c9a_c6cdeba1",
        "filename": "src/vnet/ipsec/esp_encrypt.c",
        "patchSetId": 1
      },
      "lineNbr": 238,
      "author": {
        "id": 1849
      },
      "writtenOn": "2019-12-23T09:06:46Z",
      "side": 1,
      "message": "Agree",
      "parentUuid": "cf8721b8_71646466",
      "range": {
        "startLine": 238,
        "startChar": 15,
        "endLine": 238,
        "endChar": 37
      },
      "revId": "57f854b0ef31367e500ecd22a85111ccc81590f2",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fd23dbd1_5fc32a87",
        "filename": "src/vnet/ipsec/esp_encrypt.c",
        "patchSetId": 1
      },
      "lineNbr": 250,
      "author": {
        "id": 189
      },
      "writtenOn": "2019-09-06T10:08:02Z",
      "side": 1,
      "message": "This is incorrect. vnet_crypto_submit_ops() only submits ops to the crypto infra, so there is no guarantee that the ops were completed by now.",
      "range": {
        "startLine": 250,
        "startChar": 10,
        "endLine": 250,
        "endChar": 55
      },
      "revId": "57f854b0ef31367e500ecd22a85111ccc81590f2",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da55011b_3f7c29bf",
        "filename": "src/vnet/ipsec/esp_encrypt.c",
        "patchSetId": 1
      },
      "lineNbr": 250,
      "author": {
        "id": 1849
      },
      "writtenOn": "2019-09-06T14:13:44Z",
      "side": 1,
      "message": "It is incorrect but not where you pointed...\n\nBasically when an array of crypto ops are pushed into the queue(s), the reason not all ops are enqueued are due to either queue creation fail, or queue is full. In case the former the all ops should be freed (n_failed \u003d\u003d n), in case of the latter we don\u0027t have to scan what has been enqueued already, but simply drop all those are not enqueued.\n\nSo what I was wrong here is change the whole block here like:\n\nu32 i;\nfor ( i \u003d n - n_failed; i \u003c n; i ++)\n{\n  op \u003d ops + i;\n  u32 bi \u003d ops-\u003euser_data;\n  b0-\u003eerror \u003d node-\u003eerrors[ESP_ENCRYPT_ERROR_CRYPTO_ENGINE_ERROR];\n  nexts[bi] \u003d ESP_ENCRYPT_NEXT_DROP;\n  clib_mem_free (op)\n}",
      "parentUuid": "fd23dbd1_5fc32a87",
      "range": {
        "startLine": 250,
        "startChar": 10,
        "endLine": 250,
        "endChar": 55
      },
      "revId": "57f854b0ef31367e500ecd22a85111ccc81590f2",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "618defab_9fbbfdc4",
        "filename": "src/vnet/ipsec/esp_encrypt.c",
        "patchSetId": 1
      },
      "lineNbr": 250,
      "author": {
        "id": 189
      },
      "writtenOn": "2019-09-06T14:49:58Z",
      "side": 1,
      "message": "in this case i would define more appropriate name for the error counter, like QUEUE_FULL instead of the generic ENGINE_ERROR.\n\nAlso you have to call vlib_buffer_enqueue_to_next for the failed buffers otherwise they will leak.",
      "parentUuid": "da55011b_3f7c29bf",
      "range": {
        "startLine": 250,
        "startChar": 10,
        "endLine": 250,
        "endChar": 55
      },
      "revId": "57f854b0ef31367e500ecd22a85111ccc81590f2",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f2618f1c_0741f515",
        "filename": "src/vnet/ipsec/esp_encrypt.c",
        "patchSetId": 1
      },
      "lineNbr": 297,
      "author": {
        "id": 189
      },
      "writtenOn": "2019-09-06T12:02:35Z",
      "side": 1,
      "message": "this can leak if a buffer is dropped (line 366)",
      "range": {
        "startLine": 297,
        "startChar": 1,
        "endLine": 297,
        "endChar": 10
      },
      "revId": "57f854b0ef31367e500ecd22a85111ccc81590f2",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "91c52312_ca56b12c",
        "filename": "src/vnet/ipsec/esp_encrypt.c",
        "patchSetId": 1
      },
      "lineNbr": 297,
      "author": {
        "id": 1849
      },
      "writtenOn": "2019-09-06T14:13:44Z",
      "side": 1,
      "message": "Hi, you are right. Will allocate async_ops at run time.",
      "parentUuid": "f2618f1c_0741f515",
      "range": {
        "startLine": 297,
        "startChar": 1,
        "endLine": 297,
        "endChar": 10
      },
      "revId": "57f854b0ef31367e500ecd22a85111ccc81590f2",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    }
  ]
}