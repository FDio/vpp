{
  "comments": [
    {
      "key": {
        "uuid": "e327aae6_34e24177",
        "filename": "src/vnet/gso/gro_func.h",
        "patchSetId": 31
      },
      "lineNbr": 125,
      "author": {
        "id": 361
      },
      "writtenOn": "2020-06-12T14:38:15Z",
      "side": 1,
      "message": "I really thing this is wrong: if we receive an out-of-order segment (be it a retransmit or a future one), we should flush everything including and forget the flow. Otherwise we might delay network events (eg. packet loss) detection by the receiver.\nWe should have only 2 cases: buffer if it is exactly the segment we expect, or flush everything and forget the flow.\nDid you check with Florin?",
      "revId": "17397d1511d5413f14f42338fb963506f91e0fb9",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d2aef27_94165fd1",
        "filename": "src/vnet/gso/gro_func.h",
        "patchSetId": 31
      },
      "lineNbr": 125,
      "author": {
        "id": 241
      },
      "writtenOn": "2020-06-12T15:56:50Z",
      "side": 1,
      "message": "I am handling three different scenarios here:\n1) packet has the right sequence number as expected. Enqueue it to merge into bigger packet.\n2) Retransmitted packets usually have sequence number lesser than sequence number of buffered TCP packet. We retransmit such packet immediately. But keep the current buffered packet to continue the coalescing.\n3) From my experimentation, what I have seen is, from times to times, source sends TCP packets with PUSH flag. We don\u0027t buffer TCP packets with PUSH flag for coalescing. It causes gaps between sequence number of buffered TCP packet and sequence number of next packet without PUSH flag. In that case, we send the buffered packet and store the new packet for speculative reasons, as most of the times, next packet has expected sequence number and merge in case (1).\n\nStore buffers are flushed in any case within 10 microseconds.",
      "parentUuid": "e327aae6_34e24177",
      "revId": "17397d1511d5413f14f42338fb963506f91e0fb9",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce9a0516_33453104",
        "filename": "src/vnet/gso/gro_func.h",
        "patchSetId": 31
      },
      "lineNbr": 125,
      "author": {
        "id": 361
      },
      "writtenOn": "2020-06-12T16:14:37Z",
      "side": 1,
      "message": "Ok I understand better the rationale, but I still see that as risky.\nAlso, are you not flushing all packets on PUSH? If you do not flush, could the receiver detect packet loss when there are none?\nI\u0027d really like Florin to comment on this.",
      "parentUuid": "6d2aef27_94165fd1",
      "revId": "17397d1511d5413f14f42338fb963506f91e0fb9",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2709bcb3_877d73bc",
        "filename": "src/vnet/gso/gro_func.h",
        "patchSetId": 31
      },
      "lineNbr": 125,
      "author": {
        "id": 241
      },
      "writtenOn": "2020-06-12T16:37:05Z",
      "side": 1,
      "message": "GRO function does not parse the flow and sequence number of TCP packets with all flags except ACKs. The flag check is quite early in GRO code to minimize the cost for such packets. These packets are sent immediately.",
      "parentUuid": "ce9a0516_33453104",
      "revId": "17397d1511d5413f14f42338fb963506f91e0fb9",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ce585ed_31d04534",
        "filename": "src/vnet/gso/gro_func.h",
        "patchSetId": 31
      },
      "lineNbr": 125,
      "author": {
        "id": 193
      },
      "writtenOn": "2020-06-12T19:25:27Z",
      "side": 1,
      "message": "Hi guys! I agree with Ben\u0027s point that we should flush whenever out-of-order data is received because otherwise we\u0027ll be hiding loss and packet reordering feedback that should go back to the sender. That is, each out-of-order packet should elicit a dup-ack from the receiver which subsequently forces the congestion control algorithm on the sender to adapt to the network.  \n\nNow, the effect of that depends a lot on the scenario. I guess that worst case would be when a bottleneck queue/link starts reordering when it\u0027s close to full and the lack of feedback makes the sender completely overwhelm it. \n\nNot sure I would rely on rule mentioned in point 2) above. If the sender entered fast recovery, based on sack feedback, it could retransmit a lot of non-contiguous segments in an incremental fashion, i.e., from snd_una to snd_nxt. Those would just look like gaps to gro and should be delivered on the spot with anything else that\u0027s outstanding (acks help the sender cleanup its retransmit queue faster). \n\nTo make a long story short, probably I\u0027d deliver everything with a seq number \u003c max seq number seen on the connection on the spot. Since you don\u0027t track the max seq, I guess the next best thing would be to just deliver and flush the packet when something out-of-order is received. \n\nIn case you tested already, did you see a drop in throughput? That is, if some networks are known to misbehave and induce a lot of reordering, probably something like this would improve performance. But I don\u0027t know if we should be optimizing for them.",
      "parentUuid": "2709bcb3_877d73bc",
      "revId": "17397d1511d5413f14f42338fb963506f91e0fb9",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d163a556_af39ea32",
        "filename": "src/vnet/pg/input.c",
        "patchSetId": 31
      },
      "lineNbr": 1595,
      "author": {
        "id": 361
      },
      "writtenOn": "2020-06-12T14:38:15Z",
      "side": 1,
      "message": "This looks like a completely unrelated bugfix? If so please use a separate patch, otherwise it makes backports hard",
      "revId": "17397d1511d5413f14f42338fb963506f91e0fb9",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62ced413_f9de2b9f",
        "filename": "src/vnet/pg/input.c",
        "patchSetId": 31
      },
      "lineNbr": 1595,
      "author": {
        "id": 241
      },
      "writtenOn": "2020-06-12T15:56:50Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d163a556_af39ea32",
      "revId": "17397d1511d5413f14f42338fb963506f91e0fb9",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f96b608a_2adc9a5a",
        "filename": "src/vnet/pg/input.c",
        "patchSetId": 31
      },
      "lineNbr": 1595,
      "author": {
        "id": 361
      },
      "writtenOn": "2020-06-12T16:14:37Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "62ced413_f9de2b9f",
      "revId": "17397d1511d5413f14f42338fb963506f91e0fb9",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    }
  ]
}