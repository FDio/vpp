{
  "comments": [
    {
      "key": {
        "uuid": "2c3ca720_fce694b0",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_api.c",
        "patchSetId": 7
      },
      "lineNbr": 1813,
      "author": {
        "id": 1961
      },
      "writtenOn": "2022-01-13T12:05:52Z",
      "side": 1,
      "message": "This check is not inline with nat44_session_get_timeout(), I think it would be easier to just call that function from here.",
      "revId": "b39ab9f67f10b0aae32dd2b52be2b5e1045b687b",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71b25c2e_fd62dafe",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_api.c",
        "patchSetId": 7
      },
      "lineNbr": 1813,
      "author": {
        "id": 601
      },
      "writtenOn": "2022-01-13T16:16:05Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2c3ca720_fce694b0",
      "revId": "b39ab9f67f10b0aae32dd2b52be2b5e1045b687b",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6770c65f_85c94f72",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_format.c",
        "patchSetId": 7
      },
      "lineNbr": 91,
      "author": {
        "id": 1961
      },
      "writtenOn": "2022-01-13T12:05:52Z",
      "side": 1,
      "message": "Shouldn\u0027t this be\nnat44_session_get_timeout (sm, sess) - (now -  sess-\u003elast_heard) ?",
      "revId": "b39ab9f67f10b0aae32dd2b52be2b5e1045b687b",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c64e9a11_da5152a5",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_format.c",
        "patchSetId": 7
      },
      "lineNbr": 91,
      "author": {
        "id": 601
      },
      "writtenOn": "2022-01-13T16:16:05Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6770c65f_85c94f72",
      "revId": "b39ab9f67f10b0aae32dd2b52be2b5e1045b687b",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "72920eed_03fd134b",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_inlines.h",
        "patchSetId": 7
      },
      "lineNbr": 781,
      "author": {
        "id": 1961
      },
      "writtenOn": "2022-01-13T12:05:52Z",
      "side": 1,
      "message": "Suppose one side restarts while the session is in ESTABLISHED state and later the other side sends a FIN, the state is set to FIN_I2O or FIN_O2I. The FIN will be re-transmitted, then the following 2 cases can happen:\n - An RST is sent to abandon the connection, as required by the standard as far as I know.\n   The RST is not handled in these states, the session is left hanging for the established timeout.\n - There is no RST sent, simply the FIN is given up. This is what I could observe is some of our traces.\n   Similarly, the session is left in the current state for the established timeout. This is RFC compliant as you have previously pointed out, it is just not very optimal.\n\nIt is also not possible to reopen the session in the above scenarios and this can be a real issue because these FIN_I2O/O2I states can take very long when the RST does not arrive. In the second case, neither sides have the connection anymore, the server will not answer the SYN with an RST.",
      "revId": "b39ab9f67f10b0aae32dd2b52be2b5e1045b687b",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "db4e4793_b8e2d8c8",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_inlines.h",
        "patchSetId": 7
      },
      "lineNbr": 781,
      "author": {
        "id": 601
      },
      "writtenOn": "2022-01-13T16:16:05Z",
      "side": 1,
      "message": "Yes, that is correct.\n\nI am not sure what RFC compliant solution is available here.\n\nBut in your case, if the client is dead, it can simply try a different port (as it should IIRC port randomisation is a SHOULD)",
      "parentUuid": "72920eed_03fd134b",
      "revId": "b39ab9f67f10b0aae32dd2b52be2b5e1045b687b",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58cc36e8_626e2083",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_inlines.h",
        "patchSetId": 7
      },
      "lineNbr": 781,
      "author": {
        "id": 1961
      },
      "writtenOn": "2022-01-13T17:56:52Z",
      "side": 1,
      "message": "Okey, this state machine from RFC 7857/6146 is pretty permissive and it is in favor of keeping the established session, even if the two sides can obviously no longer communicate. Like in case 1 above, when the server is RFC compliant:\n\nclient - server\n       ...\n       \u003c- FIN\n       \u003c- FIN\n       \u003c- FIN\n       ...\n       \u003c- RST\n\nThe RST could be handled in the FIN_I2O/O2I states I think. This state transition is not mentioned after the diagram in RFC 6146, but suggested before that:\n\n      TRANS: The lifetime of the state for the connection is set to\n      TCP_TRANS minutes either because a packet containing a TCP RST was\n      received by the NAT64 for this connection or simply because the\n      lifetime of the connection has decreased and there are only\n      TCP_TRANS minutes left. \n\nAnd in RFC 7857:\n   Update:  This document adopts a similar default behavior as in\n      [RFC6146].  Concretely, when the NAT receives a TCP RST matching\n      an existing mapping, it MUST translate the packet according to the\n      NAT mapping entry.  Moreover, the NAT SHOULD wait for 4 minutes\n      before deleting the session and removing any state associated with\n      it if no packets are received during that 4-minute timeout.\n\n\nAnyway, keeping the established state could help if there was only a temporary network outage and the client will try to still send some packet that the server will answer with an RST subsequently. To conserve sessions, a faster cleanup with the same result could happen if VPP sent back the RST in closed state by itself, which was an optional NAT behavior in RFC 5382. -- We could contribute a separate patch later, if you think this is of general interest.",
      "parentUuid": "db4e4793_b8e2d8c8",
      "revId": "b39ab9f67f10b0aae32dd2b52be2b5e1045b687b",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ae549061_f736d82a",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_inlines.h",
        "patchSetId": 7
      },
      "lineNbr": 781,
      "author": {
        "id": 601
      },
      "writtenOn": "2022-01-13T19:34:53Z",
      "side": 1,
      "message": "I\u0027ll leave it as it is for now. Let\u0027s not complicate things further at this step. Feel free to submit a patch with your suggested RST/transitory timeout changes. I would also bring this up on vpp-dev mailing list as this is a limited channel ...\n\nOne more option in a deployment is a custom configuration of an established timeout value - that would of course depend on knowing your environment, but if tearing down long lived sessions with occasional traffic is not an issue, then setting it to a lower value might be an option.\n\nRegarding VPP sending RST by itself, feel free to submit a patch. It would require writing a new node though, which would had to have a timer wheel to keep track of sessions to keep alive and if there are lots and lots of them, that could be a bit resource intensive. Such a timer wheel is implemented in BFD code. Another complication is that reading session data is currently possible only by owner thread as there are no locks (and I\u0027m pretty sure we don\u0027t want to introduce any), so the code would have to deal with that somehow.",
      "parentUuid": "58cc36e8_626e2083",
      "revId": "b39ab9f67f10b0aae32dd2b52be2b5e1045b687b",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    }
  ]
}