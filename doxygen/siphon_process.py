#!/usr/bin/env python
# Copyright (c) 2016 Comcast Cable Communications Management, LLC.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Filter for .siphon files that are generated by other filters.
# The idea is to siphon off certain initializers so that we can better
# auto-document the contents of that initializer.

import os, sys, re, argparse, cgi, json
import pyparsing as pp

DEFAULT_SIPHON ="clicmd"
DEFAULT_OUTPUT = None
DEFAULT_PREFIX = os.getcwd()

siphon_map = {
    'clicmd': "VLIB_CLI_COMMAND",
}

ap = argparse.ArgumentParser()
ap.add_argument("--type", '-t', metavar="siphon_type", default=DEFAULT_SIPHON,
        choices=siphon_map.keys(),
        help="Siphon type to process [%s]" % DEFAULT_SIPHON)
ap.add_argument("--output", '-o', metavar="directory", default=DEFAULT_OUTPUT,
        help="Output directory for .md files [%s]" % DEFAULT_OUTPUT)
ap.add_argument("--input-prefix", metavar="path", default=DEFAULT_PREFIX,
        help="Prefix to strip from input pathnames [%s]" % DEFAULT_PREFIX)
ap.add_argument("input", nargs='+', metavar="input_file",
        help="Input .siphon files")
args = ap.parse_args()

if args.output is None:
    sys.stderr.write("Error: Siphon processor requires --output to be set.")
    sys.exit(1)


# PyParsing definition for our struct initializers which look like this:
# VLIB_CLI_COMMAND (show_sr_tunnel_command, static) = {
#    .path = "show sr tunnel",
#    .short_help = "show sr tunnel [name <sr-tunnel-name>]",
#    .function = show_sr_tunnel_fn,
#};

def clicmd_index_header(cfg):
    s = "# CLI command index\n"
    s += "\n[TOC]\n"
    return s

def clicmd_index_section(cfg, directory, md):
    # TODO: need a better directory-to-description mechanism
    return "\n@subpage %s\n\n" % md
    #return "\n## [%s](@ref %s)\n\n" % (directory, md)

def clicmd_index_entry(cfg, meta, item):
    v = item["value"]
    return "* [%s](@ref %s)\n" % (v["path"], meta["label"])

def clicmd_header(cfg, directory, md):
    return "@page %s %s\n" % (md, directory)

def clicmd_format(cfg, meta, item):
    v = item["value"]
    s = "@section %s %s\n" % (meta['label'], v['path'])
    #s += "\n## %s {#%s}\n\n" % (v["path"], meta["label"])

    if "short_help" in v:
        s += "### Short help\n    %s\n\n" % v["short_help"]

    if "long_help" in v:
        s += "### Long help\n    %s\n\n" % v["long_help"]

    if "siphon_block" in item["meta"]:
        sb = item["meta"]["siphon_block"]
        if sb != "":
            # hack
            sb = sb.replace("\n", "\\n") 
            try:
                sb = json.loads('"'+sb+'"')
                s += "### Long help\n%s\n" % sb
            except:
                pass

    if "item" in meta:
        s += "### Declaration\nFile `%s` line %d, @ref %s\n\n" % \
            (meta["file"], int(item["meta"]["line_start"]), meta["item"])

    if "function" in v:
        s += "### Implementation\n@ref %s\n\n" % v["function"]

    return s


siphons = {
    "VLIB_CLI_COMMAND": {
        "index_header": clicmd_index_header,
        "index_section": clicmd_index_section,
        "index_entry": clicmd_index_entry,
        "header": clicmd_header,
        "format": clicmd_format,
    }
}


def getMacroInitializerBNF():
    cs = pp.Forward()
    ident = pp.Word(pp.alphas + "_", pp.alphas + pp.nums + "_")
    intNum = pp.Word(pp.nums)
    hexNum = pp.Literal("0x") + pp.Word(pp.hexnums)
    octalNum = pp.Literal("0") + pp.Word("01234567")
    integer = (hexNum | octalNum | intNum) + \
        pp.Optional(pp.Literal("ULL") | pp.Literal("LL") | pp.Literal("L"))
    floatNum = pp.Regex(r'\d+(\.\d*)?([eE]\d+)?') + pp.Optional(pp.Literal("f"))
    char = pp.Literal("'") + pp.Word(pp.printables, exact=1) + pp.Literal("'")
    arrayIndex = integer | ident

    lbracket = pp.Literal("(").suppress()
    rbracket = pp.Literal(")").suppress()
    lbrace = pp.Literal("{").suppress()
    rbrace = pp.Literal("}").suppress()
    comma = pp.Literal(",").suppress()
    equals = pp.Literal("=").suppress()
    dot = pp.Literal(".").suppress()
    semicolon = pp.Literal(";").suppress()

    # initializer := { [member = ] (variable | expression | { initializer } ) }
    typeName = ident
    varName = ident

    typeSpec = pp.Optional("unsigned") + \
               pp.oneOf("int long short float double char u8 i8 void") + \
               pp.Optional(pp.Word("*"), default="")
    typeCast = pp.Combine( "(" + ( typeSpec | typeName ) + ")" ).suppress()

    string = pp.Combine(pp.OneOrMore(pp.QuotedString(quoteChar='"',
        escChar='\\', multiline=True)), adjacent=False)
    literal = pp.Optional(typeCast) + (integer | floatNum | char | string)
    var = pp.Combine(pp.Optional(typeCast) + varName + pp.Optional("[" + arrayIndex + "]"))

    expr = (literal | var) # TODO


    member = pp.Combine(dot + varName + pp.Optional("[" + arrayIndex + "]"))
    value = (expr | cs)

    entry = pp.Group(pp.Optional(member + equals, default="") + value)
    entries = (pp.ZeroOrMore(entry + comma) + entry + pp.Optional(comma)) | \
              (pp.ZeroOrMore(entry + comma))

    cs << (lbrace + entries + rbrace)

    macroName = ident
    params = pp.Group(pp.ZeroOrMore(expr + comma) + expr)
    macroParams = lbracket + params + rbracket

    mi = macroName + pp.Optional(macroParams) + equals + pp.Group(cs) + semicolon

    metaitem = pp.Group(ident + equals + (string | integer) + semicolon)
    meta = pp.OneOrMore(metaitem)
    me = pp.Group(meta) + mi

    me.ignore(pp.cppStyleComment)

    return me


def process_block(mi, block):
    block = block.replace("\\n", "\n") # this is a hack until we can install a newer pyparsing
    o = mi.parseString(block).asList()

    r = {
        "id": o[1],
        "params": o[2],
        "value": {},
        "meta": {}
    }

    for i in o[0]:
        r["meta"][i[0]] = i[1]
    for i in o[3]:
        r["value"][i[0]] = cgi.escape(i[1])

    if "file" in r["meta"]:
        label = r["meta"]["file"]
    else:
        return None

    return (label, r["id"], r["params"][0], r)


mi = getMacroInitializerBNF()

cmds = {}

# Parse the input file into a more usable dictionary structure
line_num = 0
line_start = 0
for filename in args.input:
    sys.stderr.write("Parsing items in file \"%s\"...\n" % filename)
    with open(filename, "r") as fd:
        # group into sections of text delimited by "=%=%=\n"

        block = ""
        for line in fd:
            line_num += 1

            if line == "=%=%=\n":
                rt = None
                try:
                    rt = process_block(mi, block)
                except:
                    sys.stderr.write("Failed to parse block at line %d of %s.\n" % \
                        (line_start, filename))
                    raise

                if rt is not None:
                    file = rt[0]
                    directory = os.path.dirname(file)

                    if directory[0:2] == "./":
                        directory = directory[2:]
                    elif directory[0:len(args.input_prefix)] == args.input_prefix:
                        directory = directory[len(args.input_prefix):]
                        if directory[0] == "/":
                            directory = directory[1:]

                    if directory not in cmds:
                        cmds[directory] = {}

                    if file not in cmds[directory]:
                        cmds[directory][file] = {}

                    macro = rt[1]
                    if macro not in cmds[directory][file]:
                        cmds[directory][file][macro] = {}

                    param = rt[2]

                    cmds[directory][file][macro][param] = rt[3]

                block = ""
            else:
                if block == "":
                    line_start = line_num
                block += line

# Write the header for this siphon type
cfg = siphons[siphon_map[args.type]]
sys.stdout.write(cfg["index_header"](cfg))
contents = ""

# Iterate the dictionary and process it
for directory in sorted(cmds.keys()):
    sys.stderr.write("Processing items in directory \"%s\"...\n" % directory)

    cfg = siphons[siphon_map[args.type]]
    md = directory.replace("/", "_")
    sys.stdout.write(cfg["index_section"](cfg, directory, md))

    if "header" in cfg:
        contents += cfg["header"](cfg, directory, md)

    for file in sorted(cmds[directory].keys()):
        sys.stderr.write("- Processing items in file \"%s\"...\n" % file)
        for macro in sorted(cmds[directory][file].keys()):
            if macro != siphon_map[args.type]:
                continue
            sys.stderr.write("-- Processing items in macro \"%s\"...\n" % macro)
            cfg = siphons[macro]

            meta = {
                "directory": directory,
                "file": file,
                "macro": macro,
                "md": md,
            }

            for param in sorted(cmds[directory][file][macro].keys()):
                sys.stderr.write("--- Processing item \"%s\"...\n" % param)

                meta["item"] = param

                # mangle "md" and the item to make a reference label
                meta["label"] = "%s___%s" % (meta["md"], param)

                if "index_entry" in cfg:
                    s = cfg["index_entry"](cfg, meta, cmds[directory][file][macro][param])
                    sys.stdout.write(s)

                if "format" in cfg:
                    contents += cfg["format"](cfg, meta, cmds[directory][file][macro][param])

sys.stdout.write(contents)

# All done
