diff --git a/include/quicly.h b/include/quicly.h
index 9b1c313..3158d6e 100644
--- a/include/quicly.h
+++ b/include/quicly.h
@@ -61,6 +61,12 @@ typedef union st_quicly_address_t {
     struct sockaddr_in6 sin6;
 } quicly_address_t;
 
+#define QUICLY_MAX_PN_SIZE 4  /* maximum defined by the RFC used for calculating header protection sampling offset */
+#define QUICLY_SEND_PN_SIZE 2 /* size of PN used for sending */
+
+#define QUICLY_KEY_PHASE_BIT 0x4
+
+
 typedef struct st_quicly_datagram_t {
     ptls_iovec_t data;
     quicly_address_t dest, src;
@@ -73,6 +79,10 @@ typedef struct st_quicly_conn_t quicly_conn_t;
 typedef struct st_quicly_stream_t quicly_stream_t;
 typedef struct st_quicly_send_context_t quicly_send_context_t;
 typedef struct st_quicly_address_token_plaintext_t quicly_address_token_plaintext_t;
+typedef struct st_quicly_receive_context_t quicly_receive_context_t;
+typedef struct st_quicly_decoded_packet_t quicly_decoded_packet_t;
+typedef struct st_quicly_pn_space_t quicly_pn_space_t; 
+
 
 #define QUICLY_CALLBACK_TYPE0(ret, name)                                                                                           \
     typedef struct st_quicly_##name##_t {                                                                                          \
@@ -92,6 +102,17 @@ typedef struct st_quicly_packet_allocator_t {
     void (*free_packet)(struct st_quicly_packet_allocator_t *self, quicly_datagram_t *packet);
 } quicly_packet_allocator_t;
 
+typedef struct st_quicly_crypto_codec_t {
+    size_t (*encrypt_packet)(struct st_quicly_crypto_codec_t *self, ptls_aead_context_t *aead, ptls_cipher_context_t *header_protection,
+                             uint8_t *dst, uint8_t *dst_payload_from, uint8_t *first_byte_at, uint64_t packet_number);
+    void (*encrypt_packet_done)(ptls_cipher_context_t *header_protection, uint8_t *first_byte_at, uint8_t *dst_payload_from);
+    int (*decrypt_packet)(struct st_quicly_crypto_codec_t *self, quicly_conn_t *conn, struct sockaddr *dest_addr, struct sockaddr *src_addr, quicly_pn_space_t *space,
+                             ptls_cipher_context_t *header_protection, ptls_aead_context_t **aead, size_t epoch,
+                             uint64_t *next_expected_pn, quicly_decoded_packet_t *packet);
+    int (*decrypt_packet_done)(quicly_conn_t *conn, struct sockaddr *dest_addr, struct sockaddr *src_addr, quicly_decoded_packet_t *packet, 
+                                quicly_pn_space_t *space, size_t epoch, uint64_t pn, size_t aead_off, size_t ptlen);
+} quicly_crypto_codec_t;
+
 /**
  * CID encryption
  */
@@ -292,6 +313,10 @@ struct st_quicly_context_t {
      *
      */
     quicly_generate_resumption_token_t *generate_resumption_token;
+    /**
+     * quicly crypto codec
+     */
+    quicly_crypto_codec_t *crypto_codec;
 };
 
 /**
@@ -300,7 +325,7 @@ struct st_quicly_context_t {
 typedef enum {
     /**
      * before observing the first message from peer
-     */
+     */ 
     QUICLY_STATE_FIRSTFLIGHT,
     /**
      * while connected
@@ -552,7 +577,7 @@ struct st_quicly_stream_t {
     } _recv_aux;
 };
 
-typedef struct st_quicly_decoded_packet_t {
+struct st_quicly_decoded_packet_t {
     /**
      * octets of the entire packet
      */
@@ -608,7 +633,26 @@ typedef struct st_quicly_decoded_packet_t {
         QUICLY__DECODED_PACKET_CACHED_IS_STATELESS_RESET,
         QUICLY__DECODED_PACKET_CACHED_NOT_STATELESS_RESET
     } _is_stateless_reset_cached;
-} quicly_decoded_packet_t;
+};
+
+struct st_quicly_pn_space_t {
+    /**
+     * acks to be sent to peer
+     */
+    quicly_ranges_t ack_queue;
+    /**
+     * time at when the largest pn in the ack_queue has been received (or INT64_MAX if none)
+     */
+    int64_t largest_pn_received_at;
+    /**
+     *
+     */
+    uint64_t next_expected_packet_number;
+    /**
+     * packet count before ack is sent
+     */
+    uint32_t unacked_count;
+};
 
 struct st_quicly_address_token_plaintext_t {
     int is_retry;
diff --git a/include/quicly/defaults.h b/include/quicly/defaults.h
index 49984ea..f83be1b 100644
--- a/include/quicly/defaults.h
+++ b/include/quicly/defaults.h
@@ -44,6 +44,8 @@ extern quicly_packet_allocator_t quicly_default_packet_allocator;
 quicly_cid_encryptor_t *quicly_new_default_cid_encryptor(ptls_cipher_algorithm_t *cid_cipher,
                                                          ptls_cipher_algorithm_t *reset_token_cipher, ptls_hash_algorithm_t *hash,
                                                          ptls_iovec_t key);
+
+quicly_crypto_codec_t *quicly_new_default_crypto_codec();
 /**
  *
  */
diff --git a/lib/defaults.c b/lib/defaults.c
index 956764b..692b65c 100644
--- a/lib/defaults.c
+++ b/lib/defaults.c
@@ -246,6 +246,100 @@ void quicly_free_default_cid_encryptor(quicly_cid_encryptor_t *_self)
     free(self);
 }
 
+struct st_quicly_default_crypto_codec_t {
+    quicly_crypto_codec_t super;
+};
+
+static size_t quicly_default_crypto_codec_packet_encrypt(quicly_crypto_codec_t *_self, ptls_aead_context_t *aead,
+                                                  ptls_cipher_context_t *header_protection, uint8_t *dst, uint8_t *dst_payload_from,
+                                                  uint8_t *first_byte_at, uint64_t packet_number)
+{
+    int ret = ptls_aead_encrypt(aead, dst_payload_from, dst_payload_from, dst - dst_payload_from, packet_number, first_byte_at,
+                                dst_payload_from - first_byte_at);
+
+    { /* apply header protection */
+        _self->encrypt_packet_done(header_protection, first_byte_at, dst_payload_from);
+    }
+    return ret;
+}
+
+static void quicly_default_crypto_codec_packet_encrypt_done(ptls_cipher_context_t *header_protection, uint8_t *first_byte_at, uint8_t *dst_payload_from)
+{
+    uint8_t hpmask[1 + QUICLY_SEND_PN_SIZE] = {0};
+    ptls_cipher_init(header_protection, dst_payload_from - QUICLY_SEND_PN_SIZE + QUICLY_MAX_PN_SIZE);
+    ptls_cipher_encrypt(header_protection, hpmask, hpmask, sizeof(hpmask));
+
+    *first_byte_at ^= hpmask[0] & (QUICLY_PACKET_IS_LONG_HEADER(*first_byte_at) ? 0xf : 0x1f);
+    size_t i;
+    for (i = 0; i != QUICLY_SEND_PN_SIZE; ++i)
+        dst_payload_from[i - QUICLY_SEND_PN_SIZE] ^= hpmask[i + 1];
+}
+
+static int quicly_default_crypto_codec_packet_decrypt(quicly_crypto_codec_t *_self, quicly_conn_t *conn, struct sockaddr *dest_addr, struct sockaddr *src_addr, quicly_pn_space_t *space,
+                                               ptls_cipher_context_t *header_protection, ptls_aead_context_t **aead, size_t epoch,
+                                               uint64_t *next_expected_pn, quicly_decoded_packet_t *packet)
+{
+    size_t encrypted_len = packet->octets.len - packet->encrypted_off;
+    uint8_t hpmask[5] = {0};
+    uint32_t pnbits = 0;
+    size_t pnlen, aead_index, i;
+    size_t ptlen;
+    uint64_t pn;
+
+    struct st_quicly_default_crypto_codec_t *self = (void *)_self;
+
+    /* decipher the header protection, as well as obtaining pnbits, pnlen */
+    if (encrypted_len < header_protection->algo->iv_size + QUICLY_MAX_PN_SIZE)
+        goto Error;
+    ptls_cipher_init(header_protection, packet->octets.base + packet->encrypted_off + QUICLY_MAX_PN_SIZE);
+    ptls_cipher_encrypt(header_protection, hpmask, hpmask, sizeof(hpmask));
+    packet->octets.base[0] ^= hpmask[0] & (QUICLY_PACKET_IS_LONG_HEADER(packet->octets.base[0]) ? 0xf : 0x1f);
+    pnlen = (packet->octets.base[0] & 0x3) + 1;
+    for (i = 0; i != pnlen; ++i) {
+        packet->octets.base[packet->encrypted_off + i] ^= hpmask[i + 1];
+        pnbits = (pnbits << 8) | packet->octets.base[packet->encrypted_off + i];
+    }
+
+    /* determine aead index (FIXME move AEAD key selection and decryption logic to the caller?) */
+    if (QUICLY_PACKET_IS_LONG_HEADER(packet->octets.base[0])) {
+        aead_index = 0;
+    } else {
+        /* note: aead index 0 is used by 0-RTT */
+        aead_index = (packet->octets.base[0] & QUICLY_KEY_PHASE_BIT) == 0;
+        if (aead[aead_index] == NULL)
+            goto Error;
+    }
+
+    /* AEAD */
+    pn = quicly_determine_packet_number(pnbits, pnlen * 8, *next_expected_pn);
+    size_t aead_off = packet->encrypted_off + pnlen;
+    if ((ptlen = ptls_aead_decrypt(aead[aead_index], packet->octets.base + aead_off, packet->octets.base + aead_off,
+                                   packet->octets.len - aead_off, pn, packet->octets.base, aead_off)) == SIZE_MAX) {
+        if (QUICLY_DEBUG)
+            fprintf(stderr, "%s: aead decryption failure (pn: %" PRIu64 ")\n", __FUNCTION__, pn);
+        goto Error;
+    }
+
+    self->super.decrypt_packet_done(conn, dest_addr, src_addr, packet, space, epoch, pn, aead_off, ptlen);
+
+    return 0;
+
+Error:
+    return 1;
+}
+
+quicly_crypto_codec_t *quicly_new_default_crypto_codec()
+{
+    struct st_quicly_default_crypto_codec_t *self = NULL;
+    if ((self = malloc(sizeof(*self))) == NULL)
+        goto Exit;
+
+    *self = (struct st_quicly_default_crypto_codec_t){{quicly_default_crypto_codec_packet_encrypt, quicly_default_crypto_codec_packet_encrypt_done, quicly_default_crypto_codec_packet_decrypt, NULL}};
+
+Exit:
+    return &self->super;
+}
+
 /**
  * See doc-comment of `st_quicly_default_scheduler_state_t` to understand the logic.
  */
diff --git a/lib/quicly.c b/lib/quicly.c
index 95d5f13..f480d71 100644
--- a/lib/quicly.c
+++ b/lib/quicly.c
@@ -44,7 +44,6 @@
 #define QUICLY_QUIC_BIT 0x40
 #define QUICLY_LONG_HEADER_RESERVED_BITS 0xc
 #define QUICLY_SHORT_HEADER_RESERVED_BITS 0x18
-#define QUICLY_KEY_PHASE_BIT 0x4
 
 #define QUICLY_PACKET_TYPE_INITIAL (QUICLY_LONG_HEADER_BIT | QUICLY_QUIC_BIT | 0)
 #define QUICLY_PACKET_TYPE_0RTT (QUICLY_LONG_HEADER_BIT | QUICLY_QUIC_BIT | 0x10)
@@ -123,25 +122,6 @@ struct st_quicly_pending_path_challenge_t {
     uint8_t data[QUICLY_PATH_CHALLENGE_DATA_LEN];
 };
 
-struct st_quicly_pn_space_t {
-    /**
-     * acks to be sent to peer
-     */
-    quicly_ranges_t ack_queue;
-    /**
-     * time at when the largest pn in the ack_queue has been received (or INT64_MAX if none)
-     */
-    int64_t largest_pn_received_at;
-    /**
-     *
-     */
-    uint64_t next_expected_packet_number;
-    /**
-     * packet count before ack is sent
-     */
-    uint32_t unacked_count;
-};
-
 struct st_quicly_handshake_space_t {
     struct st_quicly_pn_space_t super;
     struct {
@@ -178,6 +158,10 @@ struct st_quicly_conn_t {
      * 0-RTT and 1-RTT context
      */
     struct st_quicly_application_space_t *application;
+    /**
+     * default codec
+     */
+    quicly_crypto_codec_t *crypto_codec;
     /**
      * hashtable of streams
      */
@@ -1501,6 +1485,7 @@ static quicly_conn_t *create_connection(quicly_context_t *ctx, const char *serve
     conn->_.super.master_id = *new_cid;
     set_address(&conn->_.super.host.address, local_addr);
     set_address(&conn->_.super.peer.address, remote_addr);
+    conn->_.crypto_codec = ctx->crypto_codec;
     if (ctx->cid_encryptor != NULL) {
         conn->_.super.master_id.path_id = 0;
         ctx->cid_encryptor->encrypt_cid(ctx->cid_encryptor, &conn->_.super.host.src_cid, &conn->_.super.host.stateless_reset_token,
@@ -2139,19 +2124,9 @@ static int commit_send_packet(quicly_conn_t *conn, quicly_send_context_t *s, int
     }
     quicly_encode16(s->dst_payload_from - QUICLY_SEND_PN_SIZE, (uint16_t)conn->egress.packet_number);
 
-    s->dst = s->dst_payload_from + ptls_aead_encrypt(s->target.cipher->aead, s->dst_payload_from, s->dst_payload_from,
-                                                     s->dst - s->dst_payload_from, conn->egress.packet_number,
-                                                     s->target.first_byte_at, s->dst_payload_from - s->target.first_byte_at);
-
-    { /* apply header protection */
-        uint8_t hpmask[1 + QUICLY_SEND_PN_SIZE] = {0};
-        ptls_cipher_init(s->target.cipher->header_protection, s->dst_payload_from - QUICLY_SEND_PN_SIZE + QUICLY_MAX_PN_SIZE);
-        ptls_cipher_encrypt(s->target.cipher->header_protection, hpmask, hpmask, sizeof(hpmask));
-        *s->target.first_byte_at ^= hpmask[0] & (QUICLY_PACKET_IS_LONG_HEADER(*s->target.first_byte_at) ? 0xf : 0x1f);
-        size_t i;
-        for (i = 0; i != QUICLY_SEND_PN_SIZE; ++i)
-            s->dst_payload_from[i - QUICLY_SEND_PN_SIZE] ^= hpmask[i + 1];
-    }
+    s->dst = s->dst_payload_from + conn->crypto_codec->encrypt_packet(conn->crypto_codec, s->target.cipher->aead,
+                                                               s->target.cipher->header_protection, s->dst, s->dst_payload_from,
+                                                               s->target.first_byte_at, conn->egress.packet_number);
 
     /* update CC, commit sentmap */
     if (s->target.ack_eliciting) {
@@ -4104,15 +4079,141 @@ Exit:
     return ret;
 }
 
+int commit_receive_packet(quicly_conn_t *conn, struct sockaddr *dest_addr, struct sockaddr *src_addr, quicly_decoded_packet_t *packet,
+                          quicly_pn_space_t *space, size_t epoch, uint64_t pn, size_t aead_off, size_t ptlen)
+{
+    ptls_iovec_t payload;
+    uint64_t offending_frame_type = QUICLY_FRAME_TYPE_PADDING;
+    int is_ack_only;
+    int ret = 0;
+
+        /* check reserved bits after AEAD decryption */
+    if ((packet->octets.base[0] & (QUICLY_PACKET_IS_LONG_HEADER(packet->octets.base[0]) ? QUICLY_LONG_HEADER_RESERVED_BITS
+                                                                                        : QUICLY_SHORT_HEADER_RESERVED_BITS)) !=
+        0) {
+        payload = ptls_iovec_init(NULL, 0);
+        if (QUICLY_DEBUG)
+            fprintf(stderr, "%s: non-zero reserved bits (pn: %" PRIu64 ")\n", __FUNCTION__, pn);
+        goto Exit;
+    }
+
+    if (QUICLY_DEBUG) {
+        char *payload_hex = quicly_hexdump(packet->octets.base + aead_off, ptlen, 4);
+        fprintf(stderr, "%s: AEAD payload:\n%s", __FUNCTION__, payload_hex);
+        free(payload_hex);
+    }
+
+    if (space->next_expected_packet_number <= pn)
+        space->next_expected_packet_number = pn + 1;
+    payload = ptls_iovec_init(packet->octets.base + aead_off, ptlen);
+
+    if (payload.len == 0) {
+        ret = QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;
+        goto Exit;
+    }
+
+    QUICLY_PROBE(CRYPTO_DECRYPT, conn, pn, payload.base, payload.len);
+    QUICLY_PROBE(QUICTRACE_RECV, conn, probe_now(), pn);
+
+    /* update states */
+    if (conn->super.state == QUICLY_STATE_FIRSTFLIGHT)
+        conn->super.state = QUICLY_STATE_CONNECTED;
+    conn->super.stats.num_packets.received += 1;
+    conn->super.stats.num_bytes.received += packet->octets.len;
+
+    /* state updates, that are triggered by the receipt of a packet */
+    if (epoch == QUICLY_EPOCH_HANDSHAKE && conn->initial != NULL) {
+        /* Discard Initial space before processing the payload of the Handshake packet to avoid the chance of an ACK frame included
+         * in the Handshake packet setting a loss timer for the Initial packet. */
+        if ((ret = discard_initial_context(conn)) != 0)
+            goto Exit;
+        update_loss_alarm(conn);
+        conn->super.peer.address_validation.validated = 1;
+    }
+
+    /* handle the payload */
+    if ((ret = handle_payload(conn, epoch, payload.base, payload.len, &offending_frame_type, &is_ack_only)) != 0)
+        goto Exit;
+    if (space != NULL) {
+        if ((ret = record_receipt(conn, space, pn, is_ack_only, epoch)) != 0)
+            goto Exit;
+    }
+
+    /* state updates post payload processing */
+    switch (epoch) {
+    case QUICLY_EPOCH_INITIAL:
+        assert(conn->initial != NULL);
+        if (quicly_is_client(conn) && conn->handshake != NULL && conn->handshake->cipher.egress.aead != NULL) {
+            if ((ret = discard_initial_context(conn)) != 0)
+                goto Exit;
+            update_loss_alarm(conn);
+        }
+        break;
+    case QUICLY_EPOCH_HANDSHAKE:
+        /* schedule the timer to discard contexts related to the handshake if we have received all handshake messages and all the
+         * messages we sent have been acked */
+        if (!conn->crypto.handshake_scheduled_for_discard && ptls_handshake_is_complete(conn->crypto.tls)) {
+            quicly_stream_t *stream = quicly_get_stream(conn, -(quicly_stream_id_t)(1 + QUICLY_EPOCH_HANDSHAKE));
+            assert(stream != NULL);
+            quicly_streambuf_t *buf = stream->data;
+            if (buf->egress.vecs.size == 0) {
+                if ((ret = quicly_sentmap_prepare(&conn->egress.sentmap, conn->egress.packet_number, now,
+                                                  QUICLY_EPOCH_HANDSHAKE)) != 0)
+                    goto Exit;
+                if (quicly_sentmap_allocate(&conn->egress.sentmap, discard_handshake_context) == NULL) {
+                    ret = PTLS_ERROR_NO_MEMORY;
+                    goto Exit;
+                }
+                quicly_sentmap_commit(&conn->egress.sentmap, 0);
+                ++conn->egress.packet_number;
+                conn->crypto.handshake_scheduled_for_discard = 1;
+            }
+        }
+        /* when running as a client, respect "disable_migration" TP sent by the peer at the end of the TLS handshake */
+        if (quicly_is_client(conn) && conn->super.host.address.sa.sa_family == AF_UNSPEC && dest_addr != NULL &&
+            dest_addr->sa_family != AF_UNSPEC && ptls_handshake_is_complete(conn->crypto.tls) &&
+            conn->super.peer.transport_params.disable_active_migration)
+            set_address(&conn->super.host.address, dest_addr);
+        break;
+    case QUICLY_EPOCH_1RTT:
+        if (!is_ack_only && should_send_max_data(conn))
+            conn->egress.send_ack_at = 0;
+        break;
+    default:
+        break;
+    }
+
+    update_idle_timeout(conn, 1);
+
+Exit:
+    switch (ret) {
+    case 0:
+        /* Avoid time in the past being emitted by quicly_get_first_timeout. We hit the condition below when retransmission is
+         * suspended by the 3x limit (in which case we have loss.alarm_at set but return INT64_MAX from quicly_get_first_timeout
+         * until we receive something from the client).
+         */
+        if (conn->egress.loss.alarm_at < now)
+            conn->egress.loss.alarm_at = now;
+        assert_consistency(conn, 0);
+        break;
+    case QUICLY_ERROR_PACKET_IGNORED:
+        break;
+    default: /* close connection */
+        initiate_close(conn, ret, offending_frame_type, "");
+        ret = 0;
+        break;
+    }
+    return ret;
+}
+
 int quicly_receive(quicly_conn_t *conn, struct sockaddr *dest_addr, struct sockaddr *src_addr, quicly_decoded_packet_t *packet)
 {
     ptls_cipher_context_t *header_protection;
     ptls_aead_context_t **aead;
-    struct st_quicly_pn_space_t **space;
+    struct st_quicly_pn_space_t *space;
     size_t epoch;
-    ptls_iovec_t payload;
-    uint64_t pn, offending_frame_type = QUICLY_FRAME_TYPE_PADDING;
-    int is_ack_only, ret;
+    uint64_t offending_frame_type = QUICLY_FRAME_TYPE_PADDING;
+    int ret = 0;
 
     update_now(conn->super.ctx);
 
@@ -4200,7 +4301,7 @@ int quicly_receive(quicly_conn_t *conn, struct sockaddr *dest_addr, struct socka
                 conn->super.peer.cid.len = packet->cid.src.len;
             }
             aead = &conn->initial->cipher.ingress.aead;
-            space = (void *)&conn->initial;
+            space = (void *)conn->initial;
             epoch = QUICLY_EPOCH_INITIAL;
             break;
         case QUICLY_PACKET_TYPE_HANDSHAKE:
@@ -4209,7 +4310,7 @@ int quicly_receive(quicly_conn_t *conn, struct sockaddr *dest_addr, struct socka
                 goto Exit;
             }
             aead = &conn->handshake->cipher.ingress.aead;
-            space = (void *)&conn->handshake;
+            space = (void *)conn->handshake;
             epoch = QUICLY_EPOCH_HANDSHAKE;
             break;
         case QUICLY_PACKET_TYPE_0RTT:
@@ -4223,7 +4324,7 @@ int quicly_receive(quicly_conn_t *conn, struct sockaddr *dest_addr, struct socka
                 goto Exit;
             }
             aead = &conn->application->cipher.ingress.aead[0];
-            space = (void *)&conn->application;
+            space = (void *)conn->application;
             epoch = QUICLY_EPOCH_0RTT;
             break;
         default:
@@ -4238,93 +4339,18 @@ int quicly_receive(quicly_conn_t *conn, struct sockaddr *dest_addr, struct socka
             goto Exit;
         }
         aead = conn->application->cipher.ingress.aead;
-        space = (void *)&conn->application;
+        space = (void *)conn->application;
         epoch = QUICLY_EPOCH_1RTT;
     }
 
-    /* decrypt */
-    if ((payload = decrypt_packet(header_protection, aead, &(*space)->next_expected_packet_number, packet, &pn)).base == NULL) {
+    conn->crypto_codec->decrypt_packet_done = commit_receive_packet;
+    if (conn->crypto_codec->decrypt_packet(conn->crypto_codec, conn, dest_addr, src_addr, space, header_protection, aead, epoch,
+                                    &space->next_expected_packet_number, packet)) {
         ret = QUICLY_ERROR_PACKET_IGNORED;
         goto Exit;
     }
-    if (payload.len == 0) {
-        ret = QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;
-        goto Exit;
-    }
-
-    QUICLY_PROBE(CRYPTO_DECRYPT, conn, pn, payload.base, payload.len);
-    QUICLY_PROBE(QUICTRACE_RECV, conn, probe_now(), pn);
-
-    /* update states */
-    if (conn->super.state == QUICLY_STATE_FIRSTFLIGHT)
-        conn->super.state = QUICLY_STATE_CONNECTED;
-    conn->super.stats.num_packets.received += 1;
-    conn->super.stats.num_bytes.received += packet->octets.len;
-
-    /* state updates, that are triggered by the receipt of a packet */
-    if (epoch == QUICLY_EPOCH_HANDSHAKE && conn->initial != NULL) {
-        /* Discard Initial space before processing the payload of the Handshake packet to avoid the chance of an ACK frame included
-         * in the Handshake packet setting a loss timer for the Initial packet. */
-        if ((ret = discard_initial_context(conn)) != 0)
-            goto Exit;
-        update_loss_alarm(conn);
-        conn->super.peer.address_validation.validated = 1;
-    }
-
-    /* handle the payload */
-    if ((ret = handle_payload(conn, epoch, payload.base, payload.len, &offending_frame_type, &is_ack_only)) != 0)
-        goto Exit;
-    if (*space != NULL) {
-        if ((ret = record_receipt(conn, *space, pn, is_ack_only, epoch)) != 0)
-            goto Exit;
-    }
-
-    /* state updates post payload processing */
-    switch (epoch) {
-    case QUICLY_EPOCH_INITIAL:
-        assert(conn->initial != NULL);
-        if (quicly_is_client(conn) && conn->handshake != NULL && conn->handshake->cipher.egress.aead != NULL) {
-            if ((ret = discard_initial_context(conn)) != 0)
-                goto Exit;
-            update_loss_alarm(conn);
-        }
-        break;
-    case QUICLY_EPOCH_HANDSHAKE:
-        /* schedule the timer to discard contexts related to the handshake if we have received all handshake messages and all the
-         * messages we sent have been acked */
-        if (!conn->crypto.handshake_scheduled_for_discard && ptls_handshake_is_complete(conn->crypto.tls)) {
-            quicly_stream_t *stream = quicly_get_stream(conn, -(quicly_stream_id_t)(1 + QUICLY_EPOCH_HANDSHAKE));
-            assert(stream != NULL);
-            quicly_streambuf_t *buf = stream->data;
-            if (buf->egress.vecs.size == 0) {
-                if ((ret = quicly_sentmap_prepare(&conn->egress.sentmap, conn->egress.packet_number, now,
-                                                  QUICLY_EPOCH_HANDSHAKE)) != 0)
-                    goto Exit;
-                if (quicly_sentmap_allocate(&conn->egress.sentmap, discard_handshake_context) == NULL) {
-                    ret = PTLS_ERROR_NO_MEMORY;
-                    goto Exit;
-                }
-                quicly_sentmap_commit(&conn->egress.sentmap, 0);
-                ++conn->egress.packet_number;
-                conn->crypto.handshake_scheduled_for_discard = 1;
-            }
-        }
-        /* when running as a client, respect "disable_migration" TP sent by the peer at the end of the TLS handshake */
-        if (quicly_is_client(conn) && conn->super.host.address.sa.sa_family == AF_UNSPEC && dest_addr != NULL &&
-            dest_addr->sa_family != AF_UNSPEC && ptls_handshake_is_complete(conn->crypto.tls) &&
-            conn->super.peer.transport_params.disable_active_migration)
-            set_address(&conn->super.host.address, dest_addr);
-        break;
-    case QUICLY_EPOCH_1RTT:
-        if (!is_ack_only && should_send_max_data(conn))
-            conn->egress.send_ack_at = 0;
-        break;
-    default:
-        break;
-    }
-
-    update_idle_timeout(conn, 1);
 
+    return ret;
 Exit:
     switch (ret) {
     case 0:
diff --git a/src/cli.c b/src/cli.c
index d13721b..26e7e35 100644
--- a/src/cli.c
+++ b/src/cli.c
@@ -1039,6 +1039,10 @@ int main(int argc, char **argv)
     if (key_exchanges[0] == NULL)
         key_exchanges[0] = &ptls_openssl_secp256r1;
 
+
+    ctx.crypto_codec =
+        quicly_new_default_crypto_codec();
+
     if (ctx.tls->certificates.count != 0 || ctx.tls->sign_certificate != NULL) {
         /* server */
         if (ctx.tls->certificates.count == 0 || ctx.tls->sign_certificate == NULL) {
diff --git a/t/test.c b/t/test.c
index 8adcbe8..8e0b1b1 100644
--- a/t/test.c
+++ b/t/test.c
@@ -384,6 +384,7 @@ int main(int argc, char **argv)
     quic_ctx.transport_params.max_streams_bidi = 10;
     quic_ctx.stream_open = &stream_open;
     quic_ctx.now = &get_now;
+    quic_ctx.crypto_codec = quicly_new_default_crypto_codec();
 
     fake_address.sa.sa_family = AF_INET;
 
