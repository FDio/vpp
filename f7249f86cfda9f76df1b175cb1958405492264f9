{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a091ea3a_657a2af1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 366
      },
      "writtenOn": "2025-01-09T16:07:11Z",
      "side": 1,
      "message": "Fixing the segfault is fine.\n\nRemoving the drain of netlink messages while creating an interface pair will cause problems. Messages are drained at this point to avoid applying transient operations to the hardware interface which were performed on the associated tap.\n\nWhen a tap is created on the host kernel network stack, it has default values set for attributes like mtu and mac address. After creation, those attributes on the kernel tap interface are set to match the values on the paired hardware interface. The initial creation of the tap will result in one or more RTM_NEWLINK messages with the default values set, followed by additional RTM_NEWLINK messages with the updated values which match the hardware interface. When a pair is created you can end up with something like the following happening:\n\n- pair create starts for hardware interface eth0 to create tap vpp1 on the host\n- tap_create_if() creates vpp1 in the host kernel network stack. kernel sends RTM_NEWLINK(s) with default mtu (1500), mac address (randomly generated).\n- tap_create_if() sets vpp1 to IFF_UP (it does this unconditionally for all created taps), kernel sends RTM_NEWLINK to reflect the change in admin state.\n- tap_create_if() sets vpp1 mac address to the hardware interface mac address. kernel sends RTM_NEWLINK to reflect the change in mac address.\n- tap_create_if() sets vpp1 mtu to the hardware interface mtu. kernel sends RTM_NEWLINK to reflect the change in mtu.\n- lcp_itf_pair_create() sets vpp1 \"link state\" (actually equivalent to VPP admin state, it\u0027s the IFF_UP flag) to match the hardware interface. kernel sends RTM_NEWLINK to reflect the change.\n- pair create returns\n- The entire series of RTM_NEWLINK messages generated by all previous actions is read from netlink socket and queued\n- The queued messages are processed sequentially.\n- The initial messages with default values set may not match the parameters currently set on eth0, so eth0\u0027s configurations can be changed to match those stale values. \n- The later messages with values matching eth0\u0027s initial state are processed. Since eth0 had changes applied previously to match the initial state of vpp1, its configuration is now changed back to it\u0027s original state.\n\nChanging the mtu, mac address, or admin state of a hardware interface can take a significant amount of time. The main thread blocks while these operations occur and \nworkers are left waiting at a barrier during that time. Doing this twice when it was not necessary to do it at all is undesirable.\n\nThe situation is avoided by using the queue drain that you remove here. A timestamp is recorded on the interface pair when it becomes active. Timestamps are written on each received message as they are processed. If a message\u0027s timestamp is earlier than the interface pair related to that message, the message is ignored. In order to ensure that this works, the netlink messages generated by provisioning/reconfiguration of the tap need to be drained before the interface pair is activated.",
      "revId": "f7249f86cfda9f76df1b175cb1958405492264f9",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1df9fa78_97f81a8b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 2280
      },
      "writtenOn": "2025-01-16T08:25:30Z",
      "side": 1,
      "message": "Thank you so much for the detailed explanation, Matthew. It was very helpful!\n\nGot it, this is optimization. I will bring it back, but as far as I understand, this is generally not a guarantee that everything will work out this way.\nFor example, what if, at the time of calling drain, the netlink messages (generated by provisioning of the tap vpp1) are not yet sent by the kernel, but other messages are received, for example from another already working lcp pair (for example from tap vpp0). In short:\n1. —Åreate lcp pair for eth0 (tap vpp0)\n2. start creating lcp pair for eth1 (tap vpp1)\n3. drain messages from vpp1, but we only receive some messages from vpp0\n4. finish creating lcp pair for eth1 (tap vpp1)\n5. messages with the default values of the vpp1 come later, after the interface pair is activated.\nIt\u0027s unlikely, but possible, I think",
      "parentUuid": "a091ea3a_657a2af1",
      "revId": "f7249f86cfda9f76df1b175cb1958405492264f9",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "996b582e_d8c9e165",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 366
      },
      "writtenOn": "2025-01-16T15:32:43Z",
      "side": 1,
      "message": "Thanks for making the requested change.\n\nYes, I think the race condition you described could possibly happen though I don\u0027t know for sure. I have not looked through kernel code in a while at details of what happens when a netlink request or ioctl() is processed.\n\nIf it happens, the effect would be that we apply unnecessary changes to eth1 and incur the overhead of resetting the NIC but it still ends up in the correct state. I think most of the time the timestamp will work correctly to avoid that overhead though.\n\nMaybe if it ends up being an issue for someone in the future, there is some other better approach possible. E.g. after all other operations performed while creating a pair, make some innocuous change that will signal that the interface is active (add an interface alt name property formatted like \u0027lcp-interface-\u003cphy_sw_if_index\u003e-\u003ckernel_if_index\u003e\u0027 or something). Then linux-nl can look for the kernel\u0027s announcement of that change being applied and mark the pair active when it sees it.",
      "parentUuid": "1df9fa78_97f81a8b",
      "revId": "f7249f86cfda9f76df1b175cb1958405492264f9",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    }
  ]
}