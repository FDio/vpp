{
  "comments": [
    {
      "key": {
        "uuid": "4fb366a8_d7be7695",
        "filename": "src/vnet/tls/tls.c",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 193
      },
      "writtenOn": "2018-08-28T15:21:49Z",
      "side": 1,
      "message": "Did you try with a reader lock here since it\u0027s cheaper? If it doesn\u0027t work, I guess we could just keep this branch and remove the rest.",
      "range": {
        "startLine": 103,
        "startChar": 18,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "6b72b35dd8cceb9cdbf422831e7267caa37d63cb",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f3affc5e_8ec50f71",
        "filename": "src/vnet/tls/tls.c",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 1269
      },
      "writtenOn": "2018-08-28T15:46:13Z",
      "side": 1,
      "message": "reader lock works fine, but the race condition happens at Thread 0 and Thread \u003c~0\u003e, and pool_get can only be called at thread 0, since other threads is using write locker, I don\u0027t know why reader is cheaper?\nFrom the below code it still needs to check writer lock. \n\n  (*p)-\u003en_readers +\u003d 1;\n  if ((*p)-\u003en_readers \u003d\u003d 1)\n    {\n      while (__sync_lock_test_and_set (\u0026(*p)-\u003ewriter_lock, 1))\n\tCLIB_PAUSE ();\n    }\n\nTwo branch here can reduce one lock for \"pool_get_aligned_will_expand\",  since non-0 thread will not call \"pool_get\", so they will never test if expand. \nHow do you think?",
      "parentUuid": "4fb366a8_d7be7695",
      "range": {
        "startLine": 103,
        "startChar": 18,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "6b72b35dd8cceb9cdbf422831e7267caa37d63cb",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1de590a7_1c2836cc",
        "filename": "src/vnet/tls/tls.c",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 193
      },
      "writtenOn": "2018-08-28T16:01:28Z",
      "side": 1,
      "message": "rwlock favors readers. That is, if you have at least one reader in, a new reader won\u0027t have to wait for the lock. The writer on the other hand needs to wait for all readers to exit. \n\nIf threadX wants to do a free while thread0 does a non expandable get, they have to wait for each other (although one is a writer and the other a reader), so the pool internal vector is protected.",
      "parentUuid": "f3affc5e_8ec50f71",
      "range": {
        "startLine": 103,
        "startChar": 18,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "6b72b35dd8cceb9cdbf422831e7267caa37d63cb",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "389faad1_4faaf76a",
        "filename": "src/vnet/tls/tls.c",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 1269
      },
      "writtenOn": "2018-08-29T02:36:21Z",
      "side": 1,
      "message": "yes, I understand this situation. But in our case, pool_get only be called by thread 0, so there is no multiple readers, even if changing to reader lock, the writer lock still needs to be checked. There is no performance gain in this case. \nIf we allow multiple threads which can call \"pool_get\" using reader lock, then since reader lock allow multiple thread to enter, it will cause internal pool vec_len corruption by calling pool_get at the same time since below code is not atomic operation. \n\n_vec_len (_pool_var (p)-\u003efree_indices) \u003d _pool_var (l) - 1;",
      "parentUuid": "1de590a7_1c2836cc",
      "range": {
        "startLine": 103,
        "startChar": 18,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "6b72b35dd8cceb9cdbf422831e7267caa37d63cb",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f4eee80c_e49eb0f8",
        "filename": "src/vnet/tls/tls.c",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 193
      },
      "writtenOn": "2018-08-29T03:16:30Z",
      "side": 1,
      "message": "The issue you\u0027ve found is that free can be called from other threads and that corrupts the free indices vector because it\u0027s not protected. So the case we need to avoid is, alloc in main thread without writer lock interacting with free in another thread, with writer lock held (note that free does acquire the writer lock).\n\nAs a first solution, you forced another writer lock even on the non-expand branch, and of course that should work. What I\u0027ve asked previously, and I thought you confirmed it worked, is if you could try with a reader lock on that branch, because that should be enough. The reasoning: when free tries to acquire writer lock, it can\u0027t if main thread acquired the reader lock (and vice-versa, main thread when it doesn\u0027t expand pool can\u0027t acquire reader lock if another thread acquired writer lock first). \n\nIf this works, and again, I thought you confirmed it did, then this might be only slightly faster because again, we favor readers: that is, if we have a reader a subsequent reader does not have to wait at all (e.g., say out of N workers, there\u0027s a good chance one just received a connection, did a read and it\u0027s still doing all the processing before freeing the context).\n\nHowever, I feel we\u0027re spending an awful lot of time debating something that at this point is not that important. If the reader lock does not work, then instead of what you\u0027re proposing I\u0027d rather remove the will expand branch entirely, because with a double lock it offers no benefits, and just protect this branch with a writer lock. It\u0027s much cleaner.",
      "parentUuid": "389faad1_4faaf76a",
      "range": {
        "startLine": 103,
        "startChar": 18,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "6b72b35dd8cceb9cdbf422831e7267caa37d63cb",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8d6e50be_89f4ee5c",
        "filename": "src/vnet/tls/tls.c",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 1269
      },
      "writtenOn": "2018-08-29T04:33:35Z",
      "side": 1,
      "message": "yes, if using read locker, then tls_ctx_half_open_get will be quicker. I will update the code. But be aware, here \"reader\" lock is used with the assumption that only \"thread 0\" can call it.",
      "parentUuid": "f4eee80c_e49eb0f8",
      "range": {
        "startLine": 103,
        "startChar": 18,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "6b72b35dd8cceb9cdbf422831e7267caa37d63cb",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    }
  ]
}