{
  "comments": [
    {
      "key": {
        "uuid": "336bce5b_f0f0bd18",
        "filename": "src/vnet/ethernet/node.c",
        "patchSetId": 5
      },
      "lineNbr": 730,
      "author": {
        "id": 9
      },
      "writtenOn": "2019-09-23T12:39:11Z",
      "side": 1,
      "message": "this is expensive, probably it is cheaper just to blindly compare....",
      "range": {
        "startLine": 729,
        "startChar": 0,
        "endLine": 730,
        "endChar": 18
      },
      "revId": "d871e4dd17239e0c08d9885f16435e57721bd94e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "89f4c1dc_e03892b0",
        "filename": "src/vnet/ethernet/node.c",
        "patchSetId": 5
      },
      "lineNbr": 730,
      "author": {
        "id": 366
      },
      "writtenOn": "2019-09-23T17:58:20Z",
      "side": 1,
      "message": "I considered this when I was working on the patch but I was not sure if it would result in any gain in performance.\n\nAs dmacs_bad is iterated, any entries which have already matched an interface hw addr (!dmac_bad[0]) are skipped. When a bad (nonzero) entry is found, the dmacs in the next spots in the array may have already matched. If 8 dmacs are blindly compared starting at a bad one that was found, some subset of the last 7 may have already matched an interface address and will fail the comparison with the interface address currently being examined.\n\nSince a dmac only has to match one of the interface hw addresses for it to be valid, dmac_bad should only be updated with results of a comparison against a secondary addr if the dmac_bad entry was nonzero before and would change to 0. An entry that was already 0 because it matched the primary hw addr should not be set to nonzero because it did not match a secondary addr.\n\nBecause of this, it seemed to me that for every comparison between a packet dmac and an interface secondary mac addr, that the current value of the dmac_bad entry would need to be read and checked to see if it was nonzero before being updated. So it seemed like the cost of figuring out which entries had not been matched yet was unavoidable.\n\nThat was my logic for coding it the way I did. Your opinions about what would be most efficient are probably better informed than mine, so I will defer to your judgement if you still think it would be better to compare a batch of dmacs blindly when we find a bad one. Let me know and I\u0027ll submit a patch.",
      "parentUuid": "336bce5b_f0f0bd18",
      "range": {
        "startLine": 729,
        "startChar": 0,
        "endLine": 730,
        "endChar": 18
      },
      "revId": "d871e4dd17239e0c08d9885f16435e57721bd94e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5b592703_f629fa4f",
        "filename": "src/vnet/ethernet/node.c",
        "patchSetId": 5
      },
      "lineNbr": 730,
      "author": {
        "id": 9
      },
      "writtenOn": "2019-09-23T18:54:50Z",
      "side": 1,
      "message": "each loop means at least one branch miss, and that costs \u003e 10 clocks.\nBeside that you spend time on checking every single byte of dmac_bad, so all together it is more expensive than to just blindlyi compare 4 dmacs in single instruction and do msb mask.\nas msb mask gives you 4 bytes (u32).\n\nfor example:\n\nstatic_always_inline u32\nis_sec_dmac_bad_x4 (u64 * dmacs, u64 hwaddr)\n{\n  u64x4 r0 \u003d u64x4_load_unaligned (dmacs) \u0026 u64x4_splat (DMAC_MASK);\n  r0 \u003d (r0 !\u003d u64x4_splat (hwaddr));\n  return u8x32_msb_mask ((u8x32) (r0));\n}\n\nWill give you back u32 where each byte is 0xff if there is no sec_dmac match and 0x00 if there is match.\n\nThen, you can simply do \"bitwise and\" between returned value and old dmac_bad for those 4 packets.\n\nLet\u0027s say that packets 0, 1, and 3 have primry dmac, and packet 2 have secondary dmac.\n\ndmac_bad will be \"0x00, 0x00, 0xff, 0x00\"\n\n\nresult of is_sec_dmac_bad_x4 on same 4 packets will be:\n\n\"0xFF, 0xFF, 0x00, 0xFF\"\n\n\nso doing simply \"bitwise and\" between those 2 u32 numbers will give you \"0x00, 0x00, 0x00, 0x00\", or in other words all for are not bad.",
      "parentUuid": "89f4c1dc_e03892b0",
      "range": {
        "startLine": 729,
        "startChar": 0,
        "endLine": 730,
        "endChar": 18
      },
      "revId": "d871e4dd17239e0c08d9885f16435e57721bd94e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "30a9138f_d93c1980",
        "filename": "src/vnet/ethernet/node.c",
        "patchSetId": 5
      },
      "lineNbr": 737,
      "author": {
        "id": 9
      },
      "writtenOn": "2019-09-23T12:39:11Z",
      "side": 1,
      "message": "IGBIT check is already done so this can be done in a simpler way. Just mask and compare u64, if equal set dmac_bad to 0.",
      "range": {
        "startLine": 737,
        "startChar": 6,
        "endLine": 737,
        "endChar": 29
      },
      "revId": "d871e4dd17239e0c08d9885f16435e57721bd94e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "380988de_2558e3d3",
        "filename": "src/vnet/ethernet/node.c",
        "patchSetId": 5
      },
      "lineNbr": 737,
      "author": {
        "id": 366
      },
      "writtenOn": "2019-09-23T17:58:20Z",
      "side": 1,
      "message": "Do you think I should do this inline instead of calling eth_input_dmac_check_x{1,4,8}()? Or add a u8 check_igbit argument to those functions and is_dmac_bad() and is_dmac_bad_x4() and only perform the ig bit check when that argument is true?",
      "parentUuid": "30a9138f_d93c1980",
      "range": {
        "startLine": 737,
        "startChar": 6,
        "endLine": 737,
        "endChar": 29
      },
      "revId": "d871e4dd17239e0c08d9885f16435e57721bd94e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7678b0c6_20376f11",
        "filename": "src/vnet/ethernet/node.c",
        "patchSetId": 5
      },
      "lineNbr": 737,
      "author": {
        "id": 9
      },
      "writtenOn": "2019-09-23T18:54:50Z",
      "side": 1,
      "message": "See above...",
      "parentUuid": "380988de_2558e3d3",
      "range": {
        "startLine": 737,
        "startChar": 6,
        "endLine": 737,
        "endChar": 29
      },
      "revId": "d871e4dd17239e0c08d9885f16435e57721bd94e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    }
  ]
}