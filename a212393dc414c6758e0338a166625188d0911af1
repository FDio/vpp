{
  "comments": [
    {
      "key": {
        "uuid": "fa5d592f_1cd85e1c",
        "filename": "src/vnet/lisp-cp/control.c",
        "patchSetId": 1
      },
      "lineNbr": 3362,
      "author": {
        "id": 267
      },
      "writtenOn": "2017-06-16T10:31:22Z",
      "side": 1,
      "message": "comparing the way this is done in the ARP handling, when vl_api_rpc_call_main_thread is called the data is copied into the shm-q message. The receiving side acts on the message\u0027s data, and only the message itself needs to be freed (which is done by the infra on the callee\u0027s behalf)",
      "revId": "a212393dc414c6758e0338a166625188d0911af1",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa5d592f_d7173fa2",
        "filename": "src/vnet/lisp-cp/control.c",
        "patchSetId": 1
      },
      "lineNbr": 3362,
      "author": {
        "id": 193
      },
      "writtenOn": "2017-06-16T16:34:01Z",
      "side": 1,
      "message": "I also gave it some thought, but the issue is that we can have a large data structure compared to arp. Namely, several mappings, each with multiple locators although the size is limited to max mtu. So, instead of doing a deep copy onto the shm-q, I opted to allocating the structs on each thread and passing them to thread0 where once used they\u0027re tagged as free. \n\nI guess we could switch to using the shm-q if you think it\u0027s better.",
      "parentUuid": "fa5d592f_1cd85e1c",
      "revId": "a212393dc414c6758e0338a166625188d0911af1",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": false
    }
  ]
}