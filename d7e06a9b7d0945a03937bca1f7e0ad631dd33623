{
  "comments": [
    {
      "key": {
        "uuid": "e8dc37da_388101ab",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_cli.c",
        "patchSetId": 3
      },
      "lineNbr": 548,
      "author": {
        "id": 1961
      },
      "writtenOn": "2022-01-11T12:01:22Z",
      "side": 1,
      "message": "Can the user precisely see the number of established and transitory sessions that are still active? As far as I understand, these numbers are polluted by the already timed out sessions and there is no way for the user to tell them apart.\nI am wondering if this is a problem also for ICMP and UDP, from the numbers, we do not know how many ICMP or UDP sessions are still \"active\". Did I overlook something?\nI would suggest to continue the loop after the `if (now \u003e\u003d sess_timeout_time)` check.",
      "revId": "d7e06a9b7d0945a03937bca1f7e0ad631dd33623",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2340b717_ca8a1509",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_cli.c",
        "patchSetId": 3
      },
      "lineNbr": 548,
      "author": {
        "id": 601
      },
      "writtenOn": "2022-01-11T13:56:22Z",
      "side": 1,
      "message": "Okay, I think I can improve this to be more usable. Stay tuned.",
      "parentUuid": "e8dc37da_388101ab",
      "revId": "d7e06a9b7d0945a03937bca1f7e0ad631dd33623",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a2ba9c6_476ec624",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_inlines.h",
        "patchSetId": 3
      },
      "lineNbr": 774,
      "author": {
        "id": 1961
      },
      "writtenOn": "2022-01-11T12:01:22Z",
      "side": 1,
      "message": "Apart from tracing and being able to debug the state, is there a reason for the REOPEN_SYN_* states and not putting the session back to SYN_*?",
      "revId": "d7e06a9b7d0945a03937bca1f7e0ad631dd33623",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "602306a3_0e7ba166",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_inlines.h",
        "patchSetId": 3
      },
      "lineNbr": 774,
      "author": {
        "id": 601
      },
      "writtenOn": "2022-01-11T13:56:22Z",
      "side": 1,
      "message": "Yes, because open transition to ESTABLISHED from these states, the session will be reset (counters, events) and that\u0027s a different behaviour from SYN-\u003eESTABLISHED. I am currently writing the code for that, will amend patch.",
      "parentUuid": "6a2ba9c6_476ec624",
      "revId": "d7e06a9b7d0945a03937bca1f7e0ad631dd33623",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "efbeafc2_0bf868b2",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_inlines.h",
        "patchSetId": 3
      },
      "lineNbr": 832,
      "author": {
        "id": 1961
      },
      "writtenOn": "2022-01-11T12:01:22Z",
      "side": 1,
      "message": "What is the reason of not updating last_heard by an RST?\nSuppose the session is established and there was no packet received for 10 mins. Then an RST is forwarded and the state is set to RST_TRANS. The transitory timeout is immediately over in this case because `s-\u003elast_heard + nat44_session_get_timeout (s)` is already in the past.\n\nAnd it seems to me that the other 3 states below could have the same problem.\nWe could see if this is a real issue with a test case.",
      "revId": "d7e06a9b7d0945a03937bca1f7e0ad631dd33623",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1f596ced_35a7895d",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_inlines.h",
        "patchSetId": 3
      },
      "lineNbr": 832,
      "author": {
        "id": 601
      },
      "writtenOn": "2022-01-11T13:56:22Z",
      "side": 1,
      "message": "last_heard is update by RST in nat44_set_tcp_session_state, see line 806 above.\n\nNormal traffic should not update last_heard while in transitory timeout as that would negate transitory timeout\u0027s purpose - that is unconditional timeout if state is not changed within timeout. But for RST_TRANS case this will not be hit as normal traffic will change RST_TRANS to ESTABLISHED in nat44_set_tcp_session_state above. Still, for completeness sake I think it\u0027s best to have it \"if in transitory then don\u0027t update\".",
      "parentUuid": "efbeafc2_0bf868b2",
      "revId": "d7e06a9b7d0945a03937bca1f7e0ad631dd33623",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd1fedcc_4210fad3",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_inlines.h",
        "patchSetId": 3
      },
      "lineNbr": 832,
      "author": {
        "id": 1961
      },
      "writtenOn": "2022-01-11T15:09:25Z",
      "side": 1,
      "message": "Thank you for the explanation.\nAn interesting part of the RFC 7857 state machine is that in both the FIN_I2O and FIN_O2I states (C FIN or S FIN RCV), the established timeout is used. It is set to transitory only in FIN_TRANS, when both FINs are forwarded. This is slightly different from the timeout value returned by nat44_session_get_timeout().\nI am wondering what could be the reason of still using the established timeout, this relies on the RST when the other FIN does not arrive. I suppose there can still be outstanding data transmitted (in half closed state), this might be the background. With your current implementation and updating the last_heard value in FIN_I2O and FIN_O2I states, this should work I think.",
      "parentUuid": "1f596ced_35a7895d",
      "revId": "d7e06a9b7d0945a03937bca1f7e0ad631dd33623",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7b18591_90850d83",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_inlines.h",
        "patchSetId": 3
      },
      "lineNbr": 832,
      "author": {
        "id": 601
      },
      "writtenOn": "2022-01-11T22:14:22Z",
      "side": 1,
      "message": "That\u0027s a good point, let me adjust the code...",
      "parentUuid": "dd1fedcc_4210fad3",
      "revId": "d7e06a9b7d0945a03937bca1f7e0ad631dd33623",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0913983_a5174eab",
        "filename": "src/plugins/nat/nat44-ed/nat44_ed_inlines.h",
        "patchSetId": 3
      },
      "lineNbr": 832,
      "author": {
        "id": 1961
      },
      "writtenOn": "2022-01-12T09:47:54Z",
      "side": 1,
      "message": "Hi Klement,\nI am rather interested in your opinion than a code change.\nI personally find this part of the RFC state machine very fragile, it relies on the receipt of the RST when a FIN cannot be delivered or the other side does not send a FIN in return. In these cases, the session would remain in established state for a long time, which is very bad with a lot of sessions, they can pile up.\n\nLooking at our traces, I could easily find such cases. The FIN was re-transmitted several times but no RST was sent afterwards. And this happens in both directions, when the client tries to terminate the session as well as when the server does it. The server-initiated termination is  important for us because our clients can go offline suddenly (loss of connectivity, flat battery...).\nYour implementation with applying the transitory timer when the first FIN is forwarded is more robust in my opinion. If the last_heard value is still updated with the packets in the FIN_I2O and FIN_O2I states, it also allows data transmit for a long time.",
      "parentUuid": "e7b18591_90850d83",
      "revId": "d7e06a9b7d0945a03937bca1f7e0ad631dd33623",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20d5f0a5_8ac50836",
        "filename": "test/test_nat44_ed.py",
        "patchSetId": 3
      },
      "lineNbr": 3453,
      "author": {
        "id": 1961
      },
      "writtenOn": "2022-01-11T12:01:22Z",
      "side": 1,
      "message": "A test case for the [SYN, ACK] retransmit would also be nice. Feel free to take it from patch #34851.",
      "revId": "d7e06a9b7d0945a03937bca1f7e0ad631dd33623",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "682e0db2_7d17be9f",
        "filename": "test/test_nat44_ed.py",
        "patchSetId": 3
      },
      "lineNbr": 3453,
      "author": {
        "id": 601
      },
      "writtenOn": "2022-01-11T13:56:22Z",
      "side": 1,
      "message": "Alright thanks",
      "parentUuid": "20d5f0a5_8ac50836",
      "revId": "d7e06a9b7d0945a03937bca1f7e0ad631dd33623",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    }
  ]
}