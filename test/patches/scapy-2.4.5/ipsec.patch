diff --git a/scapy/layers/ipsec.py b/scapy/layers/ipsec.py
index 8251dc14..cd2b8ca6 100644
--- a/scapy/layers/ipsec.py
+++ b/scapy/layers/ipsec.py
@@ -60,7 +60,7 @@ import scapy.modules.six as six
 from scapy.modules.six.moves import range
 from scapy.layers.inet6 import IPv6, IPv6ExtHdrHopByHop, IPv6ExtHdrDestOpt, \
     IPv6ExtHdrRouting
-
+from scapy.contrib.mpls import MPLS
 
 ###############################################################################
 class AH(Packet):
@@ -546,7 +546,7 @@ class AuthAlgo(object):
         else:
             return self.mac(key, self.digestmod(), default_backend())
 
-    def sign(self, pkt, key, esn_en=False, esn=0):
+    def sign(self, pkt, key, trailer=None, esn_en=False, esn=0):
         """
         Sign an IPsec (ESP or AH) packet with this algo.
 
@@ -565,6 +565,8 @@ class AuthAlgo(object):
 
         if pkt.haslayer(ESP):
             mac.update(raw(pkt[ESP]))
+            if trailer:
+                mac.update(trailer)
             pkt[ESP].data += mac.finalize()[:self.icv_size]
 
         elif pkt.haslayer(AH):
@@ -574,11 +576,13 @@ class AuthAlgo(object):
             else:
                 temp = raw(clone)
             mac.update(temp)
+            if trailer:
+                mac.update(trailer)
             pkt[AH].icv = mac.finalize()[:self.icv_size]
 
         return pkt
 
-    def verify(self, pkt, key, esn_en=False, esn=0):
+    def verify(self, pkt, key, trailer, esn_en=False, esn=0):
         """
         Check that the integrity check value (icv) of a packet is valid.
 
@@ -617,6 +621,8 @@ class AuthAlgo(object):
                 temp = raw(clone)
 
         mac.update(temp)
+        if trailer:
+            mac.update(trailer) # bytearray(4)) #raw(trailer))
         computed_icv = mac.finalize()[:self.icv_size]
 
         # XXX: Cannot use mac.verify because the ICV can be truncated
@@ -805,7 +811,7 @@ class SecurityAssociation(object):
     This class is responsible of "encryption" and "decryption" of IPsec packets.  # noqa: E501
     """
 
-    SUPPORTED_PROTOS = (IP, IPv6)
+    SUPPORTED_PROTOS = (IP, IPv6, MPLS)
 
     def __init__(self, proto, spi, seq_num=1, crypt_algo=None, crypt_key=None,
                  auth_algo=None, auth_key=None, tunnel_header=None, nat_t_header=None, esn_en=False, esn=0):   # noqa: E501
@@ -880,6 +886,23 @@ class SecurityAssociation(object):
                 raise TypeError('nat_t_header must be %s' % UDP.name)
         self.nat_t_header = nat_t_header
 
+    def build_aead(self, esp):
+        if self.esn_en:
+            return (struct.pack('!LLL', esp.spi, self.seq_num >> 32, esp.seq))
+        else:
+            return (struct.pack('!LL', esp.spi, esp.seq))
+
+    def build_seq_num(self, num):
+        # only lower order bits are  transmitted
+        # higher order bits are used in the ICV
+        lower = num & 0xffffffff
+        upper = num >> 32
+
+        if self.esn_en:
+            return lower, struct.pack("!I", upper)
+        else:
+            return lower, None
+
     def check_spi(self, pkt):
         if pkt.spi != self.spi:
             raise TypeError('packet spi=0x%x does not match the SA spi=0x%x' %
@@ -893,7 +916,8 @@ class SecurityAssociation(object):
             if len(iv) != self.crypt_algo.iv_size:
                 raise TypeError('iv length must be %s' % self.crypt_algo.iv_size)  # noqa: E501
 
-        esp = _ESPPlain(spi=self.spi, seq=seq_num or self.seq_num, iv=iv)
+        low_seq_num, high_seq_num = self.build_seq_num(seq_num or self.seq_num)
+        esp = _ESPPlain(spi=self.spi, seq=low_seq_num, iv=iv)
 
         if self.tunnel_header:
             tunnel = self.tunnel_header.copy()
@@ -917,7 +941,7 @@ class SecurityAssociation(object):
                                       esn_en=esn_en or self.esn_en,
                                       esn=esn or self.esn)
 
-        self.auth_algo.sign(esp, self.auth_key)
+        self.auth_algo.sign(esp, self.auth_key, high_seq_num)
 
         if self.nat_t_header:
             nat_t_header = self.nat_t_header.copy()
@@ -944,7 +968,8 @@ class SecurityAssociation(object):
 
     def _encrypt_ah(self, pkt, seq_num=None, esn_en=False, esn=0):
 
-        ah = AH(spi=self.spi, seq=seq_num or self.seq_num,
+        low_seq_num, high_seq_num = self.build_seq_num(seq_num or self.seq_num)
+        ah = AH(spi=self.spi, seq=low_seq_num,
                 icv=b"\x00" * self.auth_algo.icv_size)
 
         if self.tunnel_header:
@@ -985,7 +1010,7 @@ class SecurityAssociation(object):
             ip_header.plen = len(ip_header.payload) + len(ah) + len(payload)
 
         signed_pkt = self.auth_algo.sign(ip_header / ah / payload,
-                                         self.auth_key,
+                                         self.auth_key, high_seq_num,
                                          esn_en=esn_en or self.esn_en,
                                          esn=esn or self.esn)
 
@@ -1025,11 +1050,12 @@ class SecurityAssociation(object):
 
     def _decrypt_esp(self, pkt, verify=True, esn_en=None, esn=None):
 
+        low_seq_num, high_seq_num = self.build_seq_num(self.seq_num)
         encrypted = pkt[ESP]
 
         if verify:
             self.check_spi(pkt)
-            self.auth_algo.verify(encrypted, self.auth_key)
+            self.auth_algo.verify(encrypted, self.auth_key, high_seq_num)
 
         esp = self.crypt_algo.decrypt(self, encrypted, self.crypt_key,
                                       self.crypt_algo.icv_size or
@@ -1070,9 +1096,10 @@ class SecurityAssociation(object):
 
     def _decrypt_ah(self, pkt, verify=True, esn_en=None, esn=None):
 
+        low_seq_num, high_seq_num = self.build_seq_num(self.seq_num)
         if verify:
             self.check_spi(pkt)
-            self.auth_algo.verify(pkt, self.auth_key,
+            self.auth_algo.verify(pkt, self.auth_key, high_seq_num,
                                   esn_en=esn_en or self.esn_en,
                                   esn=esn or self.esn)
 
