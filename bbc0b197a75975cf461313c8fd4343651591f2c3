{
  "comments": [
    {
      "key": {
        "uuid": "e3f3ae7c_95121fea",
        "filename": "src/plugins/crypto_aesni/aes_cbc.c",
        "patchSetId": 9
      },
      "lineNbr": 345,
      "author": {
        "id": 267
      },
      "writtenOn": "2019-08-09T13:21:10Z",
      "side": 1,
      "message": "aren\u0027t the chained async buffers of different op type. the first is a cbc enc and the second a hmac?",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "887e833d_5d2965ee",
        "filename": "src/vnet/crypto/crypto.c",
        "patchSetId": 9
      },
      "lineNbr": 103,
      "author": {
        "id": 267
      },
      "writtenOn": "2019-08-09T13:21:10Z",
      "side": 1,
      "message": "how many queues do we need here? does this represent a significant saving over creating these at  init time? maybe if there is a register async capable engine.",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45581f85_178a78ad",
        "filename": "src/vnet/crypto/crypto.c",
        "patchSetId": 9
      },
      "lineNbr": 114,
      "author": {
        "id": 1849
      },
      "writtenOn": "2019-08-09T08:44:03Z",
      "side": 1,
      "message": "Hi, this part raises a bit concern to me. To me this part is too multi-core CPU based crypto oriented. Let Quickassist goes through this code will suffer the performance quite a bit.",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "627df583_6ee5800e",
        "filename": "src/vnet/crypto/crypto.c",
        "patchSetId": 9
      },
      "lineNbr": 114,
      "author": {
        "id": 189
      },
      "writtenOn": "2019-08-09T10:48:10Z",
      "side": 1,
      "message": "Could you please provide more details why is that? I\u0027m not sure what quickassist does",
      "parentUuid": "45581f85_178a78ad",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "079538c5_842e6780",
        "filename": "src/vnet/crypto/crypto.c",
        "patchSetId": 9
      },
      "lineNbr": 114,
      "author": {
        "id": 1849
      },
      "writtenOn": "2019-08-09T11:26:31Z",
      "side": 1,
      "message": "What I meant was the crypto engine queue design.\n\nFrom your implementation I had the impression:\n1. The queue architecture is fixed in crypto interface.\n2. Although the API works in burst mode, the enqueue operation is done one at a time and the dequeue operation is purely atomic.\n\nThis way I believe will suit multi-core CPU based crypto engines nicely working towards the same queue to share the workload cached in this queue. \n \nHowever for Quickassist (QAT) the assumption is different:\n- A QAT hardware queue can support the ops with mixed algorithms(cipher/auth/aead, and chained), and the number of hardware queues per QAT VF is limited.\n- The cost of \"kicking\" the QAT hardware starting encryption is relatively high. So it is more preferably using burst operation mode, which means maing multiple ops pushed into and fetched out from QAT at one time. In this case the cost of \"kicking\" can be averaged out by the number of ops.\n\nTo me the queue architecture is crypto engine specific, so instead of sharing the queue operation detail amongst all crypto engines underneath, I think it is better to hide inside the crypto engine. The crypto interface implementation could only pass the queue index into the crypto engine.",
      "parentUuid": "627df583_6ee5800e",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9219d7af_a2a4788c",
        "filename": "src/vnet/crypto/crypto.c",
        "patchSetId": 9
      },
      "lineNbr": 114,
      "author": {
        "id": 267
      },
      "writtenOn": "2019-08-09T13:21:10Z",
      "side": 1,
      "message": "Hi Fan,\n\nthe engine\u0027s handler is passed the queue of outstanding jobs in crypto_dispatch_node_one_queue(). it is free to dequeue as many jobs as it chooses. this function will be polled, so the engine can return jobs one at a time, even though it may process them in a batch.",
      "parentUuid": "079538c5_842e6780",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "05433c02_8a30bea5",
        "filename": "src/vnet/crypto/crypto.c",
        "patchSetId": 9
      },
      "lineNbr": 114,
      "author": {
        "id": 1849
      },
      "writtenOn": "2019-08-09T15:05:33Z",
      "side": 1,
      "message": "Hi Neale, \n\nThanks for the explain. I got the idea. This means a QAT crypto engine working in a polling mode needs to write the dequeued ops from the hardware into the engine queue for workers to pick up. This brings up a second question - possibly for Filip: \n\nwhy are the queues are algorithm indexed? Not to mention you need up to 29 queues per thread, it does not take QAT into consideration - as again QAT has limited hardware queues, we have to gather the ops from different queues and enqueue to the one hardware queue, and then we have to reclassify so the dequeued ops can be distributed to the crypto engine queues - right before the worker gather them possibly from all these 29 queues into a burst of packets for the next node. Even worse such unnecessary process may have to be done twice - since the crypto engine does not support chained operation.",
      "parentUuid": "9219d7af_a2a4788c",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "800f86d7_39b4e9ed",
        "filename": "src/vnet/crypto/crypto.c",
        "patchSetId": 9
      },
      "lineNbr": 122,
      "author": {
        "id": 267
      },
      "writtenOn": "2019-08-09T13:21:10Z",
      "side": 1,
      "message": "queues for other operations in the job may not be full. so continue not break?",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "87583d0f_b30fbd02",
        "filename": "src/vnet/crypto/crypto.h",
        "patchSetId": 9
      },
      "lineNbr": 19,
      "author": {
        "id": 267
      },
      "writtenOn": "2019-08-09T13:21:10Z",
      "side": 1,
      "message": "comment or static assert that this is a power of 2.",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3aa2245_a44c1a87",
        "filename": "src/vnet/crypto/crypto.h",
        "patchSetId": 9
      },
      "lineNbr": 152,
      "author": {
        "id": 1849
      },
      "writtenOn": "2019-08-09T08:44:03Z",
      "side": 1,
      "message": "In case the hardware acceleration crypto engine is used (say Quickassist) can I get the physical addresses of buffer/digest/aad from this structure?",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2216b694_e76e77f8",
        "filename": "src/vnet/crypto/crypto.h",
        "patchSetId": 9
      },
      "lineNbr": 152,
      "author": {
        "id": 189
      },
      "writtenOn": "2019-08-09T10:48:10Z",
      "side": 1,
      "message": "\u0027vnet_crypto_op_t data\u0027 field contains everything you need. Buffer index is stored in user_data, so calling vlib_get_buffer() you get the buffer pointer.",
      "parentUuid": "a3aa2245_a44c1a87",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "10a7a9e1_7fb7b82e",
        "filename": "src/vnet/crypto/crypto.h",
        "patchSetId": 9
      },
      "lineNbr": 170,
      "author": {
        "id": 267
      },
      "writtenOn": "2019-08-09T13:21:10Z",
      "side": 1,
      "message": "*jobs; not *jobs[0];",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e20d61c4_04575867",
        "filename": "src/vnet/ipsec/esp_encrypt.c",
        "patchSetId": 9
      },
      "lineNbr": 505,
      "author": {
        "id": 267
      },
      "writtenOn": "2019-08-09T13:21:10Z",
      "side": 1,
      "message": "can these also be allocated from the per-thread data to save this vec_add/vec_del overhead for each packet?",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "22acbdec_71eba7eb",
        "filename": "src/vnet/ipsec/esp_encrypt.c",
        "patchSetId": 9
      },
      "lineNbr": 610,
      "author": {
        "id": 267
      },
      "writtenOn": "2019-08-09T13:21:10Z",
      "side": 1,
      "message": "j can be NULL either because the queue is empty or because of contention. to you want to break from the loop in the case of the former?",
      "revId": "bbc0b197a75975cf461313c8fd4343651591f2c3",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    }
  ]
}