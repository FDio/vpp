{
  "comments": [
    {
      "key": {
        "uuid": "a7263af8_c13614b9",
        "filename": "src/vlib/unix/input.c",
        "patchSetId": 3
      },
      "lineNbr": 258,
      "author": {
        "id": 193
      },
      "writtenOn": "2021-03-03T18:05:29Z",
      "side": 1,
      "message": "Use the now computed at the beginning of the function by removing the if (main \u003d\u003d 0)",
      "range": {
        "startLine": 258,
        "startChar": 1,
        "endLine": 258,
        "endChar": 26
      },
      "revId": "bd77ac83abdeb328bf7608ae4e25441542f8092e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "241a4ac1_8b8c4e53",
        "filename": "src/vlib/unix/input.c",
        "patchSetId": 3
      },
      "lineNbr": 258,
      "author": {
        "id": 320
      },
      "writtenOn": "2021-03-06T07:23:54Z",
      "side": 1,
      "message": "I didn’t want to interfere with the current logic or future change thereof in https://gerrit.fd.io/r/c/vpp/+/31368/3/src/vlib/unix/input.c#168,\n\nAnd afaik it’s an inexpensive call (single value copy), which considering previously we were about to fall asleep for 10ms anyway, didn’t seem too terrible...\n\nSo it’s a bit of clarity/maintainability trade off at the expense of a few bytes copy...\n\nWhat do you think ?",
      "parentUuid": "a7263af8_c13614b9",
      "range": {
        "startLine": 258,
        "startChar": 1,
        "endLine": 258,
        "endChar": 26
      },
      "revId": "bd77ac83abdeb328bf7608ae4e25441542f8092e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0d8a0b8_2c10474c",
        "filename": "src/vlib/unix/input.c",
        "patchSetId": 3
      },
      "lineNbr": 258,
      "author": {
        "id": 193
      },
      "writtenOn": "2021-03-06T17:41:00Z",
      "side": 1,
      "message": "I was actually thinking about the rdtsc instruction at the end of the chain in clib_cpu_time_now. As for clarity, it\u0027ll end up being a personal choice as I like to have only one source of now per function. But this is just a nit, so feel free to ignore it ;-)",
      "parentUuid": "241a4ac1_8b8c4e53",
      "range": {
        "startLine": 258,
        "startChar": 1,
        "endLine": 258,
        "endChar": 26
      },
      "revId": "bd77ac83abdeb328bf7608ae4e25441542f8092e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "473ef4da_fdd9169b",
        "filename": "src/vlib/unix/input.c",
        "patchSetId": 3
      },
      "lineNbr": 258,
      "author": {
        "id": 320
      },
      "writtenOn": "2021-03-06T21:47:20Z",
      "side": 1,
      "message": "Ok, so having the whole \"new\" snippet only in main thread (thus avoiding the double call to vlib_time_now()) costs ~5K API calls/sec for multiworker scenario... similarly removing the check in the above in vocation and reusing the value of now here costs about the same in both 3-worker and 0-worker cases... We were about to go to sleep for 10ms here anyway previously, so I think keeping it (and the free extra 5k of performance gain) would be ok ?",
      "parentUuid": "c0d8a0b8_2c10474c",
      "range": {
        "startLine": 258,
        "startChar": 1,
        "endLine": 258,
        "endChar": 26
      },
      "revId": "bd77ac83abdeb328bf7608ae4e25441542f8092e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e62a429_e65050ce",
        "filename": "src/vlib/unix/input.c",
        "patchSetId": 3
      },
      "lineNbr": 258,
      "author": {
        "id": 193
      },
      "writtenOn": "2021-03-06T23:14:56Z",
      "side": 1,
      "message": "Hm, if we call vlib_time_now more often we gain api speed? That\u0027s a bit counter intuitive.",
      "parentUuid": "473ef4da_fdd9169b",
      "range": {
        "startLine": 258,
        "startChar": 1,
        "endLine": 258,
        "endChar": 26
      },
      "revId": "bd77ac83abdeb328bf7608ae4e25441542f8092e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93e708c5_c38beb41",
        "filename": "src/vlib/unix/input.c",
        "patchSetId": 3
      },
      "lineNbr": 258,
      "author": {
        "id": 320
      },
      "writtenOn": "2021-03-08T08:20:29Z",
      "side": 1,
      "message": "You are right, I had initially thought of https://gerrit.fd.io/r/c/vpp/+/31368/3/src/vlib/unix/input.c#168 somehow playing a role,\nBut upon a look with a coffee, see that it’s impossible...\nYou are right, this is worth investigating a bit more, will look at that...",
      "parentUuid": "2e62a429_e65050ce",
      "range": {
        "startLine": 258,
        "startChar": 1,
        "endLine": 258,
        "endChar": 26
      },
      "revId": "bd77ac83abdeb328bf7608ae4e25441542f8092e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0e48d9e_a484b666",
        "filename": "src/vlib/unix/input.c",
        "patchSetId": 3
      },
      "lineNbr": 259,
      "author": {
        "id": 193
      },
      "writtenOn": "2021-03-03T18:05:29Z",
      "side": 1,
      "message": "Instead of tracking the last time we got api work, wouldn\u0027t it be better to track last time we did any work related to this node? Meaning the issue could affect all unix epoll consumers, not only the api. \n\nFor instance, we could track last time we got epoll events in the epoll_pwait lower. If it was less than timeout_ms, don\u0027t sleep yet. This line then becomes:\n\ntimeout_ms \u003d clib_min (timeout_ms, (now - em-\u003elast_time_work_done) * 10e3)\n\nAlthough, wouldn\u0027t it be better to not sleep if now - em-\u003elast_time_work_done \u003c 10ms?",
      "range": {
        "startLine": 259,
        "startChar": 16,
        "endLine": 259,
        "endChar": 45
      },
      "revId": "bd77ac83abdeb328bf7608ae4e25441542f8092e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e83b209f_fceb0046",
        "filename": "src/vlib/unix/input.c",
        "patchSetId": 3
      },
      "lineNbr": 259,
      "author": {
        "id": 320
      },
      "writtenOn": "2021-03-06T07:23:54Z",
      "side": 1,
      "message": "This is explicitly not about the Unix epoll consumers but about shared memory consumers that are left hanging because there is no way to signal that we got something on the shared memory queue while we are in the epoll sleep. When I am using Unix socket for api the issue is not present because it returns immediately when there is something to be received in that socket.\n\nSo it’s really all about having received *shared memory* events while sleeping awaiting for the events in the *unix* socket.\n\nSo the heuristic is “if we got shared memory events during the last sleep, be a bit more conservative with going to sleep for long (10ms) periods in case there is more events to come, such that we can service them in a more timely fashion”\n\nMakes sense ?",
      "parentUuid": "b0e48d9e_a484b666",
      "range": {
        "startLine": 259,
        "startChar": 16,
        "endLine": 259,
        "endChar": 45
      },
      "revId": "bd77ac83abdeb328bf7608ae4e25441542f8092e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e1e33da7_ce24a667",
        "filename": "src/vlib/unix/input.c",
        "patchSetId": 3
      },
      "lineNbr": 259,
      "author": {
        "id": 193
      },
      "writtenOn": "2021-03-06T17:41:00Z",
      "side": 1,
      "message": "Yes it does, somehow I thought this is a case of us not draining the socket buffer on an EPOLLIN. \n\nBut then, isn\u0027t this a case of the logic being confused because vm-\u003eapi_queue_nonempty is ignored here [1]? \n\n[1] https://gerrit.fd.io/r/c/vpp/+/31368/3/src/vlib/unix/input.c#212",
      "parentUuid": "e83b209f_fceb0046",
      "range": {
        "startLine": 259,
        "startChar": 16,
        "endLine": 259,
        "endChar": 45
      },
      "revId": "bd77ac83abdeb328bf7608ae4e25441542f8092e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d37ff23a_42322e2d",
        "filename": "src/vlib/unix/input.c",
        "patchSetId": 3
      },
      "lineNbr": 259,
      "author": {
        "id": 320
      },
      "writtenOn": "2021-03-06T20:19:16Z",
      "side": 1,
      "message": "I outright felt that attempting to muck with that logic would be \"here be dragons\" situation :)\nbut I think still the api_queue may have been processed already... because in my tests I am strictly waiting for the reply after each request - so there is never more than 1 outstanding message in the queue...",
      "parentUuid": "e1e33da7_ce24a667",
      "range": {
        "startLine": 259,
        "startChar": 16,
        "endLine": 259,
        "endChar": 45
      },
      "revId": "bd77ac83abdeb328bf7608ae4e25441542f8092e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "166a9b6f_4fcc305a",
        "filename": "src/vlib/unix/input.c",
        "patchSetId": 3
      },
      "lineNbr": 259,
      "author": {
        "id": 193
      },
      "writtenOn": "2021-03-06T23:14:56Z",
      "side": 1,
      "message": "As far as I can remember, we unset vm-\u003eapi_queue_nonempty only if the clnt_process didn\u0027t find anything in the binary api last time it tried (which could\u0027ve been this dispatch loop or some previous one). I guess this does mean that the logic here will be tempted to quickly enter sleep. To counteract that we\u0027d probably want some form of moving average ... Oh well. \n\nAs for the logic, it already feels too complex and tricky but that\u0027s probably an experiment for another time. Speaking of which, how do you test this?",
      "parentUuid": "d37ff23a_42322e2d",
      "range": {
        "startLine": 259,
        "startChar": 16,
        "endLine": 259,
        "endChar": 45
      },
      "revId": "bd77ac83abdeb328bf7608ae4e25441542f8092e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8be1968f_637d3e01",
        "filename": "src/vlib/unix/input.c",
        "patchSetId": 3
      },
      "lineNbr": 259,
      "author": {
        "id": 320
      },
      "writtenOn": "2021-03-08T08:20:29Z",
      "side": 1,
      "message": "Yeah this is basically attempting to predict the future here based on the past behavior... always tricky :-)\n\nI am testing with this jig:\n\nhttps://github.com/ayourtch/vpp-api-transport\n\nIt’s the lowest level of abstraction in my side project..\nTo make shared mem and Unix socket look the same -\nAnd can get to a reasonable speed. :)",
      "parentUuid": "166a9b6f_4fcc305a",
      "range": {
        "startLine": 259,
        "startChar": 16,
        "endLine": 259,
        "endChar": 45
      },
      "revId": "bd77ac83abdeb328bf7608ae4e25441542f8092e",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2",
      "unresolved": true
    }
  ]
}