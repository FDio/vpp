{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "3279f416_b52c8da1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 2479
      },
      "writtenOn": "2023-05-10T12:43:14Z",
      "side": 1,
      "message": "recheck",
      "revId": "eb05829e797ab8cc26d677934bd06e49d2119b47",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0bae9358_b5882840",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 2479
      },
      "writtenOn": "2023-05-11T06:54:03Z",
      "side": 1,
      "message": "recheck",
      "revId": "eb05829e797ab8cc26d677934bd06e49d2119b47",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44946147_a35ee8ef",
        "filename": "src/plugins/wireguard/wireguard_input.c",
        "patchSetId": 1
      },
      "lineNbr": 791,
      "author": {
        "id": 2832
      },
      "writtenOn": "2023-05-15T11:02:21Z",
      "side": 1,
      "message": "move this line into the if(is_cookie \u003d\u003d true) statement in L.794",
      "revId": "eb05829e797ab8cc26d677934bd06e49d2119b47",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c4e4674_54707636",
        "filename": "src/plugins/wireguard/wireguard_input.c",
        "patchSetId": 1
      },
      "lineNbr": 791,
      "author": {
        "id": 2832
      },
      "writtenOn": "2023-05-15T11:02:21Z",
      "side": 1,
      "message": "recommend rename variable handshake_rate to process_rate",
      "revId": "eb05829e797ab8cc26d677934bd06e49d2119b47",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b2c2e97e_9f130824",
        "filename": "src/plugins/wireguard/wireguard_input.c",
        "patchSetId": 1
      },
      "lineNbr": 791,
      "author": {
        "id": 2479
      },
      "writtenOn": "2023-05-18T06:47:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "44946147_a35ee8ef",
      "revId": "eb05829e797ab8cc26d677934bd06e49d2119b47",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b91c967a_79a56e3e",
        "filename": "src/plugins/wireguard/wireguard_input.c",
        "patchSetId": 1
      },
      "lineNbr": 791,
      "author": {
        "id": 2479
      },
      "writtenOn": "2023-05-18T06:47:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0c4e4674_54707636",
      "revId": "eb05829e797ab8cc26d677934bd06e49d2119b47",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "671ef121_3f3ca596",
        "filename": "src/plugins/wireguard/wireguard_input.c",
        "patchSetId": 1
      },
      "lineNbr": 811,
      "author": {
        "id": 1388
      },
      "writtenOn": "2023-05-12T13:48:38Z",
      "side": 1,
      "message": "`wmp-\u003emax_handshake_cookie` seem to represent the rate that the server can generate cookies, as this branch is only executed when a cookie was sent in reply. And looking at the updated version of `wg_if_is_under_load()`, `wmp-\u003emax_handshake_cookie` is used there as if it was the rate that the server can process handshake messages. So the value and the use-case don\u0027t seem to agree.\n\nCan you clarify if my conclusions are correct? If so, can handshake rate be used instead of cookie rate for making decisions?",
      "revId": "eb05829e797ab8cc26d677934bd06e49d2119b47",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8aa78929_ef538e5a",
        "filename": "src/plugins/wireguard/wireguard_input.c",
        "patchSetId": 1
      },
      "lineNbr": 811,
      "author": {
        "id": 2832
      },
      "writtenOn": "2023-05-15T11:02:21Z",
      "side": 1,
      "message": "I think the naming here can be improve a bit, \nhandshake_rate \u003d process rate, the actual number of handshake process the system can handle. This  value is represent handshake rate if NOT is_cookie, and cookie rate if is_cookie is true. \nThe under-load state where decided in the function of wg_if_is_under_load(), only takes the input of handshake_cookie_rate and inflight number parameters, the handshake rate is not used in the under-load state decision making.",
      "parentUuid": "671ef121_3f3ca596",
      "revId": "eb05829e797ab8cc26d677934bd06e49d2119b47",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "db78a590_5141e490",
        "filename": "src/plugins/wireguard/wireguard_input.c",
        "patchSetId": 1
      },
      "lineNbr": 811,
      "author": {
        "id": 1388
      },
      "writtenOn": "2023-05-15T11:33:46Z",
      "side": 1,
      "message": "\u003e The under-load state where decided in the function of wg_if_is_under_load(), only takes the input of handshake_cookie_rate and inflight number parameters, the handshake rate is not used in the under-load state decision making.\n\nThat\u0027s exactly my point. `wg_if_is_under_load()` indeed uses `handshake_cookie_rate` but uses the value as if it was the handshake rate. Even the comment there says it is supposed to be the handshake rate and not the cookie rate:\n\n```\n/* check if vpp will be able to do handshake process before each\n * REKEY_TIMEOUT time, if not then under load state is activate\n */\n```\n\nThis version is predicting how many cookies the server can generate. But the server does not process cookies. It processes handshakes and thus, handshake rate is actually what is needed to be able to predict whether the server will be able to process all incoming handshakes in normal mode.\n\nTo sum up, my comment is not about naming. It\u0027s about logic.",
      "parentUuid": "8aa78929_ef538e5a",
      "revId": "eb05829e797ab8cc26d677934bd06e49d2119b47",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c88ad44b_11e799ab",
        "filename": "src/plugins/wireguard/wireguard_input.c",
        "patchSetId": 1
      },
      "lineNbr": 811,
      "author": {
        "id": 2479
      },
      "writtenOn": "2023-05-15T11:59:21Z",
      "side": 1,
      "message": "\"wmp-\u003ehandshake_cookie_rate” represents the rate that the server can generate cookies, and this value will be updated only when a cookie is sent in reply. \nIn function “wg_if_is_under_load()” this calculated value is used for prediction if wireguard should activate under load state and this value still represents the predicted rate with which server can generate cookies and here wireguard predicts how much time would spend to reply each handshake by cookie messages and if this time will be longer than the remaining time then under load state will be activated. It is important to consider cookie rate and not handshake rate, as in this case response by normal handshake flow won’t be good enough, because it will take longer time than response by cookie message and we want to consume everything before each REKEY_TIMEOUT, for example:\n- 10k handshake messages to handle,\n- handshake rate in no underload state \u003d 1k per second (this value IS NOT calculated by wireguard),\n- handshake cookie rate \u003d 100k per second (this value IS calculated by wireguard)\n\nThis case in original implementation, will be handled as follows:\nWireguard received 10k in the first storm of handshake and wg is able to consume only \"REKEY_TIMEOUT * 1kps\" handshake message – it is around 5k handshakes. Now the other side will send again 5k new handshake messages after REKEY_TIMEOUT \u003d 5s + jitter, so it means that wireguard has 5k old handshakes and 5k newest handshakes, but still wg can consume only 5k handshakes and will consume the oldest handshakes not the newest handshakes (due to handoff algorithm), time \"5s+jitter\" again was passed and again the other side sends new 5k handshake messages. This process continues.\n\nWith my changes this scenario will be handled differently because when wg will receive 10k handshake messages in the first storm, then wg will consume as soon as possible handshake messages in normal way, but WHEN prediction detects that wireguard should start reply by cookie messages because under load state will be reached then wg consumes each remaining handshakes for the 10k handshake messages from the first storm. So, after the first REKEY_TIME there won’t be any handshakes in the queue, so another side will send for the last handshake messages (for example in this case around 5.5k handshake messages) but again wg won’t be able to consume each handshake before REKEY_TIME is reached but still wg will consume as soon as possible handshakes in the normal way and the rest of remining handshakes will be replied as cookie messages. \n\nIn the original implementation we have the increasing queue because wg will receive a lot of handshakes and won’t be able to reply in the \"REKEY_TIME + jitter\". With my changes wg will be trying to consume as soon as possible handshake messages and reply to the rest of them by cookie messages. \n\nThis situation WON\u0027T occur when wireguard receives less than \"REKEY_TIME x handshake_rate\" – because in this case wg will be able to consume everything before REKEY_TIME, but will notice that there is a problem when receives more handshakes than \"REKEY_TIME x handshake_rate\", and due to this fact the under load state was introduced and there isn’t any suggestion how to reach this state in the whitepaper for wireguard – so it is my understanding, how it should be activated.",
      "parentUuid": "db78a590_5141e490",
      "revId": "eb05829e797ab8cc26d677934bd06e49d2119b47",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ad0e507a_9590f609",
        "filename": "src/plugins/wireguard/wireguard_input.c",
        "patchSetId": 1
      },
      "lineNbr": 811,
      "author": {
        "id": 2832
      },
      "writtenOn": "2023-05-15T15:10:29Z",
      "side": 1,
      "message": "If my understadning is correct,  the logic here is: \n\nWhen inflight handshake request number is bigger than the handshake_cookie_rate * (time to REKEY TIMEOUT + jitter), the under-load state is set and is_cookie to true. In this way,  the server can eliminate the rekey completely and prevent endless enqueue during the handshake process. Thus the handshake_rate is not really relevant here.",
      "parentUuid": "c88ad44b_11e799ab",
      "revId": "eb05829e797ab8cc26d677934bd06e49d2119b47",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    }
  ]
}