{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c26bc2bc_e35b889e",
        "filename": "src/vpp-api/vapi/vapi.c",
        "patchSetId": 5
      },
      "lineNbr": 400,
      "author": {
        "id": 601
      },
      "writtenOn": "2024-03-08T12:45:35Z",
      "side": 1,
      "message": "This should be before the possible return -1 above.",
      "revId": "fbc1adc87b2e58318978e2a85d530ddaf97fc8fa",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f761d7c6_1a381f73",
        "filename": "src/vpp-api/vapi/vapi.c",
        "patchSetId": 5
      },
      "lineNbr": 400,
      "author": {
        "id": 2220
      },
      "writtenOn": "2024-03-08T13:01:22Z",
      "side": 1,
      "message": "I\u0027m not 100% sure about this one. In vapi.hpp code I see the following code\n```\n    vapi_error_e rv \u003d vapi_send (vapi_ctx, req-\u003erequest.shm_data);\n    if (VAPI_OK \u003d\u003d rv)\n      {\n...\n        req-\u003erequest.shm_data \u003d nullptr; /* consumed by vapi_send */\n      }\n    else\n      {\n        vapi_swap_to_host\u003cReq\u003e (req-\u003erequest.shm_data);\n      }\n```\nand in the dctor of `class Msg` there\u0027s an explicit `msg_free` call.\n\nThough we can make vapi_msg_free tolerant to already freed vectors.\n\nWhat do you think?",
      "parentUuid": "c26bc2bc_e35b889e",
      "revId": "fbc1adc87b2e58318978e2a85d530ddaf97fc8fa",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b23f667_f4fb0634",
        "filename": "src/vpp-api/vapi/vapi.c",
        "patchSetId": 5
      },
      "lineNbr": 400,
      "author": {
        "id": 601
      },
      "writtenOn": "2024-03-08T14:04:06Z",
      "side": 1,
      "message": "538   ~Msg ()\n   539   {\n   540     VAPI_DBG (\"Destroy Msg\u003c%s\u003e@%p, shm_data@%p\",\n   541               vapi_get_msg_name (get_msg_id ()), this, shm_data);\n   542     if (shm_data)\n   543       {\n   544         con.get ().msg_free (shm_data);\n   545         shm_data \u003d nullptr;\n   546       }\n   547   }\n   \nI see a NULL-check on line 542, so msg_free() is called only if vapi_send() fails. So C++ world is good.\n   \nBut in C world the convention is:\n\nvapi_msg_sw_interface_set_flags* flags \u003d vapi_alloc_sw_interface_set_flags(ctx);\n...\nif (VAPI_EAGAIN \u003d\u003d vapi_sw_interface_set_flags (ctx, msg, reply_callback))\n{\n  vapi_msg_free(flags);\n}\n\nso the caller frees the message if it\u0027s not consumed. VAPI cannot do that in vapi_sw_interface_set_flags(), because that could impact performance - a caller might want to retry sending the message without having to allocate and initialise a new one.\n\nWith that in mind, I take back my previous comment. The ordering is good as it is - on success, the message is consumed and the caller doesn\u0027t have to do anything else with it. But in error case the API contract is broken as the caller gets \u0027-1\u0027, which then vapi_send() returns as vapi_error_e and the caller gets garbage. I\u0027d say that vapi_sock_send[2]() should return proper vapi_error_e values. Especially EAGAIN is crucial to avoid memory leaks (however unlikely the failures are).",
      "parentUuid": "f761d7c6_1a381f73",
      "revId": "fbc1adc87b2e58318978e2a85d530ddaf97fc8fa",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "45d2ed3b_56cfc123",
        "filename": "src/vpp-api/vapi/vapi.c",
        "patchSetId": 5
      },
      "lineNbr": 400,
      "author": {
        "id": 2220
      },
      "writtenOn": "2024-03-08T14:50:10Z",
      "side": 1,
      "message": "Thanks for pointing out at C code. Fixed here, but there are some other places of vapi that return `-1`. I suggest leave them be as shm code also does the same.\n\nBut if you have another opinion on it - let\u0027s fix them as well.",
      "parentUuid": "8b23f667_f4fb0634",
      "revId": "fbc1adc87b2e58318978e2a85d530ddaf97fc8fa",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7892e213_76445a6e",
        "filename": "src/vpp-api/vapi/vapi.c",
        "patchSetId": 5
      },
      "lineNbr": 400,
      "author": {
        "id": 601
      },
      "writtenOn": "2024-03-08T17:42:26Z",
      "side": 1,
      "message": "I\u0027m not sure what you mean. I only see return -1 in vapi_client_connect/disconnect, which is code written by somebody else - I haven\u0027t studied it in depth, but it looks like unnecessary code duplication at glance. Anyhow, its return values are then converted to vapi_error_e - where applicable.\n\nWhat I don\u0027t like is if it\u0027s mixed. If you have a function, either have it return -1/0 and decide what do with it (in terms of which VAPI error to present to user) or have it return VAPI error. But don\u0027t mix it.",
      "parentUuid": "45d2ed3b_56cfc123",
      "revId": "fbc1adc87b2e58318978e2a85d530ddaf97fc8fa",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5515bea0_ad6cdfbd",
        "filename": "src/vpp-api/vapi/vapi.c",
        "patchSetId": 5
      },
      "lineNbr": 400,
      "author": {
        "id": 2220
      },
      "writtenOn": "2024-03-09T08:58:14Z",
      "side": 1,
      "message": "Yes, I was talking about connect/disconnect code. In connect we can return `VAPI_ECONFAIL`, in disconnect `VAPI_ENORESP`.\n\nWhat\u0027s my concert is that we can hit a socket error (that\u0027d mean the socket was closed). There\u0027s `return -1` in vapi_sock_recv when we hit error on socket read. The similar way it was on vapi_sock_send. \n\nWe need to tell the upper layer that we were disconnected and some action should be taken.",
      "parentUuid": "7892e213_76445a6e",
      "revId": "fbc1adc87b2e58318978e2a85d530ddaf97fc8fa",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3de8d1f5_47178017",
        "filename": "src/vpp-api/vapi/vapi.c",
        "patchSetId": 5
      },
      "lineNbr": 400,
      "author": {
        "id": 601
      },
      "writtenOn": "2024-03-10T09:09:43Z",
      "side": 1,
      "message": "Ah, I know what you mean now. Original shared memory transport doesn\u0027t have this so this a new concept which needs to be introduced. Looking at standard errors which e.g. sendmsg() returns, I think we should add VAPI_ECONNRESET (and others - if applicable, like VAPI_EACCES, VAPI_EINTR, VAPI_EOPNOTSUPP - if it\u0027s a possibility that our calls return X, whould pass VAPI_X to the user if we can\u0027t work around it - if nothing else, than the human somewhere up the chain can debug it easier (e.g. if permissions are wrong and VAPI_EACCES pops up).",
      "parentUuid": "5515bea0_ad6cdfbd",
      "revId": "fbc1adc87b2e58318978e2a85d530ddaf97fc8fa",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    }
  ]
}