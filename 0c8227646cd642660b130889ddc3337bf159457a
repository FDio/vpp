{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "689c6642_ea8aa82f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 680
      },
      "writtenOn": "2025-09-05T18:25:17Z",
      "side": 1,
      "message": "To minimize the impact of the lock, I think we should use clib_spinlock_trylock. If the lock is held by the other thread, the other thread will do the kick. This thread does not have to wait and just continue.",
      "revId": "0c8227646cd642660b130889ddc3337bf159457a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "106e9b56_9027f860",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 680
      },
      "writtenOn": "2025-09-05T18:28:56Z",
      "side": 1,
      "message": "I mean clib_spinlock_trylock_if_init",
      "parentUuid": "689c6642_ea8aa82f",
      "revId": "0c8227646cd642660b130889ddc3337bf159457a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7b2846a5_e3796bb8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1388
      },
      "writtenOn": "2025-09-08T08:28:56Z",
      "side": 1,
      "message": "I guess try_lock() would work well if the interrupt triggering logic in different threads was the same. However, the input logic in vhost_user_input_do_interrupt() is responsible for triggering an interrupt by time whereas the output logic in the device TX function triggers an interrupt when a certain number of frames piled up. Trying to lock, failing, and then skipping one of those blocks may cause undesired effects. For example, the current number of frames is low but it\u0027s time to trigger an interrupt by time. And vice versa, the required number of frames has piled up but it\u0027s early to trigger an interrupt by time. If the appropriate block is missed, probably many times in a row, there will be zero interrupts for some time. Moreover, the device TX function also increments the number of frames. If skip that block often, there will not be data to decide to trigger an interrupt.",
      "parentUuid": "106e9b56_9027f860",
      "revId": "0c8227646cd642660b130889ddc3337bf159457a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13186201_acfa4f04",
        "filename": "src/plugins/vhost/vhost_user.c",
        "patchSetId": 1
      },
      "lineNbr": 307,
      "author": {
        "id": 680
      },
      "writtenOn": "2025-09-04T17:09:58Z",
      "side": 1,
      "message": "Should we only call clib_spinlock_init for the rxq? That way we can remove the test is_rxq in the loop in the function vhost_user_send_interrupt_process.",
      "revId": "0c8227646cd642660b130889ddc3337bf159457a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f99d79de_9a49e4ed",
        "filename": "src/plugins/vhost/vhost_user.c",
        "patchSetId": 1
      },
      "lineNbr": 307,
      "author": {
        "id": 1388
      },
      "writtenOn": "2025-09-05T12:28:07Z",
      "side": 1,
      "message": "int_lock mainly follows vring_lock, which is also only used for rxvq but initialized for both directions. I think we should probably leave this the way it is as an acceptable way.",
      "parentUuid": "13186201_acfa4f04",
      "revId": "0c8227646cd642660b130889ddc3337bf159457a",
      "serverId": "6d2eb258-4fe2-443e-8a38-ca81da23d4c2"
    }
  ]
}